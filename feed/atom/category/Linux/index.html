<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/Linux/"
>
<title type="text">Marco Nie - Linux</title>
<subtitle type="text"></subtitle>
<updated>2021-04-01T16:22:46+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/Linux/" />
<id>https://blog.niekun.net/feed/atom/category/Linux/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" />
<entry>
<title type="html"><![CDATA[Linux 脚本中的 Shebang #!]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2287.html" />
<id>https://blog.niekun.net/archives/2287.html</id>
<updated>2021-04-01T16:22:46+08:00</updated>
<published>2021-04-01T16:22:46+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在 Linux 中，当我们准备运行一个可执行文件时，execve 程序会建立一个新的进程替代当前的进程(如终端下的 bash)，同时决定如何完成这个执行任务。当我们执行一个文本文件时，execv...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2287.html" xml:lang="zh-CN"><![CDATA[
<p>在 Linux 中，当我们准备运行一个可执行文件时，execve 程序会建立一个新的进程替代当前的进程(如终端下的 bash)，同时决定如何完成这个执行任务。</p><p>当我们执行一个文本文件时，execve 需要文本文件的开头两个字符为 <code>“#!</code> 读作：<strong>shebang</strong>，同时跟随一个解释器的路径用来解释后续的脚本文本内容。</p><p>下面我们举例说明。</p><!--more--><h3>shell 脚本</h3><p>最常用的就是在 shell 脚本中使用 shebang，下面是一个简单的示例：</p><pre><code>#!/bin/sh
echo &quot;Hello, ${USER}&quot;</code></pre><p>我们定义了此脚本的解释器为 <code>/bin/sh</code>，后续的脚本内容会通过此解释器来运行。</p><p>实际上 <code>/bin/sh</code> 是当前系统可执行 shell 命令的程序的软链接，大多数情况下它表示 bash，但为了不同系统的兼容性和安全性，我们直接使用此软链接来表示当前系统支持的 shell 可执行程序。</p><p>同时需要注意的是，可执行文本文件必须有执行权限，当创建一个新的脚本文件时，需要对其设置执行权限：</p><pre><code>chmod +x test.sh
</code></pre><h3>其他解释器</h3><p>当然我们可以根据需要定义其他的解释器，而不仅仅是 sh。下面的示例我们将 cat 作为解释器，这样就会输出脚本本身的内容：</p><pre><code>#!/bin/cat
Hello World!</code></pre><h3>调用 PATH</h3><p>上面的示例中，我们定义的解释器的绝对路径，但是当我们不知道一个程序的明确的路径时，我们可以通过将解释器定义为 env 程序，并传递实际需要的解释器程序名称，env 会自动在当前用户 PATH 环境变量中查询程序的路径并作为解释器执行脚本。</p><p>下面我们通过 env 来查询 node 并作为解释器执行 node 脚本：</p><pre><code>#!/usr/bin/env node
console.log('Hello world!');</code></pre><p>以上就是对 shebang 的简单解释。</p><h3>参考链接</h3><p><a href="https://www.baeldung.com/linux/shebang">Using Shebang #! in Linux Scripts</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2287.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2287.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu desktop 配置 vnc server]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2281.html" />
<id>https://blog.niekun.net/archives/2281.html</id>
<updated>2021-03-31T11:26:00+08:00</updated>
<published>2021-03-31T11:26:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[通过 VNC(Virtual Network Computing) 可以使用一个图形化的界面来访问远程服务器。这样对服务器的操作可以更加便捷直观。下面我们在 Ubuntu 上安装 TightVN...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2281.html" xml:lang="zh-CN"><![CDATA[
<p>通过 VNC(Virtual Network Computing) 可以使用一个图形化的界面来访问远程服务器。这样对服务器的操作可以更加便捷直观。</p><p>下面我们在 Ubuntu 上安装 TightVNC vnc server 并通过更加安全的 SSH tunnel 来连接服务器。</p><p>环境需求：</p><ul><li>远程主机 Ubuntu desktop 20.04</li><li>关闭 ufw 防火墙或配置允许 openssh 远程连接</li><li>本地设备 vnc 客户端需要支持 SSH tunnels 连接，如： TightVNC, RealVNC, or UltraVNC.</li></ul><!--more--><h3>安装</h3><p>Ubuntu 本身没有安装 vnc 服务，下面我们通过安装 <strong>Xfce</strong> 桌面环境服务和 <strong>TightVNC</strong> 来实现，它们都很轻量及快速，很适合配置 vnc server。</p><p>首先安装 xfce 及其增强包：</p><pre><code>sudo apt install xfce4 xfce4-goodies
</code></pre><p>安装过程中会提示需要选择 xfce 的一个默认 display manager 显示管理器，它是用来在登录系统时的一个图像界面来输入用户及密码的，由于我们只是使用 xfce 来连接 vnc 客户端，且此时已经登陆了对应账户了，所以这里我们任意选择一个显示管理器即可。</p><p>下面安装 TightVNC server：</p><pre><code>sudo apt install tightvncserver
</code></pre><p>安装完成后，我们运行 vncserver 来设置一个 vnc 密码，并且初始化相关配置文件：</p><pre><code>vncserver
</code></pre><p>此时会提示要求输入一个密码及 verify 验证密码：</p><pre><code>You will require a password to access your desktops.

Password: 
Verify:  </code></pre><p>然后会提示是否需要设置一个 view-only 密码，通过这个密码登录后，不可以使用鼠标或键盘操作服务器。不需要的话输入 n 不创建即可。</p><p>然后就会创建相关的默认配置文件和显示相关连接信息，同时会启动一个运行在 5901 端口的 vnc 服务实例：</p><pre><code>Would you like to enter a view-only password (y/n)? n
xauth:  file /home/sammy/.Xauthority does not exist

New 'X' desktop is marco-virtual-machine:1

Creating default startup script /home/marco/.vnc/xstartup
Starting applications specified in /home/marco/.vnc/xstartup
Log file is /home/marco/.vnc/marco-virtual-machine:1.log</code></pre><p>后期如果需要修改 vnc 密码可以输入 vncpasswd 设置：</p><pre><code>vncpasswd
</code></pre><p>此时我们的 vnc server 就安装完成并且启动了，下面我们配置启动 xfce。</p><h3>配置</h3><p>vnc server 在启动时需要知道需要执行哪些命令，以及需要连接到哪个 graphical desktop environment 图形环境。</p><p>vnc server 启动时所执行的命令是在 <strong>xstartup</strong> 文件中定义的。他在当前登录用户的 <code>home</code> 目录的 <code>.vnc</code> 文件夹内。这个文件在我们第一次启动 vncserver 时会自动创建。下面我们对它进行修改。</p><p>由于我们上面已经启动了 vncserver，它启动了一个运行在 5901 端口的 vnc 实例。我们首先关闭这个服务：</p><pre><code>vncserver -kill :1
</code></pre><p>输出信息如下：</p><pre><code>Killing Xtightvnc process ID 17648
</code></pre><p>下面我们打开 <code>~/.vnc/xstartup</code> 文件，修改为以下内容：</p><pre><code>#!/bin/sh

unset SESSION_MANAGER
unset DBUS_SESSION_BUS_ADDRESS
startxfce4 &amp;

xrdb $HOME/.Xresources
xsetroot -solid grey
#x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;
#x-window-manager &amp;
# Fix to make GNOME work
export XKL_XMODMAP_DISABLE=1
/etc/X11/Xsession</code></pre><p><strong>注意前三句是需要添加的</strong>，下面的是文件默认内容。否则远程连接会显示为灰屏。</p><p>然后给配置文件添加执行权限：</p><pre><code>chmod +x ~/.vnc/xstartup
</code></pre><p>然后我们重新启动 vncserver：</p><pre><code>vncserver -localhost
</code></pre><p>注意这里我们添加了 <code>-localhost</code> 参数，意味着此 vnc 服务只可以在本机内被连接。如果不添加这个参数，则开放所有网络连接。</p><p>我们这里只打开本地网络连接服务，然后通过 ssh tunnel 在远程和本地建立安全的连接并转发 vnc 本地端口。</p><h3>连接</h3><p>vnc 本身并不支持通过一些安全的协议进行连接，下面我们通过 ssh tunnel 隧道在本地和远程主机间建立一个安全的链接，然后告诉 vnc 客户端使用这个安全隧道连接远程服务器。</p><p>上面我们已经启动了一个 vncserver 在 5901 端口，它可以在本地网络内被连接但无法被外部网络连接。</p><p>首先我们通过 ssh 在本地和远程建立一个安全链接，并转发远程主机的 localhost 及端口到本地的特定端口：</p><pre><code>ssh -L 59000:localhost:5901 -C -N -l user xxx.xxx.xxx.xxx
</code></pre><p>以上命令意义如下：</p><ul><li><code>-L 59000:localhost:5901</code>：使用 <code>-L</code> 参数来转发一个本地端口到远程主机的 host 地址和端口，这里我们将本地 59000 端口转发到远程主机的本地 localhost 的 5901 端口，也就是启动的 vnc server 地址。</li><li><code>-C</code> 参数用来启用传输数据压缩，可以提高传输效率</li><li><code>-N</code> 参数用来告诉 ssh 我们不需要执行任何远程命令，当我们仅仅需要建立一个端口转发隧道时，此参数很有用</li><li><code>-l</code> 定义远程主机的用户名和 IP 地址</li></ul><p>ssh tunnel 建立好后，我们就可以打开 vnc 客户端进行连接了。这里我使用 ultraVNC 访问 <code>localhost:59000</code>：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1735491420.png" alt="2021-03-31T03:03:51.png" title="2021-03-31T03:03:51.png"></p><p>输入我们之前创建的 vnc 密码后就连接到远程服务器了：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3227212438.png" alt="2021-03-31T03:04:33.png" title="2021-03-31T03:04:33.png"></p><p>当然也可以不使用 ssh tunnel ，但是需要取消 <code>-localhost</code> 参数，就可以直接连接 vnc server。</p><h3>配置 vnc systemd 服务</h3><p>为了方便的启动和停止 vncserver 我们可以将其定义为一个 systemd 服务。</p><p>在 <code>/usr/lib/systemd/system</code> 目录下新建文件 <code>vncserver@.service</code>，其中的 <code>@</code> 可以让我们在操作此服务时添加传递参数，在配置文件中使用 <code>%1</code> 可以读取这个参数。</p><p>内容如下：</p><pre><code>[Unit]
Description=Start TightVNC server at startup
After=syslog.target network.target

[Service]
Type=forking
User=user
Group=user
WorkingDirectory=/home/user

PIDFile=/home/user/.vnc/%H:%i.pid
ExecStartPre=-/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1
ExecStart=/usr/bin/vncserver -depth 24 -geometry 1280x800 -localhost :%i
ExecStop=/usr/bin/vncserver -kill :%i

[Install]
WantedBy=multi-user.target</code></pre><ul><li>注意上面的配置中，需要将 user 修改为你实际登录的用户名称，共有 4 个地方</li><li><strong>ExecStart</strong> 中我们定义了 24 位色深 1280x800 的 vnc 显示，可以根据需要自行修改</li><li>使用了 <code>-localhost</code> 参数，所以只能使用 ssh tunnel 的方式访问</li></ul><p>然后重新加载配置：</p><pre><code>sudo systemctl daemon-reload
</code></pre><p>启动一个 vncserver 使用参数 1 来定义 vnc 服务号：</p><pre><code>sudo systemctl start vncserver@1
</code></pre><p>此时我们就启动了一个 vncserver 且其服务号为 <code>:1</code>。</p><p>关闭启动的 <code>:1</code> vncserver：</p><pre><code>systemctl stop vncserver@1
</code></pre><p>开机自动启动 vncserver 服务：</p><pre><code>systemctl enable vncserver@1
</code></pre><p>这样就可以实现开机自动部署 vncserver 服务了。</p><h3>参考链接</h3><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-20-04">How to Install and Configure VNC on Ubuntu 20.04</a><br><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=216725">VNC grey screen, x cursor, nothing helps</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2281.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2281.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 配置 LuCI ssl 证书]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2278.html" />
<id>https://blog.niekun.net/archives/2278.html</id>
<updated>2021-03-30T22:00:32+08:00</updated>
<published>2021-03-30T22:00:32+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[openwrt 提供了一个 luci 管理界面可以通过图形化的方式进行配置管理。我们通过 lan 网地址 http 访问 luci 界面，会有一个提示不安全的链接，一般浏览器提供了一个跳过选项可...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2278.html" xml:lang="zh-CN"><![CDATA[
<p>openwrt 提供了一个 luci 管理界面可以通过图形化的方式进行配置管理。我们通过 lan 网地址 http 访问 luci 界面，会有一个提示不安全的链接，一般浏览器提供了一个跳过选项可以忽略警告。</p><p>但是当我们通过 wan 口地址访问 luci 界面时，新版的 chrome 会强制拒绝访问 http 不安全的链接，这样我们就无法通过外网访问 luci 界面了。</p><p>注意如果想要从 wan 口访问 luci 界面，需要配置防火墙放行，具体参考：<a href="https://blog.niekun.net/archives/1818.html">https://blog.niekun.net/archives/1818.html</a></p><p>解决方法是我们给 luci 配置一个 ssl 证书，这样浏览器就会放行了。</p><!--more--><p>首先安装相关程序：</p><pre><code>opkg update &amp;&amp; opkg install openssl-util luci-app-uhttpd
</code></pre><p>以上我们安装了 openssl 套件和 uhttpd 的 ui 配置接口，可以图形化的方式配置 uhttpd。</p><p>下面我们来生成需要的 ssl 证书文件。</p><p>首先创建文件 <code>etc/ssl/myconfig.conf</code>：</p><pre><code>[req]
distinguished_name  = req_distinguished_name
x509_extensions     = v3_req
prompt              = no
string_mask         = utf8only
 
[req_distinguished_name]
C                   = US
ST                  = VA
L                   = SomeCity
O                   = OpenWrt
OU                  = Home Router
CN                  = luci.openwrt
 
[v3_req]
keyUsage            = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage    = serverAuth
subjectAltName      = @alt_names
 
[alt_names]
DNS.1               = luci.openwrt
IP.1                = 192.168.1.1</code></pre><p>可以修改 C (country), ST (state), L (location), O (organization), OU (organization unit) 为你想要的内容。</p><p>CN 和 DNS.1 必须是一样的地址，它们表示此证书代表的域名，和 IP 是对应的。如果配置了 luci 界面地址的 hosts，这里就可以定义为对应的域名。之后我们就可以通过访问这个域名来访问 IP。</p><p>IP.1 就是 luci web 地址，设置为对应的地址即可。</p><p>配置文件保存后返回 ssl 目录：</p><pre><code>cd /etc/ssl
</code></pre><p>执行下面的命令：</p><pre><code>openssl req -x509 -nodes -days 730 -newkey rsa:2048 -keyout mycert.key -out mycert.crt -config myconfig.conf
</code></pre><p>会自动在当前目录下创建 mycert.key 和 mycert.crt 文件。</p><p>然后我们先通过 lan 内网访问 luci web 界面，在顶部我们可以看到多了一个 services 菜单，点击其中的 uhttpd 进入配置界面，在 <strong>HTTPS Certificate</strong> 和 <strong>HTTPS Private Key</strong> 中分别上传 crt 和 key 文件：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4104361265.png" alt="2021-03-30T13:52:17.png" title="2021-03-30T13:52:17.png"></p><p>然后点击 save and apply。</p><p>重启 uhttpd 服务：</p><pre><code>/etc/init.d/uhttpd restart
</code></pre><p>此时我们通过 wan 口地址访问 luci web 界面，应该就可以正常进入了。</p><p>下面我们将刚才生成的 ssl 文件加入 backup 列表。默认情况下 <code>/etc/config</code> 下的文件会自动进行备份。</p><p>我们进入 System → Backup/Flash Firmware，点击 configuration 栏，然后将 <code>/etc/ssl/mycert.crt</code> 和 <br> <code>/etc/ssl/mycert.key</code> 加入列表中，点击 save 即可。</p><p>之后我们生成的备份就会包含这些文件。</p><h3>参考链接</h3><p><a href="https://openwrt.org/docs/guide-user/luci/getting_rid_of_luci_https_certificate_warnings">How to get rid of LuCI HTTPS certificate warnings</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2278.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2278.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 自启动服务 init.d]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2277.html" />
<id>https://blog.niekun.net/archives/2277.html</id>
<updated>2021-03-30T21:29:36+08:00</updated>
<published>2021-03-30T21:29:36+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[openwrt 是针对于嵌入式设备的精简版 Linux 系统。所以一些常规的 Linux 服务都没有，比如 systemd 等。openwrt 是通过 init.d 来管理服务的。所有的服务都在...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2277.html" xml:lang="zh-CN"><![CDATA[
<p>openwrt 是针对于嵌入式设备的精简版 Linux 系统。所以一些常规的 Linux 服务都没有，比如 systemd 等。</p><p>openwrt 是通过 init.d 来管理服务的。所有的服务都在 <code>/etc/init.d</code> 目录下。</p><p>对某个服务进行操作也很方便，例如对 network 服务：</p><pre><code># 启动 network
/etc/init.d/network start

# 重启 network
/etc/init.d/network restart

# 停止 network
/etc/init.d/network stop</code></pre><!--more--><p>如果需要某个服务开机自启动，可以 enable：</p><pre><code>/etc/init.d/frp enable</code></pre><p>会自动在 <code>/etc/rc.d/</code> 目录下建立一个链接指向 <code>/etc/init.d</code> 下的对应服务，如：S99frp。</p><p>S99 表示此服务的启动顺序，下面会做介绍。</p><p>我们在 <code>/etc/init.d/</code> 下新建一个 test 文件。内容如下：</p><pre><code>#!/bin/sh /etc/rc.common
START=99
start() {
    /root/test.sh
}</code></pre><p>START=99 定义此服务如果定义开机自启动时，其启动顺序序号。最大为 99，数字越大启动排序越靠后。</p><p><strong>start</strong> function 内定义了通过启动时执行的指令，上面的示例中我们定义了一个脚本文件自动运行。</p><p>我们也可以通过手动调用 start function执行其中指令：</p><pre><code>/etc/init.d/test start
</code></pre><p>下面是一个更复杂的示例：</p><pre><code>#!/bin/sh /etc/rc.common
START=99
USE_PROCD=1
boot() {
    sleep 10
    rc_procd start_service
}
start_instance() {
    procd_open_instance &quot;frpc.frpc&quot;
    procd_set_param command &quot;/usr/bin/frpc&quot;
    procd_append_param command -c &quot;/etc/frp/frpc.ini&quot;
    procd_set_param respawn
    procd_set_param file &quot;/etc/frp/frpc.ini&quot;
    procd_set_param user &quot;root&quot;
    procd_close_instance
}
service_triggers() {
    procd_add_reload_trigger &quot;frpc&quot;
}
start_service() {
    config_load &quot;frpc&quot;
    config_foreach start_instance &quot;frpc&quot;
}</code></pre><p>sleep 10 表示自启动时延时 10 秒运行 start_service function。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2277.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2277.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用 instaloader 下载 Instagram 图片-视频]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2205.html" />
<id>https://blog.niekun.net/archives/2205.html</id>
<updated>2021-03-16T11:55:00+08:00</updated>
<published>2021-03-16T11:55:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[一直在使用 telegram bot 来下载 YouTube 或 twitter 视频，很方便快捷。关于配置自己的 bot 参考之前的文章：https://blog.niekun.net/arc...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2205.html" xml:lang="zh-CN"><![CDATA[
<p>一直在使用 telegram bot 来下载 YouTube 或 twitter 视频，很方便快捷。</p><p>关于配置自己的 bot 参考之前的文章：<a href="https://blog.niekun.net/archives/428.html">https://blog.niekun.net/archives/428.html</a></p><p>我的应用于 telegram bot 的 YouTube 下载器源码地址：<a href="https://github.com/nie11kun/telegram-bot-youtube-downloader">https://github.com/nie11kun/telegram-bot-youtube-downloader</a></p><p>最近想给我的 telegram bot 添加 Instagram 图片的下载功能，但是 youtube-dl 并不支持 Instagram。查询了下发现了 instaloader 这个开源软件可以完美实现我想要的功能。</p><p>instaloader 官网：<a href="https://instaloader.github.io/">https://instaloader.github.io/</a></p><p>GitHub：<a href="https://github.com/instaloader/instaloader">https://github.com/instaloader/instaloader</a></p><!--more--><h3>安装</h3><p>instaloader 需要 python 3.5 以上。推荐直接安装最新版 python。</p><p>使用 pip3 安装：</p><pre><code>pip3 install instaloader --upgrade
</code></pre><p><strong>注意必须通过 pip3 而不是 pip 安装，否则使用中会报错。</strong></p><h3>使用</h3><p>安装完成后就可以使用 <strong>instaloader</strong> 命令来下载了。注意如果 python 安装到了自定义目录，如 <code>/opt</code> 则需要手动链接 instaloader 可执行程序到 <code>/usr/local/bin</code> 目录。</p><h4>下载 post</h4><p>如果要下载一个 post 中的图片，提取链接中的 <strong>shortcode</strong> 来下载，如下是一个 Instagram post 的链接：<a href="https://www.instagram.com/p/CMcMZycLpbS/?utm_source=ig_web_copy_link">https://www.instagram.com/p/CMcMZycLpbS/?utm_source=ig_web_copy_link</a>，其中的 <code>CMcMZycLpbS</code> 就是 <strong>shortcode</strong> 代码。</p><p>需要通过 <code>-shortcode</code> 参数来下载对应的图片，且需要通过 <code>--</code> 告诉 instaloader 不要将 <code>-shortcode</code> 作为 option 对待，如：</p><pre><code>instaloader -- -CMcMZycLpbS
</code></pre><p>关于命令中的特殊字符处理参考：<a href="https://blog.niekun.net/archives/2204.html">https://blog.niekun.net/archives/2204.html</a></p><p>默认会下载到当前目录下，并新建文件夹 <code>-shortcode</code>，媒体文件及相关文本文件就在其中，注意到文件夹是以特殊字符 <code>-</code> 开头的，所以访问目录需要加上 <code>--</code>，如：</p><pre><code>cd -- -CMcMZycLpbS
</code></pre><h4>自定义下载目录</h4><p>通过 <code>--dirname-pattern</code> 参数可以指定下载目录，如：</p><pre><code>instaloader --dirname-pattern=/tmp/test -- -CMcMZycLpbS
</code></pre><p>就会将对应 post 的媒体下载到 <code>/tmp/test</code> 目录内。</p><p><strong>instaloader</strong> 的功能很强大，可以下载一个用户的所有发布内容，可以下载一个 <code>#hashtag</code> 标签的所有内容等。具体可以参考官方文档：<a href="https://instaloader.github.io/basic-usage.html#download-pictures-from-instagram">https://instaloader.github.io/basic-usage.html#download-pictures-from-instagram</a></p><p>我将 instaloader 加入了 telegram bot 中，可以很方便的下载一个 post 的媒体内容，有兴趣的可以查看：<a href="https://github.com/nie11kun/telegram-bot-youtube-downloader">https://github.com/nie11kun/telegram-bot-youtube-downloader</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2205.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2205.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[cd 到以 '-' dash 开头的目录的方法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2204.html" />
<id>https://blog.niekun.net/archives/2204.html</id>
<updated>2021-03-16T10:33:44+08:00</updated>
<published>2021-03-16T10:33:44+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[Linux 下，当文件或文件夹包含空格或其他特殊符号如 $，在引用时需要将其放在单引号 '' 或 &amp;quot;&amp;quot; 中，如：cd '$abc'cd &amp;quot;abc de f&amp;quot...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2204.html" xml:lang="zh-CN"><![CDATA[
<p>Linux 下，当文件或文件夹包含空格或其他特殊符号如 <code>$</code>，在引用时需要将其放在单引号 <code>''</code> 或 <code>&quot;&quot;</code> 中，如：</p><pre><code>cd '$abc'
cd &quot;abc de f&quot;
</code></pre><p>当文件以 <code>-</code> dash 开头时，命令会将其作为 option 处理，如：</p><pre><code>ls -lh
</code></pre><p>此时如果需要让命令将其识别为文件名称而不是 option 需要加入 <code>--</code> 作为参数：</p><pre><code>cd -- '-abc'
</code></pre><p>这样命令就会将 <code>-</code> 开头的字符作为文件名称处理了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2204.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2204.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[创建新文件 in Linux]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2086.html" />
<id>https://blog.niekun.net/archives/2086.html</id>
<updated>2021-01-28T08:17:25+08:00</updated>
<published>2021-01-28T08:17:25+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[下面介绍几种常用的命令行创建新文件的方法。touch：touch test1.txt&amp;gt;:&amp;gt; test2.txtcat:cat /dev/null &amp;gt; test3.txtecho...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2086.html" xml:lang="zh-CN"><![CDATA[
<p>下面介绍几种常用的命令行创建新文件的方法。</p><p><strong>touch</strong>：</p><pre><code>touch test1.txt
</code></pre><p><strong>&gt;</strong>:</p><pre><code>&gt; test2.txt
</code></pre><p><strong>cat</strong>:</p><pre><code>cat /dev/null &gt; test3.txt
</code></pre><p><strong>echo</strong>:</p><pre><code>echo &gt; test4.txt
</code></pre><p><strong>vim</strong>:</p><pre><code>vim test5.txt
:wq
</code></pre><p>使用中选择最简单的方式即可。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2086.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2086.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[服务器部署 WebDAV 服务]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2074.html" />
<id>https://blog.niekun.net/archives/2074.html</id>
<updated>2021-01-22T11:16:00+08:00</updated>
<published>2021-01-22T11:16:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 GET、POS...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2074.html" xml:lang="zh-CN"><![CDATA[
<p>WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 <strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</p><p>简单说 webdav 就像一个网盘，可以远程访问他的目录名对其文件进行读写操作。</p><p><strong>WebDAV 允许客户端进行下列操作：</strong></p><ul><li>处理服务器上 WebDAV 发布目录中的资源</li><li>具有正确权限的用户可以在 WebDAV目录中复制和移动文件</li><li>修改与某些资源相关联的属性。例如，用户可写入并检索文件的属性信息</li><li>锁定并解锁资源以便多个用户可同时读取一个文件。但每次只能有一个人修改文件</li><li>搜索 WebDAV 目录中的文件的内容和属性</li></ul><!--more--><p>下面介绍如何在服务器上部署 WebDAV 服务。这里通过 nginx 来代理。</p><h3>编译 nginx</h3><p>我们通过 nginx 来代理 webdav 服务，nginx 自带有 ngx_http_dav_module 模块，但是其不支持一些 webdav 的 method 如：PROPFIND, OPTIONS, LOCK, UNLOCK。可以通过第三方模块来完整支持 webdav 的特性。</p><p>下载以下两个第三方模块：<br><strong>nginx-dav-ext-module</strong>：<a href="https://github.com/arut/nginx-dav-ext-module">https://github.com/arut/nginx-dav-ext-module</a><br><strong>headers-more-nginx-module</strong>：<a href="https://github.com/openresty/headers-more-nginx-module">https://github.com/openresty/headers-more-nginx-module</a></p><p>以上两个模块需要在编译时通过 <strong>--add-module</strong> 参数来引入模块，同时需要包含 <strong>--with-http_dav_module</strong> 模块，否则编译会报错。</p><p>从源码编译 nginx 参考我之前的教程：<a href="https://blog.niekun.net/archives/30.html">https://blog.niekun.net/archives/30.html</a></p><p>我使用的完整的编译参数如下：</p><pre><code>./configure --prefix=/opt/nginx-1.19.6 \
--user=nginx --group=nginx \
--with-compat --with-file-aio --with-threads \
--with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module \
--with-mail --with-mail_ssl_module \
--with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module \
--add-module=../echo-nginx-module \
--add-module=../ngx-fancyindex \
--add-module=../headers-more-nginx-module \
--add-module=../nginx-dav-ext-module</code></pre><h3>配置文件</h3><p>nginx 编译安装完成后，需要配置 conf 文件来使 webdav 生效。我提前已经设置了一个单独的子域名来访问 webdav 服务，且使用 ssl 加密。</p><p>首先建立 webdav 文件夹并设置正确的权限，否则在读写时会提示权限不足：</p><pre><code>mkdir /home/www/webdav
chown -R www-data:www-data /home/www/webdav</code></pre><p>如果想要限制用户访问，可以使用 <strong>ngx_http_auth_basic_module</strong> 模块来建立账号访问，具体参考：<a href="https://blog.niekun.net/archives/730.html">https://blog.niekun.net/archives/730.html</a></p><p>完整配置文件如下：</p><pre><code>dav_ext_lock_zone zone=foo:10m;
server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   webdav.xxx.xxx;
    include       my-server/ssl;

    # 限制访问
    auth_basic           &quot;Restricted Access&quot;;
    auth_basic_user_file ../users/.adminpasswd;

    # webdav 目录
    root /home/www/webdav;
    client_body_temp_path /opt/nginx/client_body_temp;

    # webdav 设置
    dav_access      user:rw  group:rw  all:r;
    dav_methods PUT DELETE MKCOL COPY MOVE;
    dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;
    dav_ext_lock zone=foo;
    create_full_put_path on;

    # 优化大文件上传
    send_timeout 3600;
    client_body_timeout 3600;
    keepalive_timeout 3600;
    lingering_timeout 3600;
    client_max_body_size 2G;

    location / {
        # 创建文件夹操作时结尾添加斜杠
        if ($request_method = MKCOL) {
            rewrite ^(.*[^/])$ $1/ break;
        }

        # 移动文件夹操作时结尾添加斜杠
        if (-d $request_filename) {
            rewrite ^(.*[^/])$ $1/;
            set $md /;
        }

        set $x $http_destination$request_method;
        if ($x ~ [^/]MOVE) {
            more_set_input_headers -r &quot;Destination: ${http_destination}${md}&quot;;
        }
    }

    # 拒绝 Windows 或 macos 多余文件上传到 webdav 路径
    location ~ \.(_.*|DS_Store|Spotlight-V100|TemporaryItems|Trashes|hidden|localized)$ {
        access_log  off;
        error_log   off;

        if ($request_method = PUT) {
            return 403;
        }
        return 404;
    }

    location ~ \.metadata_never_index$ {
        return 200 &quot;Don't index this drive, Finder!&quot;;
    }
}</code></pre><p>注意第一句 <strong>dav_ext_lock_zone</strong> 要放在 http 块内。否则会报错。</p><p>配置文件修改好后，使用下面指令测试配置是否正确：</p><pre><code>nginx -t
</code></pre><p>如果返回 ok 重启服务即可：</p><pre><code>systemctl restart nginx
</code></pre><h3>客户端连接</h3><p>nginx 配置好 webdav 模块并启动后，可以尝试在客户端访问。</p><p>Windows 的 file explorer 和 macos 的 finder 都可以直接连接 webdav。</p><h3>Windows 端</h3><p>在 file explorer 中点击 home - easy access - map as drive：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/797689005.jpg" alt="1.jpg" title="1.jpg"></p><p>在弹出窗口中点击 connect to a web site：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1204074620.jpg" alt="2.jpg" title="2.jpg"></p><p>点击 next 在地址栏输入服务器 nginx 定义的 webdav 访问地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/3507948553.jpg" alt="3.jpg" title="3.jpg"></p><p>点击 next 后如果设置了 <strong>auth_basic</strong> 会提示要求输入账户和密码，输入账户密码后就进入了 webdav 目录了，下面就可以测试新建文件，修改文件等操作。</p><p><strong>注意 Windows 中默认只有 https 方式访问的地址才可以设置 auth，否则不会弹出输入账户和密码的提示框，而是直接提示无法访问此地址。</strong>如果想要开放 http 方式的 auth 验证，需要修改注册表 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel</code> 的值为 2，然后重启系统即可，此键值定义为：</p><ul><li>0 - Basic authentication disabled</li><li>1 - Basic authentication enabled for SSL shares only</li><li>2 or greater - Basic authentication enabled for SSL shares and for non-SSL shares</li></ul><h3>macos 端</h3><h3>参考链接：</h3><p><a href="https://www.robpeck.com/2020/06/making-webdav-actually-work-on-nginx/">Making Native WebDAV Actually Work on nginx with Finder and Explorer</a><br><a href="https://www.codetd.com/en/article/9724623">Nginx repair of WebDAV functionality</a><br><a href="http://nginx.org/en/docs/http/ngx_http_dav_module.html">Module ngx_http_dav_module</a><br><a href="https://www.webdavsystem.com/server/prev/v2/documentation/authentication/basic_auth_vista/">Using Basic Authentication with Windows 7 and Windows Vista WebDAV Client</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2074.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2074.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[修复 ubuntu vmware 虚拟机无法访问主机共享目录]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2071.html" />
<id>https://blog.niekun.net/archives/2071.html</id>
<updated>2021-01-15T16:32:00+08:00</updated>
<published>2021-01-15T16:32:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 /mnt/hgfs 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2071.html" xml:lang="zh-CN"><![CDATA[
<p>今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 <code>/mnt/hgfs</code> 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载即可。</p><p>首先查看当前设置的共享目录有哪些：</p><pre><code>$ vmware-hgfsclient 
Development
Downloads
InstallationPackage</code></pre><p>挂载主机共享路径到虚拟机对应路径下，设置所有用户可访问：</p><pre><code>$ sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other
</code></pre><p>执行以上命令后，发现共享文件夹出现了：</p><pre><code>$ ls /mnt/hgfs/
Development  Downloads  InstallationPackage</code></pre><p>以上就是解决 VMware Linux 虚拟机没有自动挂载共享目录的方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2071.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2071.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[CentOS 6 可用源]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2035.html" />
<id>https://blog.niekun.net/archives/2035.html</id>
<updated>2020-12-29T13:58:00+08:00</updated>
<published>2020-12-29T13:58:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近在调试软件的时候需要用到 CentOS 6 系统，yum 命令无法更新包返回都是 404，查了下发现大多数主流的源地址都取消对 CentOS 6 的支持，找了半天才找到一个可用的地址，记录下...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2035.html" xml:lang="zh-CN"><![CDATA[
<p>最近在调试软件的时候需要用到 CentOS 6 系统，yum 命令无法更新包返回都是 404，查了下发现大多数主流的源地址都取消对 CentOS 6 的支持，找了半天才找到一个可用的地址，记录下来备用。</p><p>CentOS 6 的包列表在：<code>/etc/yum.repos.d/CentOS-Base.repo</code> 文件中定义。</p><p>参考链接：<a href="https://blog.csdn.net/h952520296/article/details/110541018">https://blog.csdn.net/h952520296/article/details/110541018</a></p><pre><code># CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the 
# remarked out baseurl= line instead.
#
#
 
[base]
name=CentOS-6.10 - Base - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos-vault/6.10/os/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6
 
#released updates 
[updates]
name=CentOS-6.10 - Updates - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos-vault/6.10/updates/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6
 
#additional packages that may be useful
[extras]
name=CentOS-6.10 - Extras - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos-vault/6.10/extras/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6
 
#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-6.10 - Plus - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos-vault/6.10/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6
 
#contrib - packages by Centos Users
[contrib]
name=CentOS-6.10 - Contrib - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos-vault/6.10/contrib/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6</code></pre><p>将以上内容替换到 <code>CentOS-Base.repo</code> 文件内，然后执行：</p><pre><code>yum clean all &amp;&amp; yum makecache
</code></pre><p>更新缓存即可。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2035.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2035.html" thr:count="0"/>
</entry>
</feed>