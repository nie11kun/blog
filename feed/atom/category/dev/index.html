<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/dev/"
>
<title type="text">Marco Nie - Program</title>
<subtitle type="text"></subtitle>
<updated>2020-11-20T11:32:44+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/dev/" />
<id>https://blog.niekun.net/feed/atom/category/dev/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/dev/" />
<entry>
<title type="html"><![CDATA[C++ 入门教程 -- Classes and Objects]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1918.html" />
<id>https://blog.niekun.net/archives/1918.html</id>
<updated>2020-11-20T11:32:44+08:00</updated>
<published>2020-11-20T11:32:44+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[object 对象Object Oriented Programming 面向对象编程是为了让编程更加接近于真实世界的理解方式。在程序中，每个 object 是一个独立的 unite 单元，拥有...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1918.html" xml:lang="zh-CN"><![CDATA[
<h3>object 对象</h3><p>Object Oriented Programming 面向对象编程是为了让编程更加接近于真实世界的理解方式。在程序中，每个 object 是一个独立的 unite 单元，拥有自己的 identify 标识，就像真实世界的某个独立物体一样。</p><p>例如一个苹果就是一个 object，它的 identify 就是名称 <code>苹果</code>，每个苹果都有自己独立的 attributes 属性，如颜色，大小。一个属性就是这个 object 当前状态的描述。不同 object 的 attributes 属性是不一样的，例如一个苹果是绿色的，另一个是红色的。</p><p>在正式世界中 object 都有其 behave 行为，例如汽车的 move 移动，手机的 ring 响铃。这种 object 的行为叫做 object 的 type 类型。</p><p><strong>描述一个 object需要的元素：identify 标识，attributes 属性，behavior 行为</strong></p><!--more--><p>在程序中每个 object 是独立的，拥有独立的 identify 用来区分其他的 object：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/786595094.png" alt="1.png" title="1.png"></p><h3>class</h3><p>我们通过创建 class 来表示 object，一个 class 描述了一个 object 的形象，但是它并不是一个真正的 object，他只是一个对某种 object 结构的定义。一个 class 可以用来建立多个 object。例如一套设计图纸可以用来作为蓝图修建多栋楼房。</p><p>一个 class 包含：identify，attributes，behavior</p><p>程序中，一个对象的 type 就是 class 的 name 名称；Attributes 属性可以是 properties 或 data 数据；behavior 行为通常是一个 function。</p><p>例如我们建立一个银行系统程序：</p><ul><li>name: BankAccount</li><li>attributes: accountNumber, balance, dateOpened</li><li>behavior: open(), close(), deposit()</li></ul><p>一个 class 定义了某种 object 需要的属性和行为。但是它并不直接定义具体的属性值是多少，她只是一个框架的描述。</p><p>当我们写好了一个 class，可以基于这个 class 来创建 objects，这个 object 就是 instance of class，就是 class 的实例。</p><h3>建立 class</h3><p>使用关键字 <code>class</code> 来建立 class，然后定义 class 名称，class 内容写在大括号<code>{}</code> 内。注意每个 class 结尾必须写分号<code>;</code>。例如：</p><pre><code>class BankAccount {

};</code></pre><p>一个 class 的 attributes 和 behaviors 可以设置 access 访问级别。定义时使用关键词 <code>public</code> 不仅可以在 class 内部使用，也可以在 class 外部访问这个属性。也可以是使用关键词 <code>private</code> 或 <code>protected</code>，下面做详细介绍。</p><p>建立一个 class：</p><pre><code>class BankAccount {
  public:
    void sayHi() {
      cout &lt;&lt; &quot;Hi&quot; &lt;&lt; endl;
    }
};</code></pre><p>然后 instance 实例化这个 class：</p><pre><code>int main() 
{
  BankAccount test;
  test.sayHi();
}</code></pre><p>实例化的 object test 拥有其 class 所有的属性和行为。使用点分割符<code>.</code> 来访问 object 的各种属性和 function。</p><h3>抽象化</h3><p>数据抽象化的理念是给外部环境提供最核心的信息，而不用提供具体的细节。比如我们抽象化一本书，我们不用知道他具体有多少也，多少个字，什么颜色。我们只需要知道它是一本书就行了。</p><p>抽象化的理念是面向对象编程最基础的模块。可以让我们建立一个 class 模型，然后基于这个模型创建具体的 objects 对象。</p><h3>封装</h3><p>encapsulation 封装意味着将一个整体包围起来，不仅仅是将其内容放在一起，也可以将其保护起来。它的设计原则就是让外部程序只能够访问其开放的元素，其他内容保持隐藏状态。</p><p>例如我们上面的 BankAccount class，我们不想要外部直接访问修改 balance 余额属性，我们需要其使用 <code>deposit()</code> 或 <code>withdraw()</code> 方法来对其进行操作。所以我们需要将 balance 属性对外隐藏掉，只能通过内部 function 来访问。</p><p>封装的优势有：</p><ul><li>控制内部数据的访问和修改</li><li>代码更加灵活，方便后续根据情况修改</li><li>修改一个地方，不影响其他地方</li></ul><p>下面举例说明如何使用封装来控制内部数据的可访问性，使用 public，private，protected 关键词。</p><p><strong>注意如果没有使用关键词，默认 class 内所有都是 private 类型的。</strong></p><p><strong>访问 public 的数据：</strong></p><pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    string name;
};

int main() {
  myClass myObj;
  myObj.name = &quot;SoloLearn&quot;;
  cout &lt;&lt; myObj.name;
  return 0;
}

//Outputs &quot;SoloLearn&quot;</code></pre><p>使用 public 关键词定义可被外部访问的属性，注意关键词后的冒号<code>:</code>。</p><p><strong>使用 private 保护内部数据：</strong></p><pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    void setName(string x) {
      name = x;
    }
  private:
    string name;
};

int main() {
  myClass myObj;
  myObj.setName(&quot;John&quot;);

  return 0;
}</code></pre><p>name 不可以被外部直接访问修改，但是通过 <code>setName()</code> 就可以间接修改 name 的值。</p><p><strong>也可以通过 function 间接读取 private 的某些属性：</strong></p><pre><code>class myClass {
  public:
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};</code></pre><p>以上示例，通过建立 public 里的 <code>getName()</code> 方法来读取 name 的值。</p><h3>constructor 构造器</h3><p>constructor 是 class 中特殊的 function，这个 function 的名称和 class 名称一样且没有返回类型，甚至没有 void，它会在 instance 实例化 object 时自动被执行，例如：</p><pre><code>class myClass {
  public:
    myClass() {
      cout &lt;&lt;&quot;Hey&quot;;
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass myObj;

  return 0;
}

//Outputs &quot;Hey&quot;</code></pre><p>以上示例中，在实例化 myObj 时，会自动执行构造器 function。</p><p>构造器 function 可以方便的让我们在实例化 class 时设置 initial 初始化参数。默认构造器没有参数，如果需要的话我们可以加入参数。例如：</p><pre><code>class myClass {
  public:
    myClass(string nm) {
      setName(nm);
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass ob1(&quot;David&quot;);
  myClass ob2(&quot;Amy&quot;);
  cout &lt;&lt; ob1.getName();
}
//Outputs &quot;David&quot;</code></pre><p>以上示例中，构造器的作用是使用一个参数给 private name 赋值。当实例化这个 class 时，需要传入构造器需要的参数。</p><p><strong>注意我们可以在一个 class 中建立多个 constructor 构造器，来使用不同的参数。</strong></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1918.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1918.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程 -- Functions]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1915.html" />
<id>https://blog.niekun.net/archives/1915.html</id>
<updated>2020-11-20T09:38:00+08:00</updated>
<published>2020-11-20T09:38:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[一个 function 是为了完成某个任务的许多命令的一个集合。使用 function 的优势有：代码复用独立测试某功能修改一个 function 内部代码不影响程序整体结构同一个 functi...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1915.html" xml:lang="zh-CN"><![CDATA[
<p>一个 function 是为了完成某个任务的许多命令的一个集合。使用 function 的优势有：</p><ul><li>代码复用</li><li>独立测试某功能</li><li>修改一个 function 内部代码不影响程序整体结构</li><li>同一个 function 可使用不同传入参数调用</li></ul><p>一个有效的 c++ 程序至少要有一个 function：<code>main()</code>。</p><!--more--><h3>返回类型</h3><p><code>mian()</code> function 通常结构如下：</p><pre><code>int main()
{
  // some code
  return 0;
}</code></pre><p>function 的返回值类型定义在它的名称前，以上示例中，返回类型为 int 型，表明此 function 会返回一个 int 型数据。有些 function 在执行后不需返回数据，则使用 <code>void</code> 来定义。</p><p><code>void</code> 是一个基本数据类型，用来定义无值 valueless 申明。</p><h3>结构</h3><p>function 定义结构如下：</p><pre><code>return_type function_name( parameter list )
{
   body of the function
}</code></pre><ul><li>return-type: 返回值数据类型</li><li>function name: function 名称</li><li>parameters: 传递参数，当此function被调用时，传递数据给 function 内部使用。需要指定类型，名称及个数</li><li>body of the function: 指令集合</li></ul><p>parameters 参数是可选的，当不需要传递参数时可以留空。</p><h3>使用</h3><p>我们定义一个无返回值类型的 function：</p><pre><code>void printSomething() 
{
  cout &lt;&lt; &quot;Hi there!&quot;;
}</code></pre><p>此 function 功能为输出一个字符串。</p><p>我们在 <code>main()</code> 中调用此 function：</p><pre><code>int main() 
{
   printSomething();
   
   return 0;
}</code></pre><p>调用某个 function 只需要使用 function 名称及传入参数即可。</p><p>注意 function 的申明和调用顺序，需要先申明然后调用，不然会报错：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

void printSomething() {
  cout &lt;&lt; &quot;Hi there!&quot;;
}

int main() {
  printSomething();

  return 0;
}</code></pre><p>一个 function 的申明告诉编译器这个 function 的名称及调用方法，其内容可以在后续代码中定义：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

//Function declaration
void printSomething();

int main() {
  printSomething();

  return 0;
}

//Function definition
void printSomething() {
  cout &lt;&lt; &quot;Hi there!&quot;;
}</code></pre><h3>传递参数</h3><p>如果一个 function 需要传递数据，需要在申明定义正式的参数用来接收传递数据值。例如：</p><pre><code>void printSomething(int x) 
{
   cout &lt;&lt; x;
}</code></pre><p>以上定义一个 function 接收一个 int 整数然后输出这个整数。</p><p>function 内的变量在调用此 function 时创建，在结束时清除。</p><p>当一个带传递参数的 function 被定义后，在调用时需要传入对于数据类型的数据：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

void printSomething(int x) {
  cout &lt;&lt; x;
}

int main() {
  printSomething(42);
}

// Outputs 42</code></pre><p>以上示例将 42 传入 <code>printSometing()</code> 然后输出数据。</p><p>在 function 内对传入参数数据的改变不会对影响到外部的数据。</p><p>可以在调用时使用不同的传入数据：</p><pre><code>int main() {
  printSomething(42);
  printSomething(22);
  printSomething(36);
}</code></pre><p>可以定义多个传递参数，使用逗号<code>,</code> 分隔，如：</p><pre><code>int addNumbers(int x, int y) {
  int result = x + y;
  return result;
}

int main() {
  cout &lt;&lt; addNumbers(50, 25);
  // Outputs 75
}</code></pre><p>以上示例定义了两个传递参数，返回值为两个参数的和。</p><h3>rand() function</h3><p>创建一个随机整数是程序内常用的使用场景，可以调用 <code>rand()</code> function 获取随机整数。需要用到 <code>&lt;cstdlib&gt;</code> 库：</p><pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main() {
  cout &lt;&lt; rand();
}</code></pre><p>输出 10 个 1 - 6 之间的随机数：</p><pre><code>int main () {
  for (int x = 1; x &lt;= 10; x++) {
  cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}

/* Output: 
6
6
5
5
6
5
1
1
5
3
*/</code></pre><p>但是 <code>rand()</code> 其实生成的是伪随机数，因为每次执行以上程序生成的数都是一样的。使用 <code>srand()</code> 可以获得真正的随机数，它支持设置一个 seed 种子值来作为 <code>rand()</code> 的运行算法：</p><pre><code>int main () {
  srand(98);

  for (int x = 1; x &lt;= 10; x++) {
    cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}</code></pre><p>改变 <code>srand()</code> 的 seed 传入值可以改变 <code>rand()</code> 算法来生成新的随机数。所以同一个 seed 值执行后生成的随机数是一样的。</p><p>那么如何使用不同的 seed 值呢，一个方法是读取当前时间来作为 seed，这样就可以得到真正的随机数，读取系统时间需要使用 <code>&lt;ctime&gt;</code> 库：</p><pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main () {
  srand(time(0));

  for (int x = 1; x &lt;= 10; x++) {
    cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}</code></pre><p><code>time(0)</code> 返回当前时间的秒位。</p><h3>传递参数默认值</h3><p>当定义一个 function 时可以给参数项设置一个 default 默认值，这样在调用这个 function 时如果没有给参数赋值，就会使用默认值的数据，例如：</p><pre><code>int sum(int a, int b=42) {
  int result = a + b;
  return (result);
}</code></pre><p>以上示例中给变量 b 设置默认值 42，当调用这个 function 时如果没有给 b 传入数据，就会使用默认值：</p><pre><code>int main() {
  int x = 24;
  int y = 36;

  int result = sum(x, y);
  cout &lt;&lt; result &lt;&lt; endl;
  //Outputs 60

  result = sum(x);
  cout &lt;&lt;  result &lt;&lt; endl;
   //Outputs 66

  return 0;
}</code></pre><h3>overload function 重写</h3><p>function overload 功能支持使用同样的名称建立多个 function，拥有不同的传递参数。</p><p>例如创建一个 function，有一个 int 型的参数：</p><pre><code>void printNumber(int a) { 
  cout &lt;&lt; a;
}</code></pre><p>我们可以再次创建一个有同样名称的 function 有一个 float 类型的参数：</p><pre><code>void printNumber(float a) { 
  cout &lt;&lt; a;
}</code></pre><p>这两个 function 可以同时存在且互不影响，调用时根据传递参数类型或个数的不同来自动判断调用的具体是那个 function。</p><p>注意不能仅仅建立有不同的返回值类型的同名 function 例如以下 function 不能同时建立：</p><pre><code>int printName(int a) { }
float printName(int b) { }
double printName(int c) { }</code></pre><h3>递归 recursion</h3><p>递归操作在程序中很常见，可以在 function 中调用其自身。</p><p>递归在数学中很常见，如计算阶乘：</p><pre><code>4! = 4 * 3 * 2 * 1 = 24
</code></pre><p>建立一个 function 实现上面的阶乘计算：</p><pre><code>int factorial(int n) {
  if (n==1) {
    return 1;
  }
  else {
    return n * factorial(n-1);
  }
}

int main() {
  cout &lt;&lt; factorial(4);
}</code></pre><p><strong>如果我们调用此 function 传递参数为 4，则返回值计算过程为：</strong><br>返回 <code>4 * factorial(3)</code>, 然后返回 <code>4*3*factorial(2)</code>, 再次返回 <code>4*3*2*factorial(1)</code>, 然后为 <code>4*3*2*1</code>，最后 n 为 1 结束递归调用 function。</p><p>注意设计 recursion 时一定要有 base case 跳出递归的条件，要不然就会陷入死循环。</p><h3>数组类型传递参数</h3><p>数组也可以作为 function 的传递参数类型，例如：</p><pre><code>void printArray(int arr[], int size) {
  for(int x=0; x&lt;size; x++) {
    cout &lt;&lt; arr[x];
  }
}

int main() {
  int myArr[3]= {42, 33, 88};
  printArray(myArr, 3);
}</code></pre><p><code>printArray()</code> 的参数为 int 型一个数组和单变量，在 <code>main()</code> 中调用时传入一个 3 个元素的数组和数组个数数据。会输出这个数组所有元素。</p><p>当调用 function 时传入的数组只需要写数组名即可，不需要方括号<code>[]</code>。</p><h3>传入数据</h3><p>有两种方式给 function 传入数据：</p><ul><li>by value：复制传入参数的数据供 function 内部使用，内部对数据的修改操作不影响外部数据</li><li>by reference：复制传入参数的相关性到 function 内部，这时候对传入数据的操作会直接影响到外部关联的数据</li></ul><p>c++ 默认使用 by value 传入数据。如：</p><pre><code>void myFunc(int x) {
  x = 100;
}

int main() {
  int var = 20;
  myFunc(var);
  cout &lt;&lt; var;
}
// Outputs 20</code></pre><p>以上示例中，将 var 的数据传入 myFunc()，传入数据给 function 内部变量 x，内部 x 变量的值修改为 100 后不会影响到外部的 var 的数据。</p><p>by reference 方式会将传入数据的内存地址传入 function 中内部参数，这意味着 function 内对传入数据的修改会直接修改源传入数据内容。使用这种方式的 function，需要将传递数据定义为 pointer 指针类型。例如：</p><pre><code>void myFunc(int *x) {
  *x = 100;
}

int main() {
  int var = 20;
  myFunc(&amp;var);
  cout &lt;&lt; var;
}
// Outputs 100</code></pre><p>以上示例中定义一个 function 拥有指针类型的传递参数，在调用 <code>myFunc()</code> 时传入一个数据的地址，这样在 function 内对此地址数据的操作会直接改变外部对应地址的变量的数据。</p><p>通常情况下，使用 by value 方式更加快速和高效，使用 by reference 方式会修改源相关联的数据会占用更多的内存。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1915.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1915.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程 -- 数据类型，数组及指针]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1898.html" />
<id>https://blog.niekun.net/archives/1898.html</id>
<updated>2020-11-19T15:54:00+08:00</updated>
<published>2020-11-19T15:54:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression非法的运算：55 + &amp;quot;John...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1898.html" xml:lang="zh-CN"><![CDATA[
<h3>介绍数据类型</h3><p>操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：<br>合法的运算：</p><pre><code>55+15 //  legal C++ expression
</code></pre><p>非法的运算：</p><pre><code>55 + &quot;John&quot; // illegal

</code></pre><!--more--><p>数字类型的有两种类型：<br>整型，如：<code>7</code>，<code>10</code>。<br>浮点型，如：<code>3.14</code>，<code>5.67</code>。</p><p><strong>字符串</strong>是一个数字、字符、符号的集合。使用双引号来标记，如：<code>&quot;hello&quot;</code>。</p><p><strong>字符</strong>使用单引号来标记，如：<code>'A'</code>。</p><p><strong>Boolean</strong> 类型只有两个可能的值：<code>true</code> 和 <code>false</code>。</p><h3>整型</h3><p>整型一般默认 4 个字节的存储空间。</p><p>使用 int 来定义：</p><pre><code>int a = 42;
</code></pre><p>带符号型，可以定义正数和负数，一般不写默认 int 就是带符号型：</p><pre><code>signed int a;
</code></pre><p>无符号型，只能定义正数型：</p><pre><code>unsigned int a;
</code></pre><p>short 型，一般默认空间占用大小，就是 2 个字节：</p><pre><code>short int a;
</code></pre><p>long 型，2倍默认空间大小：</p><pre><code>long int a;
</code></pre><h3>浮点型</h3><p>有三种浮点类型：float, double, 和 long double。浮点型都是 signed 带符号型的。</p><p>一般情况下，float 型 4 个字节，double 型 8 个字节，long double 型 16 个字节。</p><p>使用 float 来定义：</p><pre><code>float a = 3.14;
</code></pre><h3>字符串</h3><p>string 字符串类型是一个字符、数字和符号的集合，使用双引号来标记。</p><p>使用 string 定义变量，需要使用 <code>&lt;string&gt;</code> 库：</p><pre><code>#include &lt;string&gt;
using namespace std;

int main() {
    string test = &quot;hello&quot;;
    return 0;
}</code></pre><p>注意：<code>&lt;string&gt;</code> 库包含在 <code>&lt;iostream&gt;</code> 库中，所以如果已经引用来 <code>&lt;iostream&gt;</code> 就不需要再引用 <code>&lt;string&gt;</code> 了。</p><h3>char 类型</h3><p>char 类型包含了 1 个字节的整数，但是解释器会将这个整数解释为 ASCII 码对应字符。使用单引号来标记，如：</p><pre><code>char a = 'a';
</code></pre><h3>变量定义规则</h3><p>所有变量的定义需要遵守以下规则：</p><ul><li>变量名首位必须是一个字母或下划线 <code>_</code></li><li>首字符之后的可以使用字母或数字，不能使用特殊字符或空格</li></ul><p>一般有两种常用的定义方法</p><ul><li>首字母及每个单词的首字符大写，如: BlankWord</li><li>首字母小写后续的每个单词首字符大写，如：blankWord</li></ul><p>所有的变量名都是区分大小写的，如：helloword 和 HelloWord 是两个变量。</p><h3>数组</h3><p>数组是一个同一种数据类型变量的集合体，只需要一次就可以定义多个同一种变量类型的变量。如：</p><pre><code>int a[5] = {1, 2, 5, 7, 8};
</code></pre><p>变量名后方括号<code>[]</code>定义数组内变量个数，大括号<code>{}</code>内包含数组内元素实际值，使用逗号<code>,</code>分隔各个元素。注意大括号内的元素个数不能超过数组变量定义的个数。</p><p>也可以在定义时不说明元素个数：</p><pre><code>int a[] = {1, 3, 7, 9};
</code></pre><p>会自动创建足够存储内部元素的数组。</p><p>数组内每个元素都有一个 index 索引，从 0 开始，所以数组内第一个元素索引为 0，第二个为 1。使用索引号可以访问对应元素：</p><pre><code>int b[] = {11, 45, 62, 70, 88};

cout &lt;&lt; b[0] &lt;&lt; endl;
// Outputs 11

cout&lt;&lt; b[3] &lt;&lt; endl;
// Outputs 70</code></pre><p>如果需要逐个访问数组内元素，可以使用 loop 循环来实现：</p><pre><code>int myArr[5];

for(int x=0; x&lt;5; x++) {
  myArr[x] = 42;
}</code></pre><h3>多维数组</h3><p>以上是单维数组的定义，也可以定义多维数组，如定义一个二位数组：</p><pre><code>int a[3][4];
</code></pre><p>想象这个数组为一个矩阵，有三行，每行 4 个元素：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/2097067069.png" alt="DownloadFile.png" title="DownloadFile.png"></p><p>定义多维数组定义元素需要每行在一个大括号下单独定义：</p><pre><code>int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};</code></pre><p>也可以在一行内定义：</p><pre><code>int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
</code></pre><p>使用行号和列号来定位一个元素：</p><pre><code>int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
cout &lt;&lt; x[0][2] &lt;&lt; endl;

//Outputs 4</code></pre><h3>指针</h3><p>每个变量都存储在内存单元内，每个内存空间都有地址。这个内存地址可以使用地址查询符<code>&amp;</code>来查询，如：</p><pre><code>int score = 5;
cout &lt;&lt; &amp;score &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;</code></pre><p>返回的地址就是存储变量 score 的值的地址空间。</p><p>一个 pointer 指针就是一个存储某个变量所在内存地址的变量。指针类型可以使某些任务实现更加方便，某些任务，如动态内存分配则必须使用指针来实现。</p><p>不同类型的指针变量的唯一区别就是其所在内存地址的数据类型的不同。</p><p>和其他变量类型一样，定义指针变量需要申明类型。使用星号<code>*</code> 来表示是指针类型的变量。</p><pre><code>int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character</code></pre><p>星号<code>*</code> 可以放在数据类型旁边或者变量旁边或者单独写在中间。</p><p>我们可以将一个地址赋给指针变量：</p><pre><code>int score = 5;
int *scorePtr;
scorePtr = &amp;score;

cout &lt;&lt; scorePtr &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;</code></pre><p>scorePtr 的值就是 score 变量的内存地址。</p><p>有两种指针的运算器：</p><ul><li>地址查询符<code>&amp;</code>，返回操作数所在内存地址 referencing</li><li>数据查询符<code>*</code>，返回操作数的内存地址下的数据 dereferencing</li></ul><p>例如：</p><pre><code>int var = 50;
int  *p;
p = &amp;var;

cout &lt;&lt; var &lt;&lt; endl;
// Outputs 50 (the value of var)

cout &lt;&lt; p &lt;&lt; endl;
// Outputs 0x29fee8 (var's memory location)

cout &lt;&lt; *p &lt;&lt; endl;
/* Outputs 50 (the value of the variable
 stored in the pointer p) */</code></pre><p>定义指针类型变量时候的星号<code>*</code> 只是用来表明此变量为指针类型变量，不要和内存查询符混淆。</p><p>数据查询符<code>*</code> 指针指向的变量的 alias，例如：</p><pre><code>int x = 5;
int *p = &amp;x;

x = x + 4;
x = *p + 4;
*p = *p + 4;</code></pre><p>P 是 x 的指针，以上示例的三种运算结果都是一样的，都是将变量 x 的值进行计算。我们可以通过定义变量的指针来操作变量值。</p><h3>静态内存和动态内存</h3><p>理解动态内存的工作机制对于开发有很大帮助。再 c++ 中内存被分为两种类型：</p><ul><li>the stack 静态内存空间：所有的本地变量占用静态内存空间</li><li>the heap 动态内存空间：再程序运行时动态进行分配的空间，默认不占用</li></ul><p>很多情况下，提前并不知道一个定义的变量需要多少空间来存储信息需要在运行时动态请求内存空间。可以使用 <code>new</code> 操作符来定义一个变量使用 heap 方式再运行时动态分配内存空间，并返回分配的地址，例如：</p><pre><code>new int;
</code></pre><p>以上定义一个使用 heap 方式分配一个足够存储 int 类型的内存空间，并返回这个地址。分配的地址可以存储在一个指针中，可以在后续中使用：</p><pre><code>int *p = new int;
*p = 5;</code></pre><p>以上请求了一个动态内存来存储一个 int 类型数据，然后在这个地址存储值为 5。注意指针 p 变量存储在 stack 静态内存中，且其值为 heap 动态内存分配的 int 型数据的地址，结果 5 是存储在 heap 动态内存中的。</p><p>本地静态内存 stack 下的变量，内存管理是自动进行的不需要手动干预，使用 heap 方式动态分配的内存空间需要手动干预操作，当不再需要动态内存空间的数据时使用 <code>delete</code> 操作符来释放空间。</p><p>示例：</p><pre><code>int *p = new int; // request memory
*p = 5; // store value

cout &lt;&lt; *p &lt;&lt; endl; // use value

delete p; // free up the memory</code></pre><p>忘记释放使用 <code>new</code> 请求的动态内存空间会导致内存泄漏问题，因为在程序关闭时才会释放空间。</p><p>注意 delete 操作的是指针类型。并且释放的只是 heap 动态内存，指针本身是存储在 stack 中的。当内存释放后，指针不指向某个内存地址，次时这个指针叫做：dangling pointers 悬浮指针。可以重新让这个指针指向内存地址：</p><pre><code>int *p = new int; // request memory
*p = 5; // store value

delete p; // free up the memory
// now p is a dangling pointer

p = new int; // reuse for a new address</code></pre><p>也可以定义一个 NULL 的空指针：</p><pre><code>int *ptr = NULL;
</code></pre><p>也可以指向一个数组：</p><pre><code>int *p = NULL; // Pointer initialized with null
p = new int[20]; // Request memory
delete [] p; // Delete array pointed to by p</code></pre><p>注意释放内存时要加上方括号<code>[]</code>。</p><p>动态内存分配很有用，如当程序需要读取一张图片时，你提前并不知道图片的大小，需要多大的内存空间来存储。这时候使用动态内存来定义就很方便了。</p><h3>数据大小</h3><p>虽然不同类型数据的内存占用大小和不同架构的设备有关或使用的编译器，但 c++ 有一个最小的数据大小定义：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/1716248068.png" alt="123.png" title="123.png"></p><p>可以使用 <code>sizeof</code> 指令来获取特定数据类型当前占用内存空间，如：</p><pre><code>sizeof(int)
</code></pre><p>返回值为此类型数据的内存大小，单位为字节：</p><pre><code>cout &lt;&lt; &quot;char: &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; &quot;int: &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; &quot;float: &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
int var = 50;
cout &lt;&lt; &quot;var: &quot; &lt;&lt; sizeof(var) &lt;&lt; endl;

/* Outputs
char: 1
int: 4
float: 4
double: 8
var: 4
*/ </code></pre><p>也可以获取数组的内存占用大小：</p><pre><code>double myArr[10];
cout &lt;&lt; sizeof(myArr) &lt;&lt; endl; 

//Outputs 80</code></pre><p>一个 double 占用 8 个字节，所以此数组共使用 80 个字节。</p><p>可以使用 sizeof 分别读取整个数组和单个元素的内存空间来计算数组元素个数：</p><pre><code>int numbers[100];
cout &lt;&lt; sizeof(numbers) / sizeof(numbers[0]);

// Outputs 100</code></pre><p>以上就是 c++ 数据类型及指针的介绍。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1898.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1898.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程 -- 判断及循环]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1895.html" />
<id>https://blog.niekun.net/archives/1895.html</id>
<updated>2020-11-07T15:53:00+08:00</updated>
<published>2020-11-07T15:53:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[if 判断if 申明的使用场景：当一个判断条件达到是执行指令。语法结构：if (condition) {    statements}]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1895.html" xml:lang="zh-CN"><![CDATA[
<h3>if 判断</h3><p><code>if</code> 申明的使用场景：当一个判断条件达到是执行指令。</p><p>语法结构：</p><pre><code>if (condition) {
    statements
}</code></pre><!--more--><p>示例：</p><pre><code>if (7 &gt; 4) {
  cout &lt;&lt;  &quot;Yes&quot;; 
}

// Outputs &quot;Yes&quot;</code></pre><p>可以使用的相关性判断器：</p><ul><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li><li><code>==</code></li><li><code>!=</code></li></ul><p>当条件不满足是，也可以执行命令：</p><pre><code>if (condition) {
  //statements
}
else {
 //statements
}</code></pre><p>if else 指令可以多次嵌套使用：</p><pre><code>int age = 18;
if (age &gt; 14) {
  if(age &gt;= 18) {
    cout &lt;&lt; &quot;Adult&quot;;
  }
  else {
    cout &lt;&lt; &quot;Teenager&quot;;
  }
}
else {
  if (age &gt; 0) {
    cout &lt;&lt; &quot;Child&quot;;
  }
  else {
    cout &lt;&lt; &quot;Something's wrong&quot;;
  }
}</code></pre><p>当命令只有一句时可以省略大括号：</p><pre><code>int a = 10;
if (a &gt; 4)
  cout &lt;&lt; &quot;Yes&quot;;
else
  cout &lt;&lt; &quot;No&quot;;</code></pre><h3>while 循环</h3><p>一个 while 循环重复的执行设置的命令，直到设置的条件不满足为止。</p><p>语法：</p><pre><code>while (condition) {
   statement(s);
}</code></pre><p>示例：</p><pre><code>int num = 1;
while (num &lt; 6) {
  cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl;
  num = num + 1;
}</code></pre><p>当 num 变量小于 6 满足时，循环执行大括号内的指令，直到 num 的值大于等于 6 则跳出循环继续执行下面的指令。以上示例中当 num 第五次自加后结果为 6，则下一次循环开始时判断条件就为 false 了，就会跳出循环。</p><h3>for 循环</h3><p>for 循环指令可以实现指定循环次数，语法结构如下：</p><pre><code>for ( init; condition; increment ) {
  statement(s);
}</code></pre><ul><li>init 用来设置变量初值，且只设置一次</li><li>condition 用来给定执行循环的条件，满足则执行循环内指令</li><li>increment 设置循环条件的变量值如何变化</li></ul><p>示例：</p><pre><code>for (int x = 1; x &lt; 10; x++) {
 // some code
 }</code></pre><p>定义并设置 x 变量初值 1，循环条件是 x 小于 10，每次循环后 x 自加 1。</p><p>变量变化量可以自定：</p><pre><code>for (int a = 0; a &lt; 50; a+=10) {
  cout &lt;&lt; a &lt;&lt; endl;
}
/* Outputs
0
10
20
30
40
*/</code></pre><h3>do while 循环</h3><p>不同于 while 循环，do while 循环首先执行一次循环内的指令，再判断条件是否满足。</p><p>语法：</p><pre><code>do {
   statement(s);
} while (condition);</code></pre><p>示例：</p><pre><code>int a = 0;
do {
  cout &lt;&lt; a &lt;&lt; endl;
  a++;
} while(a &lt; 5);

/* Outputs
0
1
2
3
4
*/</code></pre><p>do while 即使条件不满足也至少会执行一次循环内的命令。</p><h3>switch 指令</h3><p>当需要根据一个变量值为不同的结果时执行不同的指令时可以使用 switch 指令。</p><p>语法：</p><pre><code>switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
    default:
    statement(s);
}</code></pre><p>当变量的值匹配到 <strong>switch</strong> 里定义的一个 value 值后，会执行此 case 下的指令。<br>使用 <strong>break</strong> 来跳出 switch 指令，如果不写的话会顺序执行下面的case 指令，即使变量值并没有匹配到这个 case。<br><strong>default</strong> 用来定义当以上设置的 case 都没有匹配上时执行的指令。</p><h3>逻辑操作符</h3><p>有三个逻辑操作符：</p><ul><li>&& 与</li><li>|| 或</li><li>!  非</li></ul><p>与指令：当两个条件都满足时为 true：</p><pre><code>int age = 20;
if (age &gt; 16 &amp;&amp; age &lt; 60) {
  cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted&quot;</code></pre><p>或指令：当任意一个条件满足时为 true：</p><pre><code>int age = 16;
int score = 90;
if (age &gt; 20 || score &gt; 50) {
    cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted!&quot;</code></pre><p>非指令：当条件不满足时为 true：</p><pre><code>int age = 10;
if ( !(age &gt; 16) ) {
  cout &lt;&lt; &quot;Your age is less than 16&quot; &lt;&lt; endl;
}

// Outputs &quot;Your age is less than 16&quot;</code></pre><p>以上就是常用的判断及循环指令用法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1895.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1895.html" thr:count="1"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程 -- 基础概念]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1894.html" />
<id>https://blog.niekun.net/archives/1894.html</id>
<updated>2020-11-07T15:13:00+08:00</updated>
<published>2020-11-07T15:13:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。下面用几篇文章介绍 c++ 的...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1894.html" xml:lang="zh-CN"><![CDATA[
<p>C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。</p><p>下面用几篇文章介绍 c++ 的基础用法。</p><!--more--><h3>结构</h3><p>c++ 程序是一个集成很多命令和描述的集合，以下是一个模板程序：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

// comment
int main()
{
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; &quot;WOW&quot; &lt;&lt; &quot;\n&quot;;
    return 0;
}
/*
comments
*/</code></pre><p>所有 c++ 程序的入口都是 <code>main()</code> function，使用大括号 <code>{}</code> 将 function 的内容包围起来，括号内的指令在 fuction 运行时执行。每句指令结尾使用分号<code>;</code> 结束。</p><p><code>cout</code> 是 <code>iostream</code> 的一个 object，功能是输出信息到标准的输出设备，一般是显示屏上。<code>&lt;&lt;</code> 是 insertion operator 用来将后面的字符串传入 cout 指令最后输出到显示屏。可以使用多个 <code>&lt;&lt;</code> 将信息连起来。</p><p><code>iostream</code> 是头文件，里面包含各种程序执行需要的功能模块，使用 <code>#include</code> 调用头文件。iostream 包含输入输出数据块的 stream object。</p><p>每个 <code>namespace</code> 是一个申明区域，定义了程序调用 function 或 object 时的类型，<code>using namespace std</code> 告诉程序默认使用 <code>std</code> 类型的元素。在命令中可以直接写 std 中定义的元素：</p><pre><code>cout &lt;&lt; &quot;Hello world!&quot;;
std::cout &lt;&lt; &quot;Hello world!&quot;;</code></pre><p>以上两种写法效果是一样的，表示使用  std 类型的 cout 指令。</p><p>也可以写自定义的申明如：</p><pre><code>namespace fs = boost::filesystem;
fs:path testpath;
</code></pre><p>以上申明意思是用 <code>fs</code> 表示 <code>boost::filesystem</code> 类型，然后定义一个 <code>boost::filesystem::path</code> 类型的变量。</p><p>cout 执行后默认不添加行结束符号，添加一个 <code>endl</code> object 来实现换行操作。也可以添加字符串 <code>\n</code> 表示换行。</p><p>反斜杠 <code>\</code> 是转义符用来输入特殊意义的符号，如：<code>\n</code> 表示换行。</p><p><code>//</code> 双斜杠用来添加单行注释信息，斜杠所在的行不会被编译。<br><code>/*....*/</code> 用来表示注释区域，这一段的内容都不被编译。</p><h3>变量</h3><p>定义一个变量会请求一个内存空间来存储变量值。编译器需要在定义变量时指定变量类型，类型可以是系统内置的也可以是自定义的。定义的个体可以是变量，function，class 等：</p><pre><code>int testVar = 10;
</code></pre><p>以上定义了一个 int 整数型的变量 testVar 并赋值为 10，注意变量名是区分大小写的，也就是 testVar 和 testvar 代表两个不同的变量。</p><pre><code>double testDouble1, testDouble2;
</code></pre><p>也可以同时定义两个变量。</p><p><strong>根据需求设置变量类型，可以优化内存占用空间。</strong></p><p>示例：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int a = 30;
    int b = 12;
    int sum = a + b;
    cout &lt;&lt; sum;
    return 0;
}
//Outputs 42</code></pre><p>定义的变量可以在后续程序中赋值：</p><pre><code>int a;
int b = 1;

a = 2;
b = 3;</code></pre><h3>输入参数</h3><p>使用 <code>cin</code> 来请求用户输入数据，用 extraction operator 来将输入数据提取到别处：</p><pre><code>int a;
cin &gt;&gt; a;</code></pre><p>以上程序定义一个 int 型变量，然后提示用户输入一个数据存储到变量 a 中。</p><p>结合输入输出可以实现简单的交互操作：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

int main() 
{
  int a, b;
  int sum;
  cout &lt;&lt; &quot;Enter a number \n&quot;;
  cin &gt;&gt; a;
  cout &lt;&lt; &quot;Enter another number \n&quot;;
  cin &gt;&gt; b;
  sum = a + b;
  cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; endl;

  return 0;
}</code></pre><h3>运算符</h3><p>c++ 支持以下运算符：</p><ul><li><ul><li>加</li></ul></li><li><ul><li>减</li></ul></li><li><ul><li>乘</li></ul></li><li>/ 除</li><li>% 模(整除后的余数)</li></ul><pre><code>int a = 1 + 1;
int b = 5 * 6;
int c = 5 % 2;
int d = 5 + 2 * 2;
int e = (5 + 2) * 2;

cout &lt;&lt; c &lt;&lt; endl;

//output: 1</code></pre><p>如果对变量本身的加减乘除操作可以简写：</p><pre><code>x *= 3; // equivalent to x = x * 3
x /= 2; // equivalent to x = x / 2
x %= 4; // equivalent to x = x % 4</code></pre><p>对本身自加或自减操作，有两种方式：后缀和前缀：</p><pre><code>x++; //后缀，相当于 x = x + 1
x--;
++x;
--x;
</code></pre><p>使用后缀方式是先执行表达式再自加，前缀方式是先自加再执行表达式：</p><pre><code>int a = 1;
int b = a++;
int c = ++a;

//b = 1
//c = 3</code></pre><p>以上是基础概念及指令。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1894.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1894.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[从源码编译安装 python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1758.html" />
<id>https://blog.niekun.net/archives/1758.html</id>
<updated>2020-09-21T16:35:00+08:00</updated>
<published>2020-09-21T16:35:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1758.html" xml:lang="zh-CN"><![CDATA[
<p>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。</p><h3>下载源码包</h3><p>python 官网：<a href="https://www.python.org/">https://www.python.org/</a></p><p>当前最新版是 3.8.5，在这个页面找到地址：<a href="https://www.python.org/downloads/release/python-385/">https://www.python.org/downloads/release/python-385/</a></p><p><img src="https://blog.niekun.net/usr/uploads/2020/09/3204471917.jpg" alt="1.jpg" title="1.jpg"></p><!--more--><p>下载 tgz 压缩包到本地并解压：</p><pre><code>cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz</code></pre><h3>环境安装</h3><p>编译需要安装一些依赖：</p><pre><code>apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
</code></pre><h3>编译</h3><p>python 源码使用标准 GNU 编译系统，详细说明参考：<a href="https://blog.niekun.net/archives/883.html">https://blog.niekun.net/archives/883.html</a></p><p>将 python 安装到 <code>/opt</code> 目录，先创建文件夹：</p><pre><code>mkdir /opt/python3.8.5
</code></pre><p>然后配置 configure：</p><pre><code>cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \</code></pre><p>没有错误提示的话就开始编译和安装：</p><pre><code>make
make install
</code></pre><p>安装完成后测试执行：</p><pre><code>/opt/python3.8.5/bin/python3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>下面将可执行文件加入系统路径，创建软连接：</p><pre><code>ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
</code></pre><p>测试运行：</p><pre><code>python --version
</code></pre><h3>安装 pip</h3><p>源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。</p><p>官网：<a href="https://pip.pypa.io/en/stable/installing/">https://pip.pypa.io/en/stable/installing/</a></p><p>下载脚本到本地：</p><pre><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code></pre><p>使用刚才安装的 python 执行脚本：</p><pre><code>/opt/python3.8.5/bin/python3 get-pip.py
</code></pre><p>pip 的安装路径是 <code>/opt/python3.8.5/bin/</code>，测试命令：</p><pre><code>/opt/python3.8.5/bin/pip3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>添加软连接到系统路径：</p><pre><code>ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
</code></pre><p>测试命令：</p><pre><code>pip --version
</code></pre><h3>参考链接</h3><p><a href="https://docs.rstudio.com/resources/install-python-source/">https://docs.rstudio.com/resources/install-python-source/</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1758.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1758.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用 subprocess.check_output 执行cmd命令并返回结果到字符串]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1753.html" />
<id>https://blog.niekun.net/archives/1753.html</id>
<updated>2020-09-18T15:13:51+08:00</updated>
<published>2020-09-18T15:13:51+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[语法：subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=Fals...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1753.html" xml:lang="zh-CN"><![CDATA[
<p>语法：</p><pre><code>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)
</code></pre><p>执行cmd命令并返回结果到字符串。</p><p>用法：</p><pre><code>import subprocess

output = check_output([&quot;cat&quot;, &quot;/etc/hostname&quot;]).strip()
print(output)</code></pre><p>以上脚本会执行 <code>cat /etc/hostname</code> 命令然后将结果赋值给 <code>output</code> 变量。<br><code>strip()</code> 可以将 string 的前后空格去掉。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1753.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1753.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[argparse and struct in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1718.html" />
<id>https://blog.niekun.net/archives/1718.html</id>
<updated>2020-08-14T11:20:39+08:00</updated>
<published>2020-08-14T11:20:39+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[https://docs.python.org/3/library/argparse.htmlhttps://docs.python.org/3/library/struct.html]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1718.html" xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a><br><a href="https://docs.python.org/3/library/struct.html">https://docs.python.org/3/library/struct.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1718.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1718.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[string &lt;-&gt; byte in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1688.html" />
<id>https://blog.niekun.net/archives/1688.html</id>
<updated>2020-08-12T14:08:00+08:00</updated>
<published>2020-08-12T14:08:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[To transform a unicode string to a byte string in Python do this:&amp;gt;&amp;gt;&amp;gt; 'foo'.encode('utf_8...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1688.html" xml:lang="zh-CN"><![CDATA[
<p>To transform a unicode string to a byte string in Python do this:</p><pre><code>&gt;&gt;&gt; 'foo'.encode('utf_8')
b'foo'
</code></pre><p>To transform a byte string to a unicode string:</p><pre><code>&gt;&gt;&gt; b'foo'.decode('utf_8')
'foo'

</code></pre><ol><li>To convert a string to bytes.</li></ol><pre><code>data = &quot;&quot;               #string
data = &quot;&quot;.encode()      #bytes
data = b&quot;&quot;              #bytes</code></pre><ol><li>To convert bytes to a String.</li></ol><pre><code>data = b&quot;&quot;              #bytes
data = b&quot;&quot;.decode()     #string
data = str(b&quot;&quot;)         #string</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1688.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1688.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[winreg 操作 Windows 注册表 in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1685.html" />
<id>https://blog.niekun.net/archives/1685.html</id>
<updated>2020-08-12T13:56:00+08:00</updated>
<published>2020-08-12T13:56:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[https://docs.python.org/3/library/winreg.html#https://stackoverflow.com/questions/15128225/python...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1685.html" xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/winreg.html#">https://docs.python.org/3/library/winreg.html#</a><br><a href="https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry">https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry</a></p><pre><code>import winreg

REG_PATH = r&quot;Control Panel\Mouse&quot;

def set_reg(name, value):
    try:
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, 
                                       winreg.KEY_WRITE)
        winreg.SetValueEx(registry_key, name, 0, winreg.REG_SZ, value)
        winreg.CloseKey(registry_key)
        return True
    except WindowsError:
        return False

def get_reg(name):
    try:
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0,
                                       winreg.KEY_READ)
        value, regtype = winreg.QueryValueEx(registry_key, name)
        winreg.CloseKey(registry_key)
        return value
    except WindowsError:
        return None

#Example MouseSensitivity
#Read value 
print (get_reg('MouseSensitivity'))

#Set Value 1/20 (will just write the value to reg, the changed mouse val requires a win re-log to apply*)
set_reg('MouseSensitivity', str(10))

#*For instant apply of SystemParameters like the mouse speed on-write, you can use win32gui/SPI
#http://docs.activestate.com/activepython/3.4/pywin32/win32gui__SystemParametersInfo_meth.html</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1685.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1685.html" thr:count="0"/>
</entry>
</feed>