<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/"
>
<title type="text">Marco Nie</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2020-12-19T14:10:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/" />
<id>https://blog.niekun.net/feed/atom/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/" />
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之七 -- DOM]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2002.html" />
<id>https://blog.niekun.net/archives/2002.html</id>
<updated>2020-12-19T14:10:00+08:00</updated>
<published>2020-12-19T14:10:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[当你打开一个网页，html 页面会被加载和渲染到屏幕上。为了完成这个过程，浏览器会建立这个页面的 Document Object Model 模型。也就是一个指向页面逻辑架构的 object。一...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2002.html" xml:lang="zh-CN"><![CDATA[
<p>当你打开一个网页，html 页面会被加载和渲染到屏幕上。为了完成这个过程，浏览器会建立这个页面的 <strong>Document Object Model</strong> 模型。也就是一个指向页面逻辑架构的 object。</p><p>一个页面的 <strong>DOM</strong> 可以被表示为一些嵌套的 boxes：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/4242689357.png" alt="1.png" title="1.png"></p><p>JavaScript 能够用来操作 <strong>DOM</strong>，动态的添加、删除、修改其中的元素。</p><!--more--><h3>DOM tree</h3><p>DOM 将一个 document 表达为一个 tree structure 树形结构， html 元素称为这个 tree 上的相关联的 nodes 节点。</p><p>整个 tree 上的 nodes 之间都是互相有关联的。nodes 可以有 child node 子节点。在同一个 tree level 层级的 nodes 叫做 siblings 兄弟关系。想象下面的一个 document structure：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/4196340561.png" alt="2.png" title="2.png"></p><p><strong>以上示例中的关系结构是：</strong></p><ul><li><code>&lt;html&gt;</code> 有两个 children：<code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>;</li><li><code>&lt;head&gt;</code> 有一个 child：<code>&lt;title&gt;</code>，有一个 parent：<code>&lt;html&gt;</code>;</li><li><code>&lt;title&gt;</code> 有一个 parent：<code>&lt;head&gt;</code>， 没有 children;</li><li><code>&lt;body&gt;</code> 有两个 children：<code>&lt;h1&gt;</code> and <code>&lt;a&gt;</code>，有一个 parent：<code>&lt;html&gt;</code>;</li></ul><p>理解 HTML document 的元素间的关系很重要，这样我们就可以使用 JavaScript 来操纵这些元素了。</p><p><code>document</code> object 在 JavaScript 中被预定义，可以用来访问 DOM 中的所有元素。换句话说，<code>document</code> object 是页面中所有元素的拥有者。所以想要访问 html 页面中的元素，首先需要访问 <code>document</code> object。</p><p>看下面的示例：</p><pre><code>document.body.innerHTML = &quot;Some text&quot;;
</code></pre><p><code>body</code> 是 DOM 中的元素，通过 <code>document</code> 来访问到它，然后通过其 <code>innerHTML</code> property 修改其内容。</p><h3>Selecting Elements</h3><p>所有的元素都是 object，都有 properties 和 method。<code>document</code> 有能够让我们选择其内部元素的 method，常用的有三种方法：</p><pre><code>//finds element by id
document.getElementById(id) 

//finds elements by class name
document.getElementsByClassName(name) 

//finds elements by tag name
document.getElementsByTagName(name)</code></pre><p>下面的示例，我们使用 <code>getElementById</code> method 来选中一个元素，并修改其内容：</p><pre><code>var elem = document.getElementById(&quot;demo&quot;);
elem.innerHTML = &quot;hello world&quot;;</code></pre><p>注意以上示例中我们需要 html 有一个元素设置 <code>id=&quot;demo&quot;</code>，如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre><p><code>getElementsByClassName()</code> method 会返回一个特定 calss name 的集合。例如，我们有三个含有 <code>class=&quot;demo&quot;</code> 的元素：</p><pre><code>&lt;body&gt;
    &lt;div class=&quot;demo&quot;&gt;test1&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test2&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test3&lt;/div&gt;
&lt;/body&gt;</code></pre><p>首先选中全部 3 个元素为一个数组，然后修改第一个元素内容：</p><pre><code>&lt;script&gt;
    var arr = document.getElementsByClassName(&quot;demo&quot;);
    arr[0].innerHTML = &quot;hi&quot;;
&lt;/script&gt;</code></pre><p>类似的方式， <code>getElementsByTagName</code> method 返回一个特定 tag 的集合。下面的示例中，将选中所有 paragraph 元素然后修改他们的内容：</p><pre><code>&lt;body&gt;
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
    &lt;p&gt;3&lt;/p&gt;
&lt;/body&gt;

&lt;script&gt;
    var arr = document.getElementsByTagName(&quot;p&quot;);
    for (var i = 0; i &lt; arr.length; i++) {
        arr[i].innerHTML = &quot;hi there&quot;;
    }
&lt;/script&gt;</code></pre><p>每个 DOM 中的元素都有 properties 和 method 来提供给我们关于其在 DOM 中的相互关系的信息：</p><ul><li><code>element.childNodes</code> 返回其子元素的数组</li><li><code>element.firstChild</code> 返回其第一个子元素</li><li><code>element.lastChild</code> 返回其最后一个子元素</li><li><code>element.hasChildNodes</code> 当其有子元素时返回 true，否则返回 false</li><li><code>element.nextSibling</code> 返回下一个处于同一 tree level 节点的元素</li><li><code>element.previousSibling</code> 返回上一个处于同一 tree level 节点的元素</li><li><code>element.parentNode</code> 返回其 parent 节点的元素</li></ul><h3>Changing Attributes</h3><p>当选中了想要的元素后，就可以修改其相关属性了。</p><p>我们前面使用过通过 <code>innerHTML</code> property 修改了元素的 text 内容。同样的方法，我们可以修改它的属性值，例如修改一个 image 的 <code>src</code> 属性：</p><pre><code>&lt;/body&gt;
    &lt;img id=&quot;img1&quot; src=&quot;1.jpg&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;img1&quot;);
    el.src = &quot;2.jpg&quot;;
&lt;/script&gt;</code></pre><p>通常情况下，元素中所有的属性都可以通过 JavaScript 修改。</p><p>html 元素的 style 也可以通过 JavaScript 修改，所有的 style 属性可以通过 <code>style</code> object 来访问，例如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo2&quot; style=&quot;width: 200px;&quot;&gt;some text&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var x = document.getElementById(&quot;demo2&quot;);
    x.style.color = '#6600FF';
    x.style.width = '100px';
&lt;/script&gt;</code></pre><p>所有的 css properties 都可以通过 JavaScript 修改。但是要注意，JavaScript 中相关 property 时，<strong>名称中不能够使用 dash<code>-</code> 横杠</strong>，如果 css 属性名称有横杠，需要转换成 camelCase versions，也就是相关首字母转换成大写。例如：js 在调用 <code>background-color</code> property 时需要写成 <code>backgroundColor</code>。</p><h3>Adding & Removing Elements 创建和删除元素</h3><p><strong>Adding Elements</strong></p><p>使用下面的 method 来创建节点 node：</p><ul><li><code>element.cloneNode()</code> clone 一个节点并将其返回</li><li><code>document.createElement(element)</code> 创建一个新元素的节点</li><li><code>document.createTextNode(text)</code> 创建一个新的 text 节点</li></ul><p>下面简单说下元素和节点：</p><pre><code>&lt;div&gt;
    test1
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre><p>以上示例中，<code>div</code> 就是一个 element 元素，<code>test1</code> 就是这个元素下的 text node 节点，<code>p</code> 就是 <code>div</code> 元素下的另一个子元素节点。</p><p>例如：</p><pre><code>var node = document.createTextNode(&quot;Some new text&quot;);
</code></pre><p>将会创建一个 text 节点，但是当前它并不会出现在页面上，因为还没有定义它属于那个元素。</p><p><code>element.appendChild(newNode)</code> method 来给元素添加一个新的子节点，并放在最后。</p><p><code>element.insertBefore(node1, node2)</code> method 将添加的新直接点 node1 放在已有的子节点 node2 之前。</p><p>下面做一个示例：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo3&quot;&gt;test&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var p = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;some text&quot;);
    p.appendChild(node);

    var el = document.getElementById(&quot;demo3&quot;);
    el.appendChild(p);
&lt;/script&gt;</code></pre><p>以上出现的执行过程为：创建一个元素 <code>p</code> 和 text node <code>node</code>，然后将 node 作为 p 的子元素，最后将 p 添加到 el 中。</p><p><strong>Removing Elements</strong></p><p>想要<strong>删除一个元素</strong>，首先需要选中其 parent 元素，然后使用 <code>removeChild(node)</code> method 来删除相关子元素，例如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;some text one&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;some text two&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.removeChild(child);
&lt;/script&gt;</code></pre><p>也可以使用 <code>parentNode</code> property 来获取某个子元素的 parent 元素，然后执行相关操作：</p><pre><code>child.parentElement.removeChild(child);</code></pre><p><strong>Replacing Elements</strong></p><p>使用 <code>element.replaceChild(newNode, oldNode)</code> method 来替换一个元素。例如：</p><pre><code>&lt;script&gt;
    var newEl = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;this is a new node&quot;);
    newEl.appendChild(node);

    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.replaceChild(newEl, child);
&lt;/script&gt;</code></pre><h3>Animations 动态效果</h3><p>现在我们已经知道如何选择和修改元素，下面我们可以创建一个简单的动画效果。</p><p>首先建立一个 html 页面，包含一个 box 元素，后期通过 js 来让它动起来：</p><pre><code>&lt;style&gt;
    #container {
        width: 200px;
        height: 200px;
        background: green;
        position: relative;
    }
    #box {
        width: 50px;
        height: 50px;
        background: red;
        position: absolute;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre><p><strong>box</strong> 元素是 <strong>container</strong> 的子元素，注意两个的 <code>position</code> attribute，container 是 <strong>relative</strong>，box 是 <strong>absolute</strong>，我们将创建一个让 box 从左移动到右的动画。</p><p>为了实现动态效果，我们需要在一个很小的时间间隔下修改元素的相关 properties，可以使用 <code>setInterval()</code> method：</p><pre><code>&lt;script&gt;
    var pos = 0;
    var box = document.getElementById(&quot;box&quot;);

    function move() {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }

    setInterval(move, 10);
&lt;/script&gt;</code></pre><p>以上指令控制 <strong>box</strong> 的 <strong>left</strong> property 每 10 毫秒移动 1 位。</p><p>但是以上的代码会让 box 元素一直向右移动，我们可以加一个简单的判断来检测 box 到达 container 边沿，然后使用  <code>clearInterval()</code> method 停止定时器：</p><pre><code>function move() {
    if (pos &gt;= 150) {
        clearInterval();
    } else {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }
}</code></pre><p>当 <strong>left</strong> 属性达到 150 时，由于 <strong>box</strong> 宽度为 50，<strong>container</strong> 宽度为 200，这时候 <strong>box</strong> 已经达到边沿。</p><h3>Handling Events 事件处理</h3><p>我们可以实现当一个 event 事件发生时执行特定 JavaScript 代码，如点击某个元素，移动鼠标，提交一个表格等。</p><p>当一个 event 发生在目标元素上时，一个 handling function 会被执行。常用的 html events 包括：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/171918129.png" alt="3.png" title="3.png"></p><p>event 事件可以作为一个属性添加在元素内，如：</p><pre><code> &lt;p onclick=&quot;someFunc()&quot;&gt;some text&lt;/p&gt;
</code></pre><p>下面我们创建一个事件，当用户点击元素时弹出一个窗口：</p><pre><code>&lt;body&gt;
    &lt;button onclick=&quot;show()&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    function show() {
        alert(&quot;hello&quot;);
    }
&lt;/script&gt;</code></pre><p>event handling 事件响应也可以在 js 中直接分配给 elements：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;demo&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;demo&quot;);
    el.onclick = function () {
        el.innerHTML = &quot;clicked&quot;;
    }
&lt;/script&gt;</code></pre><p><strong>onload</strong> 和 <strong>onunload</strong> events 会在用户进入和离开页面时被触发。可以用来实现当页面加载完成后执行的动作：</p><pre><code>&lt;body onload=&quot;doSomething()&quot;&gt;
</code></pre><p>类似的 <code>window.onload</code> event 可以在整个页面加载后执行动作：</p><pre><code>window.onload = function () {
    //do someting
}</code></pre><p><code>onchange</code> event 在文本框中很有用，当文本框的 text 内容被修改同时元素不在 focus 状态时 <code>onchange</code> event 响应。</p><p>例如：</p><pre><code>&lt;body&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; onchange=&quot;changed()&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    function changed() {
        var el = document.getElementById(&quot;name&quot;);
        el.value = el.value.toUpperCase();
    }
&lt;/script&gt;</code></pre><p>以上示例中，当我们在文本框输入字符，然后将光标移动到其他地方或者敲回车键后，文本框字符会自动转换为大写。</p><p>理解 events 很重要，因为它是实现动态页面的核心。</p><p><strong>Event Listeners</strong></p><p><code>addEventListener()</code> method 可以给一个元素添加 event handler 而不会覆盖其已有的 event handlers。可以给一个元素添加多个 event handler 甚至是统一类型的 handler，比如可以添加两个 <code>click</code> handler。</p><p>语法如下：</p><pre><code>element.addEventListener(event, function, useCapture);
</code></pre><ul><li>第一个参数是 event 类型，如："click" 或 "mousedown"，需要用引号包围</li><li>第二个参数是事件发生时调用的 function 名称，不需要写小括号<code>()</code></li><li>第三个参数时一个 Boolean 数值，定义是使用 event bubbling 还是 event capturing，这个参数是可选项，后续会介绍</li></ul><p><strong>注意这里 event 名称不需要 <code>on</code> 前缀</strong>，使用 <code>click</code> 代替 <code>onclick</code>。</p><pre><code>element.addEventListener(&quot;click&quot;, myFunction);
element.addEventListener(&quot;mouseover&quot;, myFunction);

function myFunction() {
  alert(&quot;Hello World!&quot;);
}</code></pre><p>以上代码给元素添加了两个 event handler，我们可以删除其中一个：</p><pre><code>element.removeEventListener(&quot;mouseover&quot;, myFunction);
</code></pre><p>下面的示例中，我们给 button 创建一个 event handler，然后再触发事件后删除这个 event handler：</p><pre><code>&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    var btn = document.getElementById(&quot;btn&quot;);
    btn.addEventListener(&quot;click&quot;, myFunction);

    function myFunction() {
        alert(Math.random());
        btn.removeEventListener(&quot;click&quot;, myFunction);
    }
&lt;/script&gt;</code></pre><p>当第一次点击 button 后会弹出窗口，然后删除 <code>click</code> event，后面点击会没有反应。</p><p>IE8 及以下版本的浏览器不支持 <code>addEventListener()</code> 和 <code>removeEventListener()</code> methods，可以使用 <code>document.attachEvent()</code> 来添加 event handler。</p><p><strong>Event Propagation 事件传播</strong></p><p>在 DOM 中有两种方式进行 event propagation 事件传播：<strong>bubbling</strong> 和 <strong>capturing</strong>。</p><p>当事件触发时，可以定义元素顺序。例如有一个 <code>&lt;p&gt;</code> 元素在 <code>&lt;div&gt;</code> 元素内部，当用户点击 <code>&lt;p&gt;</code> 元素时，哪个元素的 <code>click</code> event handler 首先被触发？</p><ul><li>在 <strong>bubbling</strong> 模式下，最内部元素的 event 最先响应，逐级触发外层元素；</li><li>在 <strong>capturing</strong> 模式下，最外部元素的 event 最先响应，逐级触发内层元素。</li></ul><p><code>addEventListener()</code> method 支持设置事件传播类型，定义下面的 <strong>useCapture</strong> 参数：</p><pre><code>addEventListener(event, function, useCapture)
</code></pre><p><strong>useCapture</strong> 默认值为 <strong>false</strong>，也就是 <strong>bubbling</strong> 模式，当设置为 <strong>true</strong> 时 event 使用 <strong>capturing</strong> 模式。例如：</p><pre><code>//Capturing propagation
elem1.addEventListener(&quot;click&quot;, myFunction, true); 

//Bubbling propagation
elem2.addEventListener(&quot;click&quot;, myFunction, false);</code></pre><p>当同一个 event 存在于多个 DOM 层级中的元素时，设置 event propagation 事件传播模式很有用。</p><h3>Image Slider 幻灯片</h3><p>下面我们制作一个幻灯片程序，通过 <strong>Next</strong> 和 <strong>Prev</strong> button 来切换图片。</p><p>首先创建 html，包含两个 button 和一个 image：</p><pre><code>&lt;html&gt;
&lt;body&gt;
    &lt;button&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>然后再 JavaScript 中定义我们的图片数组：</p><pre><code>&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];
&lt;/script&gt;</code></pre><p>下面需要添加响应 <strong>Next</strong> 和 <strong>Prev</strong> button 的 event handler 来切换不同图片：</p><pre><code>&lt;body&gt;
    &lt;button onclick=&quot;prev()&quot;&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button onclick=&quot;next()&quot;&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];

    var num = 0;
    function next() {
        var slider = document.getElementById(&quot;slider&quot;);
        num++;
        if (num &gt;= images.length)
            num = 0;
        slider.src = images[num];
    }

    function prev() {
        var slider = document.getElementById(&quot;slider&quot;);
        num--;
        if (num &lt; 0)
            num = images.length - 1;
        slider.src = images[num];
    }
&lt;/script&gt;</code></pre><p>效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3936392311.jpg" alt="4.jpg" title="4.jpg"></p><p><strong>num</strong> 变量存储当前图片的 index 索引。</p><h3>Form Validation 表格验证</h3><p>html5 添加了一些用来验证的属性，例如 <strong>required</strong> attribute 能够添加给 <strong>input</strong> 元素来强制必须输入内容。</p><p>更加复杂的验证机制可以通过 JavaScript 完成。</p><p><strong>form</strong> 元素有一个 <strong>onsubmit</strong> event 能够用来进行验证。我们创建一个 form 表格，有两个 input 和一个 button，需要两个 input 输入一样的内容且不为空才通过验证：</p><pre><code>&lt;form onsubmit=&quot;return validate()&quot; method=&quot;post&quot;&gt;
    number: &lt;input type=&quot;text&quot; name=&quot;num1&quot; id=&quot;num1&quot;&gt;
    &lt;br&gt;
    repeat: &lt;input type=&quot;text&quot; name=&quot;num2&quot; id=&quot;num2&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre><p>然后定义 <code>validate()</code> function：</p><pre><code>&lt;script&gt;
    function validate() {
        var n1 = document.getElementById(&quot;num1&quot;);
        var n2 = document.getElementById(&quot;num2&quot;);

        if (n1.value != &quot;&quot; &amp;&amp; n2.value != &quot;&quot;) {
            if (n1.value == n2.value)
                return true;
        }
        alert(&quot;the values shoud be equal and not blank&quot;);
        return false;
    }
&lt;/script&gt;</code></pre><p>只有当 <strong>onsubmit</strong> event 的返回值为 <strong>true</strong> 时，form 才会被提交。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2002.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2002.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之六 -- 核心 Objects]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1997.html" />
<id>https://blog.niekun.net/archives/1997.html</id>
<updated>2020-12-18T18:53:00+08:00</updated>
<published>2020-12-18T18:53:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。JavaScript Arrays 数组当你需要定义三个课程名称时，需要分别定义：var course1 =&amp;quot...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1997.html" xml:lang="zh-CN"><![CDATA[
<p>下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。</p><h3>JavaScript Arrays 数组</h3><p>当你需要定义三个课程名称时，需要分别定义：</p><pre><code>var course1 =&quot;HTML&quot;; 
var course2 =&quot;CSS&quot;; 
var course3 =&quot;JS&quot;; </code></pre><p>当你有 100 个课程名称呢？这时候可以使用 Array：</p><pre><code>var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);</code></pre><!--more--><p>以上定义了一个数组 courses，存储了 3 个元素。</p><p>可以使用 index 索引号内访问数组元素，索引号 0 表示第一个元素：</p><pre><code>var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);
var course = courses[0];
courses[1] = &quot;c++&quot;;</code></pre><p>以上示例表示：给变量 course 赋值数组第一个元素，给第二个元素赋值 <code>c++</code>。</p><p><strong>如果尝试访问超出数组元素的索引，会返回 <code>undefined</code></strong>。</p><p>在定义数组时也可以只申明数组元素个数，后续再给元素赋值：</p><pre><code>var courses = new Array(3);
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;</code></pre><p>array 数组是一种特殊的 object，它使用 index number 来访问元素，而标准 object 使用 property name 来访问元素。</p><p>JavaScript array 是动态的，也就是你可以在创建时不传入任何参数给构造器：</p><pre><code>var courses = new Array();
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;
courses[3] = &quot;C++&quot;;</code></pre><p>你可以添加任意多个元素给数组。</p><p>为了定义更加方便，可以使用 array literal 语法来创建数组：</p><pre><code>var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];</code></pre><p>以上语法和使用 <code>new</code> 关键词创建的数组是一样的。<strong>推荐使用这种语法</strong>。</p><p><strong>JavaScript array 内建了很多实用的 properties 和 method。</strong></p><p>array 的 <code>length</code> property 返回数组的元素个数：</p><pre><code>var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
document.write(courses.length);</code></pre><p><code>length</code> 的返回值比最后一个元素的索引号大 1，如果数组为空，则返回值为 0。</p><p>使用 <code>concat()</code> method 可以叠加两个数组并返回为一个新的数组：</p><pre><code>var c1 = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
var c2 = [&quot;C++&quot;];
var newC = c1.concat(c2);</code></pre><p>newC 数组拥有四个元素："HTML", "CSS", "JS", "C++"。注意使用 <code>concat()</code> method 并不会影响 c1 和 c2。</p><p><strong>Associative Arrays</strong> 关联型数组</p><p>很多编程语言支持给数组添加命名化的 index 索引，也就是给每个元素定义一个名称，<strong>但是 JavaScript 不支持这种操作</strong>。</p><p>但是我们依然可以定义命名化的 index 索引数组，JavaScript 会将其作为一个 object 处理：</p><pre><code>var a = [];
a[&quot;name&quot;] = &quot;marco&quot;;
a[&quot;age&quot;] = 20;
document.write(a[&quot;age&quot;]);</code></pre><p>JavaScript 会将 a 作为 object 处理，这样 name 和 age 就是其 properties。可以使用以上写法来读取 property 数据。</p><p>由于 a 数组被作为 object 处理，所以标准 array 的一些 method 和 properties 将无法正确执行，例如：<code>a.length</code> 返回值将是 0 而不是 2。</p><p>JavaScript 原生并不支持命名化的元素索引，所以<strong>推荐</strong>当你想要使用 number 数字型 index 时使用 array，当你想要使用命名化的索引时使用 object。</p><h3>the Math Object 数学对象</h3><p>the Math Object 可以用来处理数学运算任务，它包含多个 properties：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2493943028.png" alt="1.png" title="1.png"></p><p><strong>Math 没有 constructor 构造器</strong>，所以使用时并不需要单独创建 object。例如：</p><pre><code>document.write(Math.PI);
</code></pre><p>以上将输出：3.141592653589793</p><p>Math object 包含多个 method 用来计算：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2808938315.png" alt="2.png" title="2.png"></p><p>下面示例计算 4 的平方根：</p><pre><code>var a = Math.sqrt(4);</code></pre><p>如果想要得到一个 0- 10 的随机数，可以使用下面方法：</p><pre><code>Math.ceil(Math.random() * 10);
</code></pre><p>下面编写一个小程序，让用户输入一个数字然后将这个数字的平方根放在弹窗通知中：</p><pre><code>var n = prompt(&quot;please input a number: &quot;, &quot;&quot;);
var m = Math.sqrt(n);
alert(m);</code></pre><h3>The Date Object 时间对象</h3><p><code>setInterval()</code> method 用来在指定的间隔时间(毫秒)下调用 function 或评估一个表达式。它将会持续调用直到执行 <code> clearInterval()</code> 或关闭窗口。</p><p>下面的示例将会每三秒钟弹出窗口：</p><pre><code>function myAlert() {
    alert(&quot;hello&quot;);
}
setInterval(myAlert, 3000);</code></pre><p>注意传递 function 时只需要写 function 名称即可，不需要小括号<code>()</code>。</p><p><code>Data</code> object 可以让我们使用时间元素，一个 <code>Date</code> object 由：a year, a month, a day, an hour, a minute, a second, and milliseconds 构成。</p><p>使用 <code>new</code> 关键词来创建一个 Date obect，包含有当前的<strong>日期和时间</strong>：</p><pre><code>var d = new Date();
//d stores the current date and time</code></pre><p>也可以使用指定的日期和时间来创建 Date object：</p><pre><code>new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)</code></pre><p>JavaScript 日期计算使用毫秒为单位，起始日期为：01 January, 1970 00:00:00 (UTC)。一天包含 86,400,000 毫秒。</p><p>以下示例使用不同方式定义指定日期：</p><pre><code>//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000); 

//Fri Jan 02 2015 10:42:00
var d2 = new Date(&quot;January 2, 2015 10:42:00&quot;);

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);</code></pre><p>JavaScript 的月份从 0 到 11，1 月就是 0，12 月就是 11。Date object 是 static 类型的，创建后就不会改变。</p><p>Date object 有如下 method 可供使用：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/986046713.png" alt="3.png" title="3.png"></p><p>例如读取当前小时数值：</p><pre><code>var d = new Date();
document.write(d.getHours());</code></pre><p>下面示例在窗口显示当前时间，且每秒刷新一次：</p><pre><code>function printTime() {
    var d = new Date();
    var hour = d.getHours();
    var min = d.getMinutes();
    var sec = d.getSeconds();
    document.body.innerHTML = hour + &quot;:&quot; + min + &quot;:&quot; + sec;
}

setInterval(printTime, 1000);</code></pre><p><code>innerHTML</code> property 可以设置或返回一个 HTML 元素的内容，这里我们将 document 的 body 块的内容赋值为我们定义的时间数据，并且每秒覆盖更新一次。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1997.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1997.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之五 -- Objects]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1996.html" />
<id>https://blog.niekun.net/archives/1996.html</id>
<updated>2020-12-18T15:25:00+08:00</updated>
<published>2020-12-18T15:25:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[JavaScript 的 variables 变量是用来包含数据的容器。object 同样是变量，但是包含了多个数据。一个 object 是一组使用 name:value 模式定义的数据集合，大...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1996.html" xml:lang="zh-CN"><![CDATA[
<p>JavaScript 的 variables 变量是用来包含数据的容器。object 同样是变量，但是包含了多个数据。</p><p>一个 object 是一组使用 <strong>name:value</strong> 模式定义的数据集合，大括号<code>{}</code> 内部定义数据，数据间使用逗号<code>,</code> 分隔，注意大括号结尾的分号<code>;</code>：</p><pre><code>var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 170
};</code></pre><!--more--><p>这些数据叫做 <strong>properties</strong>：</p><table><thead><tr><th align="center"> </th><th align="center"> </th></tr></thead><tbody><tr><td align="center"><strong>property</strong></td><td align="center"><strong>property value</strong></td></tr><tr><td align="center">name</td><td align="center">marco</td></tr><tr><td align="center">age</td><td align="center">20</td></tr><tr><td align="center">like</td><td align="center">basketball</td></tr><tr><td align="center">height</td><td align="center">170</td></tr></tbody></table><p>object 初始化语法可以写在一行，也可以写在多行。以下两种写法都是一样的：</p><pre><code>var John = {name: &quot;John&quot;, age: 25};

var John = {
  name: &quot;John&quot;,
  age: 25
};</code></pre><p>JavaScript 的 object 就是一组有命名的数据的容器。</p><p>有两种方法访问 object 的 properties：</p><pre><code>objectName.propertyName
//or
objectName['propertyName']</code></pre><p>使用上面的示例访问 properties，以下两种结果是一样的：</p><pre><code>var x = person.age;
var y = person['age'];</code></pre><p>使用 JavaScript 内建的 <code>length</code> property 可以得到 property 或 string 包含的字符个数:</p><pre><code>var a = person.name.length;</code></pre><h3>method</h3><p><strong>object method</strong> 就是一个定义了 function 的 property，使用 object method 的语法为：</p><pre><code>objectName.methodName()
</code></pre><p>我们前面多次使用 <code>document.write()</code> 来输出内容到网页，实际上 <code>write()</code> function 就是 document object 的一个 method。</p><p>定义一个 method 的语法如下：</p><pre><code>methodName = function() { code lines }
</code></pre><p>在上面的示例中给 object 加入一个 method：</p><pre><code>var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 62,
    test: function() {
        alert(&quot;method&quot;);
    }
};

person.test();</code></pre><p>使用 method 的方法和 properties 一样，需要加上小括号<code>()</code>。</p><h3>The Object Constructor 构造器</h3><p>上一节我们学习了如何建立 object，例如：</p><pre><code>var person = {
name: &quot;John&quot;, age: 42, favColor: &quot;green&quot;
};</code></pre><p>以上的写法一次只能创建一个 object，那么如何设置一种 <strong>object type</strong> 用来创建多个统一类型的 objects 呢？</p><p>标准的方法是使用 <strong>constructor function</strong> 构造器来定义一个 <strong>object type</strong>：</p><pre><code>function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}</code></pre><p>以上就是一个 constructor function，接收传入数据来赋值给 object properties。关键词 <code>this</code> 表示当前 object 本身。</p><p>当我们定义了一个 object constructor，就可以使用关键词 <code>new</code> 来新建一个 object：</p><pre><code>var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
document.write(p1.name);

//output:
//marco</code></pre><p>p1 就是 person 类型的 object，它的 properties 就是对应传入的数据。</p><p>同样的方法，可以在 object constructor 中定义 method：</p><pre><code>    function person(name, age, color) {
        this.name = name;
        this.age = age;
        this.favColor = color;
        this.changeName = function(name) {
            this.name = name;
        }
    }

    var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
    p1.changeName(&quot;john&quot;);
    document.write(p1.name);</code></pre><p>以上示例中，我们定义了一个 <code>changeName</code> method，它有一个参数 <code>name</code> 用来赋值给 object 的 propertiy <code>name</code>。</p><p>也可以在 object constructor function 外部定义 method：</p><pre><code>function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = bornyear;
}

function bornyear() {
    return 2020 - this.age;
}

var p1 = new person(&quot;marco&quot;, 25);
document.write(p1.yearOfBirth());</code></pre><p>以上示例中，我们给 property <code>yearOfBirth</code> 赋值为 <code>bornyear</code>。<code>bornyear</code> function 在外部定义，this 关键词可以来访问 person 的 properties，因为 bornyear 复制给了 person 的一个 property。</p><p><strong>注意当将一个 function 赋值给 object 时不需要写小括号<code>()</code></strong>。</p><p>通过 object property name 来调用构造器定义的 method，注意不是外部 function 的名称。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1996.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1996.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之四 -- Functions]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1992.html" />
<id>https://blog.niekun.net/archives/1992.html</id>
<updated>2020-12-18T13:58:00+08:00</updated>
<published>2020-12-18T13:58:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[JavaScript function 就是一个执行特定任务的代码块。使用 function 的优点是：代码复用通过传入不同参数得到不同结果function 需要被调用才能执行。]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1992.html" xml:lang="zh-CN"><![CDATA[
<p>JavaScript function 就是一个执行特定任务的代码块。</p><p>使用 function 的优点是：</p><ul><li>代码复用</li><li>通过传入不同参数得到不同结果</li></ul><p>function 需要被调用才能执行。</p><!--more--><h3>定义</h3><p>使用关键词 <code>function</code> 来定义一个 function，需要指定名称，使用大括号<code>{}</code> 来定义代码块：</p><pre><code>function name() { 
  //code to be executed
}</code></pre><p>function name 可以包含字符、数字，下划线和 <code>&amp;</code> 符号。</p><p>下面定义一个简单的 function：</p><pre><code>function myFunction() {
    alert(&quot;call the function&quot;);
}

myFunction();</code></pre><p>一个 function 可以被调用任意次数，</p><p>当需要调用 function 时，直接使用 function name 名称及小括号<code>()</code> 即可。注意结尾要写分号<code>;</code>。</p><p>还有一种调用写法：<code>myFunction.call()</code>。当使用这种方法时，会自动将关键词 <code>this</code> 传入此 function，后续会详细介绍。</p><h3>function 参数</h3><p>function 可以接收参数，在定义时需要列出来：</p><pre><code>functionName(param1, param2, param3) {
   // some code
}</code></pre><p>多个参数使用逗号<code>,</code> 隔开。</p><p>当定义了参数后，就可以在 function 代码块内使用：</p><pre><code>function myFunction(name) {
    alert(&quot;hi &quot; + name);
}

myFunction(&quot;marco&quot;);</code></pre><p>以上第一了一个 function 有一个 name 参数，当调用此 function 时需要给 name 赋值。function 内部就会将赋值数据分配个 name 参数。</p><p>调用 function 时，通过不同的参数值来得到不同的结果：</p><pre><code>myFunction(&quot;marco&quot;);
myFunction(&quot;john&quot;);
myFunction(&quot;tom&quot;);</code></pre><p>使用逗号分隔多个参数：</p><pre><code>function myFunction(name, age) {
    alert(&quot;my name is &quot; + name + &quot;, age is &quot; + age);
}

myFunction(&quot;marco&quot;, 20);</code></pre><p>JavaScript 不会检查调用 function 时的传入参数个数和定义的参数个数是否一致，如果调用时缺少传递参数，则缺失的参数会被赋值为 <code>undefined</code>，表示没有被分配数据。</p><p>function 可以有一个可选的 <code>return</code> 命令，用来从 function 返回一个数据。</p><p>当 JavaScript 执行到 <code>return</code> 时，会停止执行后续指令。</p><p>下面的示例中，我们计算两个参数的和并返回结果：</p><pre><code>function myFunction(a, b) {
    return a + b;
}

var x = myFunction(1, 2);</code></pre><p>变量 x 的值就是 3。</p><p><strong>如果 function 中没有 <code>return</code> 则默认会返回  <code>undefined</code></strong>。</p><h3>Alert, Prompt, Confirm</h3><p>JavaScript 提供三种弹出窗口：Alert, Prompt, Confirm。</p><p><strong>alert Box</strong> 用来给用户显示一个提示信息，需要点击 OK 来取消弹窗。有一个参数：</p><pre><code>alert(&quot;this is a alert&quot;);</code></pre><p>信息中需要换行的话可以加入 <code>\n</code>：</p><pre><code>alert(&quot;this is\n a alert&quot;);
</code></pre><p>效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/1686727989.jpg" alt="2.jpg" title="2.jpg"></p><p><strong>Prompt Box</strong> 用来弹出一个用户可以输入数据的提示窗口。</p><p>用户需要点击 OK 或 cancel 来退出窗口，如果点击 OK 则会 return 输入的数据，如果点击 cancel 则会返回 null。</p><p><code>prompt()</code> 有两个参数，第一个是窗口显示的提示信息字符串，第二个是输入框的默认字符(可选项)：</p><pre><code>var a = prompt(&quot;please input value&quot;, &quot;test&quot;);
document.write(a);</code></pre><p>效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/600067485.jpg" alt="3.jpg" title="3.jpg"></p><p>选择 OK 后变量 a 会赋值为输入的数据。</p><p><strong>confirm box</strong> 可以用来作为确认对话框。</p><p>用户必须点击 OK 或 cancel 来退出窗口，当点击 OK 后 box 会返回 true，当点击 cancel 后 box 会返回 false：</p><pre><code>var result = confirm(&quot;if confirm&quot;);

if (result) {
    alert(&quot;confirmed&quot;);
}
else {
    alert(&quot;not confirmd&quot;);
}</code></pre><p>弹出窗口不要过多的使用，因为弹出窗口会导致页面不可用。</p><h3>inline function</h3><p>有一种特殊的 function 可以在直接在调用中进行定义，不需要写 function 名称。例如想要对 array 数组的每个元素执行一个 function，通过 <code>forEach</code> method 来给每个元素调用 function：</p><pre><code>var arr = [1, 2, 3];
arr.forEach(function(el) {
    console.log(el * 2);
});</code></pre><p>function 直接在调用中定义，参数 el 的值通过 <code>forEach</code> method 来传入每个元素的数据。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1992.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1992.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之三 -- Conditionals and Loops]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1990.html" />
<id>https://blog.niekun.net/archives/1990.html</id>
<updated>2020-12-18T11:10:00+08:00</updated>
<published>2020-12-18T11:10:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[The if Statement在编程中，如果想要根据不同的情况执行不同的代码，可以使用 if conditional statements 状况指令来处理，语法如下：if (condition...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1990.html" xml:lang="zh-CN"><![CDATA[
<h3>The if Statement</h3><p>在编程中，如果想要根据不同的情况执行不同的代码，可以使用 <code>if conditional statements</code> 状况指令来处理，语法如下：</p><pre><code>if (condition) {
   statements
}</code></pre><p>使用 if 语法来根据 condition 是否为 true 来确定是否执行 statements。下面举例说明，修改 html 文件 script 部分：</p><pre><code>var a = 1;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}</code></pre><!--more--><p>效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/185715999.jpg" alt="1.jpg" title="1.jpg"></p><p>如果修改 condition 不为 true 则不会执行内部指令：</p><pre><code>var a = 2;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}</code></pre><p>以上示例不会执行 alert function。</p><p>注意如果 statement 指令只有一句时，<strong>可以省略大括号</strong>，如下写法也是正确的：</p><pre><code>var a = 1;
if (a == 1)
    alert(&quot;a is 1&quot;);</code></pre><p>使用 <code>else</code> 申明来 condition 为 false 时执行的指令：</p><pre><code>if (expression) {
   // executed if condition is true
}
else {
   // executed if condition is false
}</code></pre><p>下面举例说明：</p><pre><code>var a = 1;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else
    alert(&quot;a is bigger than b&quot;);</code></pre><p>以上示例实现的动作也可以使用我们上一章提到的状况判断符来实现：</p><pre><code>a &lt; b ? alert(&quot;a smaller than b&quot;) : alert(&quot;a is bigger than b&quot;);
</code></pre><p>如果 condition 不止有两种情况要处理，可以使用 <code>else if</code> 申明多个情况下的指令，修改上面的示例：</p><pre><code>var a = 2;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else if (a == b)
    alert(&quot;a equal to b&quot;);
else
    alert(&quot;a is bigger than b&quot;);</code></pre><p>则会执行 <code>alert(&quot;a equal to b&quot;);</code> 指令。</p><p>注意 <code>else</code> 在整个块中必须作为最后一个申明写在 <code>if</code> 和 <code>else if</code> 之后，如果所有 condition 的条件都不满足则会执行 <code>else</code> 中的申明指令。</p><p>可以根据情况使用任意多个 <code>else if</code> 申明。</p><h3>switch</h3><p>当 condition 有多个情况需要处理时，使用 <code>else if</code> 就会很麻烦。这时候可以使用 <code>switch statement</code> 来处理，语法如下：</p><pre><code>switch (expression) {
  case n1: 
     statements
     break;
  case n2: 
     statements
     break;
  default: 
     statements
}</code></pre><p><code>switch expression</code> 会被评估一次，然后在 <code>case</code> 中寻找匹配的结果并执行对应块的指令。</p><p>以下是一个简单示例：</p><pre><code>var day = 2;
switch (day) {
    case 1:
        document.write(&quot;today is monday&quot;);
        break;
    case 2:
        document.write(&quot;today is tuesday&quot;);
        break;
    default:
        document.write(&quot;today is another day&quot;);
        break;
}</code></pre><p>当 day 的值为 2，则会匹配到 case 2 并执行其内的指令。</p><p>当 JavaScript 执行到 <code>break</code> 后会跳出 switch 块，如果不写 <code>break</code> 则会顺序执行下面的指令，即使不满足其他的 case 条件。<strong>通常情况下每个 case 块结尾都应该有</strong> <code>break</code>。</p><p><code>default</code> 关键词用来处理没有匹配到任何 <code>case</code> 情况，如果没有匹配到则执行 default 中的指令。如果不需要处理没有指定的 case 匹配到的情况时 default 可以被省略。</p><h3>for 循环</h3><p>使用 loop 循环可以多次执行一段代码，通过一些条件来控制循环次数及参数值。</p><p>JavaScript 提供三种类型的循环：for, while, 和 do while。</p><p>for 循环语法如下：</p><pre><code>for (statement 1; statement 2; statement 3) {
   code block to be executed
}</code></pre><ul><li>Statement 1 在循环前被执行</li><li>Statement 2 定义执行循环的状态</li><li>Statement 3 在每次循环后被执行</li></ul><p>下面的示例将输出 0 - 4：</p><pre><code>for (var i=0; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}</code></pre><p>过程为：首先给变量 i 赋值为 1，执行循环的条件是 i&lt;5，每次循环后给 i 加 1。当 i==4 时，执行完本次循环后 i 加 1 后值为 5，不满足第二项条件就会跳出循环。</p><p><strong>statement 1</strong> 是可选项可以不写，如：</p><pre><code>var i = 0;
for (; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}</code></pre><p>和第一个示例效果是一样的。</p><p><strong>statement 1</strong> 也可以同时定义多个参数，使用逗号<code>,</code> 来隔离，如：</p><pre><code>for (var i=0, j=2; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}</code></pre><p>如果 <strong>statement 2</strong> 返回 true 则会执行循环块内容，如果返回 false 则会结束循环。</p><p>同样的 <strong>statement 2</strong> 也是可选项，也可以不定义，但是必须在循环块内定义 <code>break</code> 不然就会无线循环下去：</p><pre><code>for (var i=0; ; i++) {
    if (i &gt;= 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}</code></pre><p>statement 3 用来修改初始变量的值，同样也是可选项，可以在循环块内部直接修改初值：</p><pre><code>for (var i=0; i&lt;5 ;) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}</code></pre><h3>while 循环</h3><p>while 循环也是用来实现当某个 condition 为 true 时循环一个代码块。语法如下：</p><pre><code>while (condition) {    
   code block
}</code></pre><p>下面的示例将输出 0 - 10 的数字：</p><pre><code>var i = 0;
while (i&lt;=10) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}</code></pre><p>当 condition 一直为 true 时，循环就会继续下去。我们应该避免无限循环情况出现。</p><h3>do while 循环</h3><p>do while 循环是 while 循环的一种变形，它会首先执行一次循环块然后判断 condition 条件。语法如下：</p><pre><code>do {
   code block
}
while (condition);</code></pre><p>注意 while 结尾的分号<code>;</code> 不能省略。</p><p>下面的示例会输出 0 - 4：</p><pre><code>var i = 0;
do {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
} while (i&lt;5);</code></pre><p><strong>循环块至少会执行一次，即使 condition 为 false。</strong></p><h3>break</h3><p><code>break</code> 指令用来跳出循环继续执行后续程序。</p><p>下面示例中，将只会输出 0 - 4 的数字：</p><pre><code>for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}</code></pre><p>在 function 中可以使用 return 来跳出当前代码块，下一章节将会介绍。</p><h3>continue</h3><p><code>continue</code> 指令用来仅跳出当次循环，然后继续进行下一次循环。</p><p>下面示例将会输出 0- 10，但不包括 5：</p><pre><code>for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        continue;
    document.write(i + &quot;&lt;br&gt;&quot;);
}</code></pre><p>当 i 等于 5 时会跳出本次循环所以不会输出 5，但是会继续进行下面的循环。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1990.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1990.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之二 -- 基本概念]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1985.html" />
<id>https://blog.niekun.net/archives/1985.html</id>
<updated>2020-12-17T16:33:00+08:00</updated>
<published>2020-12-17T16:33:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[数学运算符有以下运算符可以使用：加减运算使用方法很简单：var b = 10 + 2;var c = b - 3;document.write(c);]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1985.html" xml:lang="zh-CN"><![CDATA[
<h3>数学运算符</h3><p>有以下运算符可以使用：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2072140588.png" alt="1.png" title="1.png"></p><p><strong>加减运算</strong>使用方法很简单：</p><pre><code>var b = 10 + 2;
var c = b - 3;
document.write(c);</code></pre><!--more--><p>可以使用 <code>eval()</code> 来将计算结果转换为字符串形式：</p><pre><code>var d = eval(&quot;10 + 2 + 1&quot;)
document.write(d);</code></pre><p>d 的结果就是 <code>&quot;13&quot;</code>。</p><p><strong>乘法使用星号<code>*</code> 来表示</strong>，以下三种写法都是正确的：</p><pre><code>var e = 2 * 3;
var f = 2 * '3';
var g = '2' * '3';
document.write(g);</code></pre><p>注意如果尝试对一个字符串进行乘法计算会返回：NaN (Not a Number)：</p><pre><code>var h = 'hello' * 2;
document.write(h);

//output：
//NaN</code></pre><p><strong>除法使用斜线<code>/</code> 表示</strong>：</p><pre><code>var i = 1 / 2;</code></pre><p>注意被除数不能为 0。</p><p>取模运算使用<code>%</code> 表示：</p><pre><code>var j = 10 % 3;
document.write(j);

//output:
//1</code></pre><p>可以对整数和浮点型数字进行取模运算。</p><p><strong>递增和递减</strong>：</p><p><img src="https://blog.niekun.net/usr/uploads/2020/12/1935080336.png" alt="2.png" title="2.png"></p><p>使用<code>++</code> 表示给对应变量进行加 1 运算，操作符写在变量前则返回加 1 后的值。写在后边返回加 1 前的值。<br>使用<code>--</code> 表示给对应变量进行减 1 运算，操作符写在变量前则返回减 1 后的值。写在后边返回减 1 前的值</p><pre><code>var k = 10;
var l = k++;
var m = ++l;
document.write(m);

//output:
//11</code></pre><h3>分配符 Assignment Operators</h3><p>可用的分配符有：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3717535399.png" alt="3.png" title="3.png"></p><p>除了常规用法外，也可以在一行命令中使用多个分配符，例如：</p><pre><code>var n = 4;
var o = 5;
o += n += 3;
document.write(o);

//output:
//12</code></pre><h3>比较符 Comparison Operators</h3><p>在逻辑判断中使用比较符来比较数据是否有区别。结果为 true 或 false。</p><p>例如可以使用 equal to (==) operator 来比较两个数据是否一样：</p><pre><code>var p = 2;
document.write(p == 1);

//output:
//false</code></pre><p>所有的数据类型都可以进行比较，返回值只有 true 和 false。但需要注意比较的两个数据需要是同一类型的。</p><p>以下是可用的比较符：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/218772581.png" alt="4.png" title="4.png"></p><h3>逻辑判断符 Logical Operators</h3><p>逻辑判断符用来评估一个表达式，返回结果为 true 和 false。可用的逻辑判断符为：<strong>AND, OR, NOT</strong>：</p><ul><li><code>&amp;&amp;</code> - AND 如果判断块都为 true，则返回 true</li><li><code>||</code> - OR  如果任何一个判断块为 true，则返回 true</li><li><code>!</code> - NOT  如果判断块为 false，则返回 true</li></ul><p>下面的示例是对两个判断块进行 与<code>AND</code> 操作：</p><pre><code>(4 &gt; 2) &amp;&amp; (1 &lt; 3);</code></pre><p>以上两个判断块都为 true 则整个逻辑判断结果为 true。</p><h3>状况判断符 Conditional (Ternary) Operator</h3><p>状况判断符用来根据一些实际状态给某个变量赋值。语法如下：</p><pre><code>variable = (condition) ? value1: value2 
</code></pre><p>下面举例说明：</p><pre><code>var age = 20;
var isAdult = (age &lt; 18) ? &quot;too young&quot; : &quot;old enough&quot;;
document.write(isAdult);

//OUTPUT:
//old enough</code></pre><p>以上示例中，如果 age 小于 18 则 isAdult 赋值为 "too young"，如果 age 大于等于 18 则 isAdult 赋值为 "old enough"。</p><h3>字符串操作符 String Operators</h3><p>我们可以使用级联符<code>+</code> 来将多个字符串组合成一个新的字符串。例如：</p><pre><code>var str1 = &quot;this is a &quot;;
var str2 = &quot;test string&quot;;
document.write(str1 + str2);

//output:
// this is a test string</code></pre><p>注意一个数字使用引号括起来后就成了一个字符串，如：<code>&quot;42&quot;</code> 表示一个字符串。。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1985.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1985.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[JavaScript 入门教程之一 -- 总览]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1979.html" />
<id>https://blog.niekun.net/archives/1979.html</id>
<updated>2020-12-17T10:31:00+08:00</updated>
<published>2020-12-17T10:31:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1979.html" xml:lang="zh-CN"><![CDATA[
<blockquote>JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。最初命名为 Mocha，1995年9月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年12月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上 Java 这个编程语言“热词”，因此将其临时改名为 JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。</blockquote><p>不同于服务器端脚本语言，例如 PHP 与 ASP，JavaScript 主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于 JavaScript 以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器变得强大，现在的程序员更喜欢运行于服务端的脚本以保证安全，但 JavaScript 仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖 JavaScript 在客户端进行支持。随着引擎如 V8 和框架如 Node.js 的发展，及其事件驱动及异步 IO 等特性，JavaScript 逐渐被用来编写服务器端程序。且在近几年中，Node.js 的出世，让 JavaScript 也具有了一定的服务器功能。</p><!--more--><h3>我们的第一个 JavaScript</h3><p>我们首先来了解一些基本概念，给 web 网页加上 JavaScript。</p><p>在 web 上，JavaScript 位于 HTML document 内，可以在任意位置。js 内容使用 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 包围起来：</p><pre><code>&lt;script&gt;
   ...
&lt;/script&gt;</code></pre><p>让我们使用 JavaScript 在网页上打印出一个 <strong>Hello World</strong>，新建一个 html 文件，内容如下：</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        
    &lt;/body&gt;
    &lt;script&gt;
        document.write(&quot;hello world&quot;);
    &lt;/script&gt;
&lt;/html&gt;</code></pre><p>使用 <code>document.write()</code> function 用来给 html document 写入内容。注意此 function 只用来测试，实际使用中会覆盖 document 中已有的内容。</p><p><strong>JavaScript 每条指令结尾使用分号<code>;</code> 来标记。</strong></p><p>文件保存后可以使用浏览器打开查看效果。</p><p>js 中还支持标准 html markup 标记语法，我们给 hello world 设置属性：</p><pre><code>    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
    &lt;/script&gt;</code></pre><p>这时候文字会以标题模式显示。</p><p>也可以在浏览器终端 console 中输出信息，使用 <code>console.log()</code> function 实现：</p><pre><code>    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
    &lt;/script&gt;</code></pre><p>打开浏览器的调试窗口即可看到输出信息，chrome 浏览器使用快捷键 <strong>ctrl+shift+I</strong> 或设置中打开调试：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3155874967.jpg" alt="1.jpg" title="1.jpg"></p><p>点击 console 栏查看：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2655756535.jpg" alt="2.jpg" title="2.jpg"></p><h3>注释</h3><p>对于不需要被执行的语句可以使用符号来忽略，使用双斜杠 <code>//</code> 注释单行内容，使用 <code>/*</code> 和 <code>*/</code> 注释一个块。</p><p>修改我们上面的 html 文件的 js 块：</p><pre><code>    &lt;script&gt;
        // this is a commit
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
        /* this code create
            a alert box
        */
        alert(&quot;this is a alert box&quot;);
    &lt;/script&gt;</code></pre><p><code>alert()</code> function 用来弹出一个提示窗口。</p><h3>变量</h3><p>variables 变量是存储数据的容器。变量的值可以再程序中被修改。</p><p>使用关键词 <code>var</code> 申明一个变量：</p><pre><code>var x = 10;
</code></pre><p>以上指令给变量 x <strong>分配</strong>数据 10。注意我们在此使用 <strong>assign 分配</strong>来描述这个过程，因为在 JavaScript 中等于号<code>=</code> 会调用 <code>assignment</code> operator 操作符，而不是 <code>equal to</code> operator 操作符。</p><p>变量名是大小写敏感的，也就是说 <code>name</code> 和 <code>Name</code> 是两个变量。</p><p>让我们输出一个变量值到浏览器：</p><pre><code>var x = 10;
document.write(x);</code></pre><p><strong>变量定义的基本原则：</strong></p><ul><li>首字符必须是这三者之一：字母，下划线<code>_</code>，<code>$</code> 符。后续字符可以是字母、数字，下划线或者 <code>&amp;</code></li><li>名称不能包含数学运算符或操作符</li><li>不能包含空格</li><li>不能使用特殊字符，如：# & % 等</li><li>不能使用连字符<code>-</code>，这是减法保留符</li></ul><h3>数据类型</h3><p>JavaScript 支持多种类型的数据：numbers, strings, arrays 等。</p><h4>number</h4><p>number 可以是整数或小数：</p><pre><code>var a = 10;
var b = 1.1;</code></pre><p>变量分配的数据类型可以任意修改，例如重新分配 a 的数据为 string 字符串：</p><pre><code>a = &quot;this is a strings&quot;;
</code></pre><h4>string</h4><p>使用 string 可以来存储及操作文本信息。使用引号来包裹内容，单引号<code>'</code> 或双引号<code>&quot;</code> 都可以：</p><pre><code>var a = 'marco';
var b = &quot;john&quot;;</code></pre><p>如果要在 string 内部使用也引号，可以通过内外使用不同的单双引号来实现，js 会自动区分：</p><pre><code>var a = &quot;this is a 'test'&quot;;
</code></pre><p>如果内外想要使用同一个引号形式可以在内部使用转义符 <code>\</code> 来实现：</p><pre><code>a = &quot;this \&quot;is\&quot; a \&quot;other\&quot; test&quot;;
</code></pre><p>转义符可以将特殊字符作为普通字符使用，也可以实现特殊功能，一些列表是常用的转码：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3151408178.png" alt="3.png" title="3.png"></p><p><strong>注意字符串的包裹分号需要前后统一，起始用了单引号结尾也必须使用单引号，否则会报错。</strong></p><h3>Boolean</h3><p>Boolean 只有两种结果：true 和 false。</p><p>如果你需要一种只有两种可能的结果的数据类型，就可以使用 Boolean：</p><pre><code>var isActive = true;</code></pre><p>注意 Boolean 类型的值如果是：0 (zero), null, undefined, empty string 则都是 false，其他如果有一个真实数据的都为 true。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1979.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1979.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[brew 安装路径]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1977.html" />
<id>https://blog.niekun.net/archives/1977.html</id>
<updated>2020-12-16T22:04:00+08:00</updated>
<published>2020-12-16T22:04:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。brew 默认安装路径为：/usr/local/Cellar，然后会在 /usr/local/opt/ 建立所安装的包的软连...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1977.html" xml:lang="zh-CN"><![CDATA[
<p>brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。</p><p>brew 默认安装路径为：<code>/usr/local/Cellar</code>，然后会在 <code>/usr/local/opt/</code> 建立所安装的包的软连接。</p><p>包安装好后如果不能正常执行，可以建立包的可执行程序的软连接到：<code>/usr/local/bin/</code> 目录。</p><p>比如安装 openssl：</p><pre><code>brew install openssl
</code></pre><p>安装后包的路径为：<code>/usr/local/Cellar/openssl@1.1/1.1.1h</code>。同时包的软连接在：<code>/usr/local/Cellar/openssl</code>。</p><p>这时候执行命令：</p><pre><code>openssl version
</code></pre><p>返回的并不是刚才安装的版本，而是系统自带的老版本的。这时候可以建立可执行程序的软连接到对应路径：</p><pre><code>ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
</code></pre><p>这时候执行命令就可以得到正确的返回：</p><pre><code>openssl version
//OpenSSL 1.1.1h  22 Sep 2020
</code></pre><p>其他包的模式和此类似。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1977.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1977.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[QT 网络应用]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1973.html" />
<id>https://blog.niekun.net/archives/1973.html</id>
<updated>2020-12-16T16:59:00+08:00</updated>
<published>2020-12-16T16:59:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近研究了下 QT 如何访问网络，做一些简单总结。首先在 pro 文件内定义网络属性：QT  += network如果需要连接 https 需要安装 openssl 工具，使用 QT 的 Mai...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1973.html" xml:lang="zh-CN"><![CDATA[
<p>最近研究了下 QT 如何访问网络，做一些简单总结。</p><p>首先在 pro 文件内定义网络属性：</p><pre><code>QT  += network
</code></pre><p>如果需要连接 https 需要安装 openssl 工具，使用 QT 的 MaintenanceTool 工具找到 openssl toolkit 并安装。否则执行程序时 ssl 会报错。</p><p>安装后需要将 openssl 路径加入系统 PATH，默认安装路径为：<code>Qt/Tools/OpenSSL</code>。根据需要将对应系统版本的 bin 路径加入 PATH 如：<code>C:\Qt\Tools\OpenSSL\Win_x86\bin</code>，里面包含相关 lib 库文件。添加方法参考：<a href="https://blog.niekun.net/archives/413.html">https://blog.niekun.net/archives/413.html</a>。</p><!--more--><p>需要用到的 QT class：<br><a href="https://doc.qt.io/qt-5/qnetworkaccessmanager.html">QNetworkAccessManager</a><br><a href="https://doc.qt.io/qt-5/qnetworkrequest.html">QNetworkRequest</a><br><a href="https://doc.qt.io/qt-5/qsslconfiguration.html">QSslConfiguration</a><br><a href="https://doc.qt.io/qt-5/qnetworkreply.html">QNetworkReply</a></p><p>我们做一个示例，新建项目，在头文件添加相关引用：</p><pre><code>#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;</code></pre><p>public 栏添加触发网络访问的 function：</p><pre><code>public:
    void doRequest();</code></pre><p>private 栏定义指针：</p><pre><code>private:
    QNetworkAccessManager *manager;</code></pre><p>添加 private slots 用来处理服务器的回应：</p><pre><code>private slots:
    void replyFinished(QNetworkReply *reply);</code></pre><p>传入参数 reply 用来接收网络访问响应内容，对应于 signal: <code>void QNetworkAccessManager::finished(QNetworkReply *reply)</code>，signal 触发后的数据通过 connect 会自动传入 slot 中，下面在源文件中做详细定义。</p><p>下面修改源文件，先在构造器中调用触发网络 function: <code>doRequest()</code>：</p><pre><code>MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    doRequest();
}</code></pre><p>下面实现 <code>doRequest()</code> 的内容：</p><pre><code>void MainWindow::doRequest() {
    manager = new QNetworkAccessManager(this);

    QSslConfiguration sSlConfig;
    sSlConfig.setDefaultConfiguration(QSslConfiguration::defaultConfiguration());
    sSlConfig.setProtocol(QSsl::TlsV1_2);

    QNetworkRequest request;
    request.setSslConfiguration(sSlConfig);
    request.setUrl(QUrl(&quot;https://info.niekun.net&quot;));
    request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);

    manager-&gt;get(request);

    connect(manager, &amp;QNetworkAccessManager::finished, this, &amp;MainWindow::replyFinished);
    connect(manager, &amp;QNetworkAccessManager::finished, manager, &amp;QNetworkAccessManager::deleteLater);
}</code></pre><p>首先实例化一个 QNetworkAccessManager 用来访问网络。</p><p>然后构造我们的 request 和 ssl 的初始化内容，request 中设置了访问的网络地址，定义了一个 request 的 header。</p><p>QNetworkAccessManager  的 object 使用 <code>get</code> function 来启动网络请求。</p><p>然后我们使用 <code>connect</code> 根据网络请求发出后的响应来触发相关 slot function。signal 触发后的数据会传入 slot function 中。所以 signal：<code>void QNetworkAccessManager::finished(QNetworkReply *reply)</code> 触发后返回的数据 reply 自动作为传入数据给 <code>replyFinished</code>。</p><p>第二个 connect 的作用是网络请求结束后释放相关内存，避免造成内存溢出。</p><p>注意这里我使用了新版的 QT connect 语法，详细参考官方文档：<a href="https://wiki.qt.io/New_Signal_Slot_Syntax">https://wiki.qt.io/New_Signal_Slot_Syntax</a></p><p>下面实现 replyFinished：</p><pre><code>void MainWindow::replyFinished(QNetworkReply *reply) {
    if(reply-&gt;error())
    {
        qDebug() &lt;&lt; &quot;ERROR!&quot;;
        qDebug() &lt;&lt; reply-&gt;errorString();
    }
    else
    {
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentTypeHeader).toString();
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::LastModifiedHeader).toDateTime().toString();;
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentLengthHeader).toULongLong();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
        qDebug() &lt;&lt; &quot;-----------------------&quot;;
        qDebug().noquote() &lt;&lt; reply-&gt;readAll();
    }
}</code></pre><p>reply 指向 <code>&amp;QNetworkAccessManager::finished</code> 的 QNetworkReply 数据。</p><p>在此 function 中，我们输出 reply 中的部分信息来检测网络是否通畅。其他的可用类型可以查询：<a href="https://doc.qt.io/qt-5/qnetworkrequest.html#public-types">https://doc.qt.io/qt-5/qnetworkrequest.html#public-types</a></p><p>注意使用 <code>qDebug().noquote()</code> 来自动将字符串中的 <code>\n</code> 作为换行处理。</p><p>正常输出信息如下：</p><pre><code>&quot;text/plain&quot;
&quot;&quot;
0
200
&quot;OK&quot;
-----------------------
request info:
request: GET / HTTP/1.1
scheme: https
host: info.niekun.net
http_host: info.niekun.net
uri: /
request_uri: /
connection: 202130
remote_addr: 172.68.189.53
client_real_ip: 1.81.217.183
server_port: 443

other variates:
http_x_forwarded_for: 1.81.217.183
proxy_add_x_forwarded_for: 1.81.217.183, 172.68.189.53</code></pre><p>以上就是 QT 访问网络的简单教程。</p><p>参考链接：<br><a href="https://www.bogotobogo.com/Qt/Qt5_Downloading_Files_QNetworkAccessManager_QNetworkRequest.php">https://www.bogotobogo.com/Qt/Qt5_Downloading_Files_QNetworkAccessManager_QNetworkRequest.php</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1973.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1973.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[c++ 字符串数组指针的研究]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1968.html" />
<id>https://blog.niekun.net/archives/1968.html</id>
<updated>2020-12-08T21:37:00+08:00</updated>
<published>2020-12-08T21:37:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。一个简单的测试：    const char* test1 = &amp;quot;abc...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1968.html" xml:lang="zh-CN"><![CDATA[
<p>在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。</p><p><strong>一个简单的测试：</strong></p><pre><code>    const char* test1 = &quot;abc&quot;;
    const string test2 = &quot;abc&quot;;

    cout &lt;&lt; test1 &lt;&lt; endl;
    cout &lt;&lt; *test1 &lt;&lt; endl;
    cout &lt;&lt; test2 &lt;&lt; endl;
    cout &lt;&lt; sizeof (test1) &lt;&lt; endl;
    cout &lt;&lt; sizeof (test2) &lt;&lt; endl;</code></pre><p>输出如下：</p><pre><code>abc
a
abc
8
24</code></pre><!--more--><p>以前我的教程里提到过，字符串就相当于一个字符数组。指针会指向它的首个字符地址。<code>test1</code> 指针理论上存储着字符串的首地址。</p><p>但我们可以看到直接输出 <code>test1</code> 会得到实际字符串内容，而不是首个字符地址。输出 <code>*test</code> 会得到正常的首字符内容。</p><p>字符串指针使用 sizeof 得到这个指针所占用内存大小，而不是字符串内容的大小。</p><p>同时我们可以发现，一个字符指针可以直接指向一个字符串，而不需要先定义一个字符串变量然后建立指针指向这个变量。这是因为一个<strong>字符串可以看做一个字符数组，同时它也是一个整体</strong>，字符指针可以直接定义指向它。</p><p><strong>下面测试 int 型数组：</strong></p><pre><code>    const int test3[] = {1, 3 ,5};
    const int* test4 = test3;

    cout &lt;&lt; test3 &lt;&lt; endl;
    cout &lt;&lt; test4 &lt;&lt; endl;
    cout &lt;&lt; test4[0] &lt;&lt; endl;
    cout &lt;&lt; *test4 &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4) &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4[0]) &lt;&lt; endl;</code></pre><p>输出结果：</p><pre><code>0x7ffee8cbaa58
0x7ffee8cbaa58
1
1
8
4</code></pre><p>可以看到直接输出数组名称或指针名称得到的是数组所在地址。<code>*test</code> 和 <code>test[0]</code> 会得到数组第一位内容。</p><p>test4 是一个指针，所以 sizeof 得到的是这个指针做占用的内存空间而不是数组本身占用空间。无法通过 sizeof 计算出数组个数。</p><p>以上实验，我们先建立了一个 int 型数组变量，然后建立 int 型指针指向这个变量，如果直接在一行中建立一个指针指向一个数组会报错，这就和上面测试的字符指针不一样了。因为其他类型的数组不同于字符串，它的每个元素是独立的个体，所以无法使用一个指针直接指向他们全部。</p><p><strong>下面做最后一个测试：</strong></p><pre><code>const char* test5[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

const string test6[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

int x = sizeof (test5)/sizeof(test5[0]);
cout &lt;&lt; test5 &lt;&lt; endl;
cout &lt;&lt; *test5 &lt;&lt; endl;
cout &lt;&lt; test5[0] &lt;&lt; endl;
cout &lt;&lt; *test5[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test5) &lt;&lt; endl;
cout &lt;&lt; sizeof(test5[0]) &lt;&lt; endl;

cout &lt;&lt; &quot;*************\n&quot;;

x = sizeof (test6)/sizeof(test6[0]);
cout &lt;&lt; test6 &lt;&lt; endl;
cout &lt;&lt; *test6 &lt;&lt; endl;
cout &lt;&lt; test6[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test6) &lt;&lt; endl;
cout &lt;&lt; sizeof(test6[0]) &lt;&lt; endl;</code></pre><p>输出结果如下：</p><pre><code>0x7ffee596ea40
abc
abc
a
4
32
8
*************
0x7ffee596e9e0
abc
abc
4
96
24</code></pre><p><strong>由于字符串本身就是一个字符数组，所以一个字符串数组相当于一个二维的数组。定义字符串数组的指针，就是数组中每个字符串对应的指针的集合。</strong>所以这个数组指针本身不是字符串类型的，而它的每个指针元素都是字符串指针类型的。</p><p>可以看到类似于第一组测试，非字符串的指针直接输出指针名称，所以 <code>test5</code> 得到字符串数组的地址。</p><p><code>*test5</code> 和 <code>test5[0]</code> 都表示指针数组第一个元素，也就是字符串类型的指针，根据第一组实验可以知道使用字符串指针名称输出本身字符串而不是地址，所以输出此指针可以直接得到字符串内容。</p><p><code>*test5[0]</code> 就是字符串指针的首字符地址内容，也就是得到第一个字符串第一个字符的内容。</p><p>test5 指针数组使用 sizeof 得到的是这个指针数组总共占用的内存大小，也就是每个指针大小的总和。除以单个指针大小就可以得到这个数组指针的个数，也就是对应指向的数组的元素个数。</p><p>test6 字符串数组使用 sizeof 得到的是这个字符串数组所有元素的占用内存大小，除以单个字符串大小就可以得到这个数组的元素个数。</p><p>我们可以看到 test5 和 test6 使用 sizeof 都可以得到数组的元素个数，但他们的原理是完全不同的，一个是使用指针的内存大小，一个是使用数组本身的内存大小。</p><p><strong>总结：</strong><br>字符串的指针名称可以直接输出字符串内容而不是地址。其他指针类型指向的数据，如字符，数字，字符串数组，number 型数组等，指针名输出的都是数据地址。</p><p>指针使用 sizeof 得到的是指针所占用的内存大小。可以使用 <code>sizeof(*Pointer)</code> 得到数据本身大小。</p><p>字符串数组的指针使用 sizeof 得到指针数组的总大小，可以用来间接计算数组元素个数。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1968.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1968.html" thr:count="0"/>
</entry>
</feed>