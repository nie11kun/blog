<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/"
>
<title type="text">Marco Nie</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2020-09-18T16:20:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/" />
<id>https://blog.niekun.net/feed/atom/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/" />
<entry>
<title type="html"><![CDATA[awk 命令的用法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1757.html" />
<id>https://blog.niekun.net/archives/1757.html</id>
<updated>2020-09-18T16:20:00+08:00</updated>
<published>2020-09-18T16:20:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[awk 是常用的 Linux 文本操作命令和脚本语言。用来按行提取和处理文本内容，也可以执行简单的逻辑处理。比如我们有一个 txt 文件：ab.c 123 e.rt 456oh.g 324 b....]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1757.html" xml:lang="zh-CN"><![CDATA[
<p>awk 是常用的 Linux 文本操作命令和脚本语言。用来按行提取和处理文本内容，也可以执行简单的逻辑处理。</p><p>比如我们有一个 txt 文件：</p><pre><code>ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452</code></pre><!--more--><p>执行命令：</p><pre><code>$ awk '{print $1}' test.txt
ab.c
oh.g
si.d</code></pre><p>可以看到返回结果为每一行的第一个字符串。默认以<strong>空格</strong>作为分隔符。</p><p><code>$1</code> 为每行第一个字符串，<code>$2</code> 为每行第二个字符串，以此类推。<code>$0</code> 为整个文本。</p><p>可以同时输出多个内容：</p><pre><code>$ awk '{print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156</code></pre><h3>内部集成的参数</h3><h4>FS 区域分割符</h4><p>awk 默认使用空格来分割字符串，也可以自己定义分割符：</p><pre><code>$ awk 'FS = &quot;.&quot; {print $1, $2}' test.txt
ab c 123 e
oh g 324 b
si d 156 o</code></pre><p>这时候，<code>ab</code> 和 <code>c 123 e</code> 分别是一个整体。</p><p>还有一种写法使用 <code>-F</code> 表示，要写在引号外部：</p><pre><code>$ awk -F. '{print $1, $2}' test.txt
</code></pre><h4>NF 每行字符串个数</h4><p>用 <code>$NF</code> 来表示每行最后一个串：</p><pre><code>$ awk '{print $NF}' test.txt
456
756
452</code></pre><p>用 NF 来判断每行字符串格个数：只输出有 4 个字符串的所在行的内容</p><pre><code>$ awk 'NF == 4 {print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156</code></pre><h4>NR 当前行号</h4><p><code>NR</code> 记录当前行的行号：</p><pre><code>$ awk '{print NR}' test.txt
1
2
3</code></pre><pre><code>$ awk '{print NR, $0}' test.txt
1 ab.c 123 e.rt 456
2 oh.g 324 b.na 756
3 si.d 156 o.ui 452</code></pre><h3>OFS 定义输出串分割符</h3><p>字符串输出是可以自定义分割符号：</p><pre><code>$ awk 'OFS=&quot;/&quot; {print $1, $2}' test.txt
ab.c/123
oh.g/324
si.d/156</code></pre><h4>BEGIN 和 END 规则</h4><p>BEGIN 规则是在 awk 读取输入文本前执行的指令，END 规则是在 awk 输出完字符串后执行的指令。</p><pre><code>$ awk 'BEGIN {print &quot;begin process&quot;} {print $0} END {print &quot;end process&quot;}' test.txt
begin process
ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452
end process</code></pre><h4>判断模块</h4><p>可以使用常用的判断来过滤输出结果：</p><p>设置第4个字符串数字需要大于等于500：</p><pre><code>$ awk '$4 &gt;=500 {print $0}' test.txt
oh.g 324 b.na 756</code></pre><p>设置行内必须包含字符串 <code>ab</code>:</p><pre><code>$ awk '/ab/ {print $0}' test.txt
ab.c 123 e.rt 456</code></pre><p>设置行开始必须包含字符串 <code>ab</code>:</p><pre><code>$ awk '/^ab/ {print $0}' test.txt
ab.c 123 e.rt 456</code></pre><h3>awk script 脚本</h3><p>如果命令很复杂，可以建立一个脚本来单独执行。</p><p>建立文件：<code>test.awk</code></p><pre><code>#!/usr/bin/awk -f

BEGIN {
  # set the input and output field separators
  FS=&quot;:&quot;
  OFS=&quot;:&quot;
  # zero the accounts counter
  accounts=0
}
{
  # set field 2 to nothing
  $2=&quot;&quot;
  # print the entire line
  print $0
  # count another account
  accounts++
}
END {
  # print the results
  print accounts &quot; accounts.\n&quot;
}</code></pre><p>可执行权限：</p><pre><code>chmod +x test.awk
</code></pre><p>执行：</p><pre><code>./test.awk /etc/passwd
</code></pre><h3>参考链接</h3><p><a href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/">https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/</a><br><a href="http://linuxcommand.org/lc3_adv_awk.php">http://linuxcommand.org/lc3_adv_awk.php</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1757.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1757.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[${1%str} 在 shell 脚本的用法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1754.html" />
<id>https://blog.niekun.net/archives/1754.html</id>
<updated>2020-09-18T15:25:00+08:00</updated>
<published>2020-09-18T15:25:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[执行 shell 脚本时经常会有传入参数，如：./test.sh abcdef abc.bbb以上的命令使用了两个传入参数，abcdef,abc.bbb。在脚本里使用时，$1 就表示第一个参数，...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1754.html" xml:lang="zh-CN"><![CDATA[
<p>执行 shell 脚本时经常会有传入参数，如：</p><pre><code>./test.sh abcdef abc.bbb
</code></pre><p>以上的命令使用了两个传入参数，<code>abcdef</code>,<code>abc.bbb</code>。</p><p>在脚本里使用时，<code>$1</code> 就表示第一个参数，<code>$2</code> 就表示第二个参数:</p><pre><code>var1 = $1
var2 = $2</code></pre><p>在脚本中有一种用法，如：<code>${1%def}jjj</code>。<br>他的意思就是将 <code>$1</code> 最后的字符 <code>def</code> 替换为 <code>jjj</code>：</p><pre><code>newstr1 = ${1%def}jjj</code></pre><p><code>newstr1</code> 的值就是 <code>abcjjj</code>。</p><pre><code>newstr2 = ${2%.bbb}.ccc</code></pre><p><code>newstr2</code> 的值就是 <code>abc.ccc</code>。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1754.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1754.html" thr:count="1"/>
</entry>
<entry>
<title type="html"><![CDATA[使用 subprocess.check_output 执行cmd命令并返回结果到字符串]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1753.html" />
<id>https://blog.niekun.net/archives/1753.html</id>
<updated>2020-09-18T15:13:51+08:00</updated>
<published>2020-09-18T15:13:51+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[语法：subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=Fals...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1753.html" xml:lang="zh-CN"><![CDATA[
<p>语法：</p><pre><code>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)
</code></pre><p>执行cmd命令并返回结果到字符串。</p><p>用法：</p><pre><code>import subprocess

output = check_output([&quot;cat&quot;, &quot;/etc/hostname&quot;]).strip()
print(output)</code></pre><p>以上脚本会执行 <code>cat /etc/hostname</code> 命令然后将结果赋值给 <code>output</code> 变量。<br><code>strip()</code> 可以将 string 的前后空格去掉。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1753.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1753.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[FFmpeg 简单用法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1752.html" />
<id>https://blog.niekun.net/archives/1752.html</id>
<updated>2020-09-18T15:03:12+08:00</updated>
<published>2020-09-18T15:03:12+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。官方网站：htt...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1752.html" xml:lang="zh-CN"><![CDATA[
<p>FFmpeg 是视频处理最常用的开源软件。</p><p>它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p><p>官方网站：<a href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></p><!--more--><h3>安装</h3><p>最简单的方法就是用包管理工具如：apt 安装：</p><pre><code>apt update
apt install ffmpeg
</code></pre><p>或者也可以从源码安装，可以参考我之前的教程：<a href="https://blog.niekun.net/archives/891.html">https://blog.niekun.net/archives/891.html</a></p><h3>常用指令</h3><p>查看 ffmpeg 版本：</p><pre><code>ffmpeg -version
</code></pre><p>查看支持的编码格式：如 h.264, h.265</p><pre><code>ffmpeg -codecs
</code></pre><p>查看支持的容器：如 mp4, mp3, mkv</p><pre><code>ffmpeg -formats
</code></pre><p>查看已安装的编码器：如 libx264, libx265, libvpx, aac</p><pre><code>ffmpeg -encoders
</code></pre><h3>使用格式</h3><p>FFmpeg 的命令行参数非常多，可以分成五个部分。</p><pre><code>ffmpeg {1} {2} -i {3} {4} {5}
</code></pre><p>上面命令中，五个部分的参数依次如下：</p><pre><code>全局参数
输入文件参数
输入文件
输出文件参数
输出文件</code></pre><p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:</p><pre><code>$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]</code></pre><p>下面是一个例子:</p><pre><code>ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件</code></pre><p>上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。</p><p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。<strong>一般可以省略输入文件参数。</strong></p><h3>常用命令参数</h3><pre><code>-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。</code></pre><h3>常规使用方法</h3><p>查看元数据信息，如时长，比特率等：</p><pre><code>ffmpeg -i test.mp4
</code></pre><p>输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：</p><pre><code>ffmpeg -i test.mp4 -hide_banner
</code></pre><p>转码，如 avi to h.264:</p><pre><code>ffmpeg -i test.avi -c:v libx264 test.mp4
</code></pre><p>转换容器：</p><pre><code>ffmpeg -i test.mp4 -c copy test.webm</code></pre><p>转换容器不需要转码，所以直接 copy 即可。</p><p>转换码率，转换成固定码率：</p><pre><code>ffmpeg -i test.mp4 -b:v 500k test_out.mp4
</code></pre><p>转换码率，转换成一个码率范围：</p><pre><code>ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
</code></pre><p>改变分辨率：转换成 480p</p><pre><code>ffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4</code></pre><p>视频中提取音频：</p><pre><code>ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac</code></pre><p>上面例子中，<code>-vn</code> 表示去掉视频，<code>-c:a copy</code> 表示不改变音频编码，直接拷贝。</p><p>视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图</p><pre><code>ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg</code></pre><p><code>%3d</code> 在 shell 里表示至少输出3个字符空间的数字：</p><pre><code>% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;</code></pre><p>如果只需要截一张图，可以指定只截取一帧。</p><pre><code>$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg</code></pre><p>上面例子中，<code>-vframes 1</code> 指定只截取一帧，<code>-q:v 2</code> 表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p><p><strong>裁剪:</strong><br>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。</p><pre><code>$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</code></pre><p>下面是实际的例子。</p><pre><code># 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4</code></pre><p>上面例子中，<code>-c copy</code> 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。</p><h3>高级用法</h3><h4>压缩视频内容到指定容量大小</h4><p>使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。</p><p>bash脚本：</p><pre><code>#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;</code></pre><p><strong>使用方法：</strong>压缩视频到 50 MB 大小</p><pre><code>./script.sh test.mp4 50
</code></pre><h4>切割视频到指定时长的多个视频</h4><p>使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。<br>python 脚本：</p><pre><code>#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()</code></pre><p><strong>使用方法：</strong>将视频切割为单个视频100秒</p><pre><code>./split.py -f test.mp4 -s 100
</code></pre><h3>ffprobe 使用</h3><p>ffprobe 可以用来得到视频信息。</p><p>视频时长：秒</p><pre><code>ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><p>视频码率：bit</p><pre><code>ffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><h3>参考链接</h3><p><a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html</a><br><a href="https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size">https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size</a><br><a href="https://github.com/c0decracker/video-splitter">https://github.com/c0decracker/video-splitter</a><br><a href="https://trac.ffmpeg.org/wiki/FFprobeTips">https://trac.ffmpeg.org/wiki/FFprobeTips</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1752.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1752.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 系统时间设置问题]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1747.html" />
<id>https://blog.niekun.net/archives/1747.html</id>
<updated>2020-09-17T10:47:00+08:00</updated>
<published>2020-09-17T10:47:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[昨天重装了 vps 系统，在设置 crontab 定时任务时发现并没有在指定的时间执行脚本。于是就进行排查问题。测试在 /etc/crontab 添加一条测试任务:30  10    *  * ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1747.html" xml:lang="zh-CN"><![CDATA[
<p>昨天重装了 vps 系统，在设置 crontab 定时任务时发现并没有在指定的时间执行脚本。于是就进行排查问题。</p><p>测试在 <code>/etc/crontab</code> 添加一条测试任务:</p><pre><code>30  10    *  *  * root python -V &gt; /root/test.log
</code></pre><p>在 10：30 并没有看到 test.log 文件生成。</p><!--more--><p>通过 <code>systemctl status cron</code> 查看信息：</p><pre><code>Sep 17 10:21:01 niekun-bandwagon CRON[946]: pam_unix(cron:session): session clos
Sep 17 10:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)</code></pre><p>在 10：29 crontab 脚本已经重新加载过了，但是并没有执行任务。</p><p>通过命令 <code>cat /var/log/syslog | grep cron</code> 查看系统日志：</p><pre><code>Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (pidfile fd = 3)
Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (Running @reboot jobs)
Sep 16 22:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)</code></pre><p>发现日志的时间比我当前时间晚了 12 个小时，会不会就是系统日期问题导致脚本没有达到设定的时间？</p><p>在按装新系统的后，使用 <code>date</code> 命令查看当前系统时间，发现时间是 UTC 时间，我通过 <code>tzselect</code> 命令设置了时区：</p><pre><code>[root@db-server ~]# tzselect 
Please identify a location so that time zone rules can be set correctly.
Please select a continent or ocean.
 1) Africa
 2) Americas
 3) Antarctica
 4) Arctic Ocean
 5) Asia
 6) Atlantic Ocean
 7) Australia
 8) Europe
 9) Indian Ocean
10) Pacific Ocean
11) none - I want to specify the time zone using the Posix TZ format.
#? 5
Please select a country.
 1) Afghanistan           18) Israel                35) Palestine
 2) Armenia               19) Japan                 36) Philippines
 3) Azerbaijan            20) Jordan                37) Qatar
 4) Bahrain               21) Kazakhstan            38) Russia
 5) Bangladesh            22) Korea (North)         39) Saudi Arabia
 6) Bhutan                23) Korea (South)         40) Singapore
 7) Brunei                24) Kuwait                41) Sri Lanka
 8) Cambodia              25) Kyrgyzstan            42) Syria
 9) China                 26) Laos                  43) Taiwan
10) Cyprus                27) Lebanon               44) Tajikistan
11) East Timor            28) Macau                 45) Thailand
12) Georgia               29) Malaysia              46) Turkmenistan
13) Hong Kong             30) Mongolia              47) United Arab Emirates
14) India                 31) Myanmar (Burma)       48) Uzbekistan
15) Indonesia             32) Nepal                 49) Vietnam
16) Iran                  33) Oman                  50) Yemen
17) Iraq                  34) Pakistan
#? 9
Please select one of the following time zone regions.
1) east China - Beijing, Guangdong, Shanghai, etc.
2) Heilongjiang (except Mohe), Jilin
3) central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.
4) most of Tibet &amp; Xinjiang
5) west Tibet &amp; Xinjiang
#? 1
 
The following information has been given:
 
        China
        east China - Beijing, Guangdong, Shanghai, etc.
 
Therefore TZ='Asia/Shanghai' will be used.
Local time is now:      Sun Jan 11 23:31:51 CST 2015.
Universal Time is now:  Sun Jan 11 15:31:51 UTC 2015.
Is the above information OK?
1) Yes
2) No
#? yes
Please enter 1 for Yes, or 2 for No.
#? 1
 
You can make this change permanent for yourself by appending the line
        TZ='Asia/Shanghai'; export TZ
to the file '.profile' in your home directory; then log out and log in again.
 
Here is that TZ value again, this time on standard output so that you
can use the /usr/bin/tzselect command in shell scripts:
Asia/Shanghai</code></pre><p>将 <code>TZ='Asia/Shanghai'; export TZ</code> 写入 <code>~/.profile</code>，并刷新文件：</p><pre><code>source .bash_profile</code></pre><p>测试当前系统时间：</p><pre><code>root@niekun-bandwagon:~# date
Thu Sep 17 10:44:00 CST 2020
</code></pre><p>但是系统日志记录的时间还是不对，这就可能还是时区不对，手动复制亚洲时区文件到目录：</p><pre><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre><p>更新 rsyslog 进程：</p><pre><code>systemctl restart rsyslog
</code></pre><p>再次测试发现系统日志时间对了，crontab 脚本也可以正确执行。</p><p>也可以使用 timedatectl 命令设置时区：</p><pre><code># 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone Asia/Shanghai</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1747.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1747.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[自由填充 Pattern in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1720.html" />
<id>https://blog.niekun.net/archives/1720.html</id>
<updated>2020-08-18T12:09:00+08:00</updated>
<published>2020-08-18T12:09:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1720.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/1117148355.jpg" alt="1.jpg" title="1.jpg"></p><p>对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。</p><!--more--><p>我们从如何定一个 pattern 开始，下面是一张 1 美元图片：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2275032220.jpg" alt="2.jpg" title="2.jpg"></p><p>使用 object selection tool 快速将主体选出来：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/547813215.jpg" alt="3.jpg" title="3.jpg"></p><p>选区边沿如果有多余的或者缺失的部分，通过 按住 shift 和 alt 键来增加/减去选区：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1909413931.jpg" alt="5.jpg" title="5.jpg"></p><p>点击添加图层蒙版，边沿如果需要调整，可以使用画笔工具来进一步修整蒙版。如果蒙版边沿有锯齿，可以双击蒙版打开属性框，调整 smooth 和 contract 来优化蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3707703993.jpg" alt="6.jpg" title="6.jpg"></p><p>使用选区工具框出一个矩形框包含我们的主体：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1689003146.jpg" alt="7.jpg" title="7.jpg"></p><p>选择 edit - define pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3798048595.jpg" alt="8.jpg" title="8.jpg"></p><p>定义一个名称，点击 ok：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2156770301.jpg" alt="9.jpg" title="9.jpg"></p><p>新建图层，快捷键 shift backspace/shift delete 调出填充框：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3400954114.jpg" alt="10.jpg" title="10.jpg"></p><p>content 选择 pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1708881397.jpg" alt="11.jpg" title="11.jpg"></p><p>custom pattern 里选中我们刚才新建的模型：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/234781752.jpg" alt="12.jpg" title="12.jpg"></p><p>script 前打勾，然后右侧菜单里选择 random fill：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2358508818.jpg" alt="13.jpg" title="13.jpg"></p><p>点击 ok 后进入调整菜单，首先将 下面的 color randomness 设为 0 避免图形的染色改变，brightness randomness 设置为 0.02 左右使亮度轻微可以随机改变，形成层次感：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1452674295.jpg" alt="14.jpg" title="14.jpg"></p><p>将 density 设置为最大 10，将 minimum/maximum scale factor 设置为 1，这样 pattern 会以 1:1 比例显示：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912797465.jpg" alt="15.jpg" title="15.jpg"></p><p>将 rotate pattern 打勾，这样模型会随机旋转：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1309014316.jpg" alt="16.jpg" title="16.jpg"></p><p>设置完成后点击 ok，可以看到效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/186378886.jpg" alt="17.jpg" title="17.jpg"></p><p><strong>还可以做一些优化来使层叠效果更加真实，过程就是降低 density 和 scale，添加图层阴影效果。</strong></p><p>新建图层，使用上面的方法填充 pattern，在设置中将 density 设置为 9，scale 设置为 0.25：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/651526338.jpg" alt="18.jpg" title="18.jpg"></p><p>确认后可以看到效果，单个图形变小，填充密度变小：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/223800845.jpg" alt="19.jpg" title="19.jpg"></p><p>我们给图层添加阴影效果，双击图层打开 layer style，下方点击添加阴影：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3623006525.jpg" alt="20.jpg" title="20.jpg"></p><p>再次新建图层，使用上面图层的填充设置填充 pattern，可以将空缺的部分进一步补充完整：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1465392084.jpg" alt="21.jpg" title="21.jpg"></p><p>按住 alt 键拖拽刚才的阴影特效到新图层，可以快速复制效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1601765537.jpg" alt="22.jpg" title="22.jpg"></p><p>可以看到还是有空白的区域没有填充完整，继续重复上面的步骤，建立多个图层，直到完全充满整个区域为止，最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3607587483.jpg" alt="23.jpg" title="23.jpg"></p><p>以上就是使用 script 来实现 pattern 自由填充的过程。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1720.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1720.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[argparse and struct in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1718.html" />
<id>https://blog.niekun.net/archives/1718.html</id>
<updated>2020-08-14T11:20:39+08:00</updated>
<published>2020-08-14T11:20:39+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[https://docs.python.org/3/library/argparse.htmlhttps://docs.python.org/3/library/struct.html]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1718.html" xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a><br><a href="https://docs.python.org/3/library/struct.html">https://docs.python.org/3/library/struct.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1718.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1718.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[眼睛进阶处理 in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1690.html" />
<id>https://blog.niekun.net/archives/1690.html</id>
<updated>2020-08-14T11:16:27+08:00</updated>
<published>2020-08-14T11:16:27+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1690.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/480024501.jpg" alt="26.jpg" title="26.jpg"><br>在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。</p><!--more--><p>下图是我们的原图：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1396099294.jpg" alt="1.jpg" title="1.jpg"></p><p>放大眼睛细节：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3561747204.jpg" alt="2.jpg" title="2.jpg"></p><p>原图已经很好了，很清晰。下面我们进行调整。</p><h3>强化亮部细节</h3><p>需要提亮的部分是光源点的对面，再此图中就是眼睛光斑的下方，新建图层，画笔工具画圆：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3017674335.jpg" alt="3.jpg" title="3.jpg"></p><p>擦除多余部分，笔刷选择软笔刷，可以先降低不透明度来看到背景：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3764677799.jpg" alt="4.jpg" title="4.jpg"></p><p>高斯模糊使过度自然：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3996858297.jpg" alt="5.jpg" title="5.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/501671708.jpg" alt="6.jpg" title="6.jpg"></p><p>混合模式改为 overlay 实现提亮：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/335821335.jpg" alt="7.jpg" title="7.jpg"></p><p>blend option 去掉影响阴影部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3804539933.jpg" alt="8.jpg" title="8.jpg"></p><p>如果想要加强效果可以再次复制图层，调整不透明度。</p><h3>增加高光点</h3><p>新建曲线图层，拉高曲线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1354307723.jpg" alt="9.jpg" title="9.jpg"></p><p>ctrl I 反转图层蒙版，白色画笔工具软笔刷在瞳孔下方点击一下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3285907289.jpg" alt="10.jpg" title="10.jpg"></p><p>可以看到效果太强了，调低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/295434221.jpg" alt="11.jpg" title="11.jpg"></p><h3>增加明暗细节</h3><p>新建曲线图层，提高曲线，反转图层蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/4087592833.jpg" alt="12.jpg" title="12.jpg"></p><p>白色画笔工具使用软笔刷沿着瞳孔在亮部区域画出射线，这一步注意如果有数位板来画的话会更好：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1796541048.jpg" alt="13.jpg" title="13.jpg"></p><p>降低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3436373763.jpg" alt="14.jpg" title="14.jpg"></p><p>下面增加暗部细节，再次新建曲线，然后降低曲线，反转蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/691635148.jpg" alt="15.jpg" title="15.jpg"></p><p>同样的方法画出射线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1700268067.jpg" alt="16.jpg" title="16.jpg"></p><p>降低不透明度：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3272285669.jpg" alt="17.jpg" title="17.jpg"></p><h3>眼白清理</h3><p>首先清理红血丝，新建图层，选择修复画笔工具混合模式设置为 screen，这样可以只处理暗部血丝：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912985796.jpg" alt="18.jpg" title="18.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/3994121998.jpg" alt="19.jpg" title="19.jpg"></p><p>按 alt 键采样眼白，涂抹血丝区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2541180553.jpg" alt="20.jpg" title="20.jpg"></p><p>然后进行 dogding and burning 明暗调节，首先建立 soild color 观察图层，混合模式改为 color 来只显示亮度情况：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2919767102.jpg" alt="21.jpg" title="21.jpg"></p><p>新建图层，混合模式改为 soft light，选择笔刷工具软笔刷流量改为 1，快捷键 D 恢复颜色为黑/白，根据实际用白色笔刷涂抹暗部，黑色笔刷涂抹过亮部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3803864790.jpg" alt="22.jpg" title="22.jpg"></p><p>然后修复亮度调整后的颜色变化，新建图层，混合模式改为 color，快捷键 I 拾取眼白正常部分的颜色，然后在新图层上涂抹出需要修复的区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/825482316.jpg" alt="23.jpg" title="23.jpg"></p><h3>复制效果</h3><p>将亮部细节处理/高光点/明暗细节处理部分建立分组然后复制一份，安住 ctrl 拖动分组到另一只眼睛部分，可以配合蒙版清理多余部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3182465625.jpg" alt="24.jpg" title="24.jpg"></p><p>可以使用同样的方法清理另一只眼睛的眼白部分最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2262252084.jpg" alt="25.jpg" title="25.jpg"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1690.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1690.html" thr:count="1"/>
</entry>
<entry>
<title type="html"><![CDATA[string &lt;-&gt; byte in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1688.html" />
<id>https://blog.niekun.net/archives/1688.html</id>
<updated>2020-08-12T14:08:00+08:00</updated>
<published>2020-08-12T14:08:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[To transform a unicode string to a byte string in Python do this:&amp;gt;&amp;gt;&amp;gt; 'foo'.encode('utf_8...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1688.html" xml:lang="zh-CN"><![CDATA[
<p>To transform a unicode string to a byte string in Python do this:</p><pre><code>&gt;&gt;&gt; 'foo'.encode('utf_8')
b'foo'
</code></pre><p>To transform a byte string to a unicode string:</p><pre><code>&gt;&gt;&gt; b'foo'.decode('utf_8')
'foo'

</code></pre><ol><li>To convert a string to bytes.</li></ol><pre><code>data = &quot;&quot;               #string
data = &quot;&quot;.encode()      #bytes
data = b&quot;&quot;              #bytes</code></pre><ol><li>To convert bytes to a String.</li></ol><pre><code>data = b&quot;&quot;              #bytes
data = b&quot;&quot;.decode()     #string
data = str(b&quot;&quot;)         #string</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1688.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1688.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[winreg 操作 Windows 注册表 in python]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1685.html" />
<id>https://blog.niekun.net/archives/1685.html</id>
<updated>2020-08-12T13:56:00+08:00</updated>
<published>2020-08-12T13:56:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[https://docs.python.org/3/library/winreg.html#https://stackoverflow.com/questions/15128225/python...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1685.html" xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/winreg.html#">https://docs.python.org/3/library/winreg.html#</a><br><a href="https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry">https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry</a></p><pre><code>import winreg

REG_PATH = r&quot;Control Panel\Mouse&quot;

def set_reg(name, value):
    try:
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, 
                                       winreg.KEY_WRITE)
        winreg.SetValueEx(registry_key, name, 0, winreg.REG_SZ, value)
        winreg.CloseKey(registry_key)
        return True
    except WindowsError:
        return False

def get_reg(name):
    try:
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0,
                                       winreg.KEY_READ)
        value, regtype = winreg.QueryValueEx(registry_key, name)
        winreg.CloseKey(registry_key)
        return value
    except WindowsError:
        return None

#Example MouseSensitivity
#Read value 
print (get_reg('MouseSensitivity'))

#Set Value 1/20 (will just write the value to reg, the changed mouse val requires a win re-log to apply*)
set_reg('MouseSensitivity', str(10))

#*For instant apply of SystemParameters like the mouse speed on-write, you can use win32gui/SPI
#http://docs.activestate.com/activepython/3.4/pywin32/win32gui__SystemParametersInfo_meth.html</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1685.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1685.html" thr:count="0"/>
</entry>
</feed>