<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/2019/02/"
>
<title type="text">Marco Nie - 2019年2月</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2019-02-26T08:21:00-05:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/2019/02/" />
<id>https://blog.niekun.net/feed/atom/2019/02/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/2019/02/" />
<entry>
<title type="html"><![CDATA[重定向 HTTP to HTTPS in Nginx]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/118.html" />
<id>https://blog.niekun.net/archives/118.html</id>
<updated>2019-02-26T08:21:00-05:00</updated>
<published>2019-02-26T08:21:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[将http请求重定向为https，使所有连接都使用安全的ssl。重定向所有http请求以下配置为将所有收到的80端口的请求都重定向到443端口,这会把此ip下的所有域名都转换：server { ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/118.html" xml:lang="zh-CN"><![CDATA[
<p>将http请求重定向为https，使所有连接都使用安全的ssl。</p><h2>重定向所有http请求</h2><p>以下配置为将所有收到的80端口的请求都重定向到443端口,这会把此ip下的所有域名都转换：</p><pre><code>server {
    listen           80;
    listen           [::]:80;
    server_name      _;
    return           301 https://$host$request_uri;
}</code></pre><p>listen 80 default_server 表示这是唯一监听80端口的server块<br>server_name _ 表示监听所有使用的域名</p><h2>重定向特定域名</h2><p>以下配置为重定向特定域名的请求，此方式适用于此ip下绑定多个域名的情况：</p><pre><code>server {
    listen           80;
    listen           [::]:80;
    server_name      your.domain;
    return           301 https://your.domain$request_uri;
}</code></pre><h2>443 server block</h2><p>设定我们的域名只接收443端口的访问：</p><pre><code>server {
    listen                443 ssl default_server;
    listen                [::]:443 ssl;
    server_name           foo.com;
}

server {
    listen                443 ssl;
    listen                [::]:443 ssl;
    server_name           bar.com;
}

...
</code></pre><p>只能设置一个域名为default_server。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/118.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/118.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[macOS使用brew安装的模块提示命令不存在的解决方法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/100.html" />
<id>https://blog.niekun.net/archives/100.html</id>
<updated>2019-02-21T07:51:00-05:00</updated>
<published>2019-02-21T07:51:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[此问题主要是没有把 /usr/local/sbin 加入path，使用下面指令可以将其加入path：export PATH=$PATH:/usr/local/sbin此指令只对当前终端窗口有效，...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/100.html" xml:lang="zh-CN"><![CDATA[
<p>此问题主要是没有把 <code>/usr/local/sbin</code> 加入path，使用下面指令可以将其加入path：</p><pre><code>export PATH=$PATH:/usr/local/sbin
</code></pre><p>此指令只对当前终端窗口有效，关闭后失效。可将命令加入 <code>~/.bash_profile</code> 文件使设置永久有效,此文件一般不存在，可新建：</p><pre><code>vim ~/.bash_profile
</code></pre><p>加入代码：</p><pre><code>export PATH=$PATH:/usr/local/sbin
</code></pre><p>关闭文件后，重新载入配置：</p><pre><code>source ~/.bash_profile
</code></pre><p>重新运行命令测试是否已经可用。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/100.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/100.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[macOS/Linux/windows设置终端 proxy 代理]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/97.html" />
<id>https://blog.niekun.net/archives/97.html</id>
<updated>2019-02-21T07:33:00-05:00</updated>
<published>2019-02-21T07:33:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[macOS/Linux通过设置代理来让终端流量走代理端口(socks5适用于大部分的流量，有些程序不走http)，在终端输入：export all_proxy=socks5://127.0.0....]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/97.html" xml:lang="zh-CN"><![CDATA[
<h3>macOS/Linux</h3><p>通过设置代理来让终端流量走代理端口(socks5适用于大部分的流量，有些程序不走http)，在终端输入：</p><pre><code>export all_proxy=socks5://127.0.0.1:1080
</code></pre><p>取消代理：</p><pre><code>unset all_proxy
</code></pre><p>也可以通过创建alias来设置一个“快捷命令”运行此命令：</p><pre><code>alias proxy='export all_proxy=socks5://127.0.0.1:1080'
alias unproxy='unset all_proxy'
</code></pre><p>然后开启代理就输入：</p><pre><code>proxy
</code></pre><p>取消代理输入：</p><pre><code>unproxy
</code></pre><p><strong>设置只对当前窗口有效，关闭后取消。</strong></p><!--more--><p>可以通过bash文件保存<em>alias</em>，快速设置/取消proxy。</p><p>打开 <code>~/.bash_profile</code>, <code>~/.bashrc</code>, 或者 <code>~/.profile</code>，The difference between these files is (primarily) when they get read by the shell. If you're not sure where to put it, ~/.bashrc is a good choice.</p><h4>macOS/Linux</h4><p>此文件一般不存在，可新建：</p><pre><code>vim ~/.bashrc
</code></pre><p>将下面代码加入文件：</p><pre><code>alias proxy='export all_proxy=socks5://127.0.0.1:1080 &amp;&amp; export http_proxy=http://127.0.0.1:1082 &amp;&amp; export https_proxy=http://127.0.0.1:1082'
alias unproxy='unset all_proxy &amp;&amp; export http_proxy= &amp;&amp; export https_proxy='</code></pre><p>保存文件后，重新载入配置：</p><pre><code>source ~/.bashrc
</code></pre><p>运行命令测试alias是否生效：</p><pre><code>proxy
</code></pre><p>对于 macOS，默认的 shell 是 zsh，它的默认加载文件是 <code>~/.zshrc</code>，所以修改上面的文件后每次启动 zsh 都需要手动运行 <code>source ~/.bashrc</code> 指令，解决方法打开 <code>~/.zshrc</code>，在文件内加入 <code>source ~/.bashrc</code> 即可，这样每次启动就可以正常使用设置的 alias 了。</p><h3>windows</h3><h4>CMD</h4><p><strong>cmd 中用 set http_proxy 设置</strong></p><pre><code>set http_proxy=http://127.0.0.1:1082
set https_proxy=http://127.0.0.1:1082
</code></pre><p>恢复</p><pre><code>set http_proxy=
set https_proxy=
</code></pre><p><strong> command prompt 使用 doskey 命令建立类似 alias 功能：</strong><br>新建 cmd_profile.bat 文件内容如下：</p><pre><code>@echo off
doskey phttp = set http_proxy=http://127.0.0.1:1082
doskey phttps = set https_proxy=http://127.0.0.1:1082
doskey unphttp = set http_proxy=
doskey unphttps = set https_proxy=</code></pre><p>打开注册表：win + r 输入 regedit，定位到 <code>HKEY_CURRENT_USER\Software\Microsoft\Command Processor\</code>,右键 new - string value，重命名为：Autorun，值设置为 bat 文件路径：<br><img src="https://niekun.net/usr/uploads/2019/10/3156600933.png" alt="2019-10-15T06:04:07.png" title="2019-10-15T06:04:07.png"></p><p>重新打开 cmd 输入 phttp phttps，查看当前IP：</p><pre><code>curl ipecho.net/plain ; echo
</code></pre><p><strong>注意，如果默认终端是 powershell 则无法通过上述方式在注册表加载 bat 脚本，建议将脚本路径设置到系统 path 中，然后启动 CMD 后输入脚本文件名运行一次即可。</strong></p><h4>power shell</h4><p>power shell 稍微麻烦一下，需要建立 PowerShell profile 文件设置 alias。</p><p>在启动 power shell 时会执行 profile 里的命令，类似与上面的 .bashrc 文件，关于建立 PowerShell profile 文件参考：<a href="https://docs.microsoft.com/en-us/previous-versions/system-center/service-manager-2010-sp1/ff461033(v=technet.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/system-center/service-manager-2010-sp1/ff461033(v=technet.10)?redirectedfrom=MSDN</a></p><p>开始建立 profile，首先以管理员权限运行 power shell，执行以下命令：</p><pre><code>Test-path $profile
</code></pre><p>如果返回值为 false 执行以下命令，返回值为 true 跳过此步骤：</p><pre><code>New-item –type file –force $profile
</code></pre><p>打开 profile 文件：</p><pre><code>Notepad $profile
</code></pre><p>加入以下内容：</p><pre><code># Set-Proxy command

Function SetProxy() {
    Param(
        $Addr = $null,
        [switch]$ApplyToSystem
    )
    
    $env:HTTP_PROXY = $Addr;
    $env:HTTPS_PROXY = $Addr; 
    $env:http_proxy = $Addr;
    $env:https_proxy = $Addr;
  
    if ($addr -eq $null) {
        [Net.WebRequest]::DefaultWebProxy = New-Object Net.WebProxy;
        if ($ApplyToSystem) { SetSystemProxy $null; }
        Write-Output &quot;Successful unset all proxy variable&quot;;
    }
    else {
        [Net.WebRequest]::DefaultWebProxy = New-Object Net.WebProxy $Addr;
        if ($ApplyToSystem) {
            $matchedResult = ValidHttpProxyFormat $Addr;
            # Matched result: [URL Without Protocol][Input String]
            if (-not ($matchedResult -eq $null)) {
                SetSystemProxy $matchedResult.1;
            }
        }
        Write-Output &quot;Successful set proxy as $Addr&quot;;
    }
}

Function SetSystemProxy($Addr = $null) {
    Write-Output $Addr
    $proxyReg = &quot;HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;;

    if ($Addr -eq $null) {
        Set-ItemProperty -Path $proxyReg -Name ProxyEnable -Value 0;
        return;
    }
    Set-ItemProperty -Path $proxyReg -Name ProxyServer -Value $Addr;
    Set-ItemProperty -Path $proxyReg -Name ProxyEnable -Value 1;
}

Function ValidHttpProxyFormat ($Addr) {
    $regex = &quot;(?:https?:\/\/)(\w+(?:.\w+)*(?::\d+)?)&quot;;
    $result = $Addr -match $regex;
    if ($result -eq $false) {
        throw [System.ArgumentException]&quot;The input $Addr is not a valid HTTP proxy URI.&quot;;
    }

    return $Matches;
}

Set-Alias -Name set-proxy -Value SetProxy</code></pre><p>上面的脚本主要就是建立了三个 function：设置代理 设置系统代理 检查 uri 是否正确，然后设置 alias。</p><p>关于 Set-Alias 语法参考：<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-7">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-7</a></p><p>保存文件后，继续输入下面命令：</p><pre><code>Set-ExecutionPolicy RemoteSigned
. $profile
</code></pre><p>以上就完成了 profile 的设置，使用语法如下:</p><pre><code># 设置当前窗口代理 ：
set-proxy http://your-proxy:port

#设置当前窗口代理 + 系统代理：
set-proxy http://your-proxy:port -ApplyToSystem

#取消当前窗口代理：
set-proxy (没有参数)

#取消当前窗口代理 + 系统代理：
set-proxy -ApplyToSystem</code></pre><p>测试代理然后查看当前IP：</p><pre><code>set-proxy http://127.0.0.1:1082
curl https://info.niekun.net/ip ; echo
</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/97.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/97.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[boost库里使用path的指针问题]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/95.html" />
<id>https://blog.niekun.net/archives/95.html</id>
<updated>2019-02-21T01:03:00-05:00</updated>
<published>2019-02-21T01:03:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[近期在开发过程中遇到一个奇怪的问题，当我复制一个文件夹到新目录时候总是失败，查看日志发现是传递地址出错了。我是使用的是Boost的filesystem C++库处理文件，下面是代码片段，将pat...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/95.html" xml:lang="zh-CN"><![CDATA[
<p>近期在开发过程中遇到一个奇怪的问题，当我复制一个文件夹到新目录时候总是失败，查看日志发现是传递地址出错了。<br>我是使用的是Boost的filesystem C++库处理文件，下面是代码片段，将path类型的地址放入一个指针，然后调用其他function：</p><pre><code>fs::path childDir = np;
childDir += &quot;/\\&quot; + dir_itr-&gt;path().filename().string();
const char* c_childDir = childDir.string().c_str();
</code></pre><p>我在本机实验是没有问题，但在他人电脑上提示directory error。<br>我将path里的地址先存放到一个string里然后在转换为char*，发现问题解决了。<br>我想可能的原因就是path不能直接使用其指针地址。下面是修改后的程序片段：</p><pre><code>string s_childDir = newDir;
s_childDir += &quot;/\\&quot; + dir_itr-&gt;path().filename().string();
const char* c_childDir = s_childDir.c_str();
</code></pre><p>以上就是关于boost库里使用path的指针问题的解决方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/95.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/95.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[V2ray install guide]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/80.html" />
<id>https://blog.niekun.net/archives/80.html</id>
<updated>2019-02-19T19:48:00-05:00</updated>
<published>2019-02-19T19:48:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[Project V 是一个工具集合，它可以帮助你打造专属的基础通信网络。Project V 的核心工具称为V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。V2Ray...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/80.html" xml:lang="zh-CN"><![CDATA[
<blockquote>Project V 是一个工具集合，它可以帮助你打造专属的基础通信网络。Project V 的核心工具称为V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。V2Ray 可以单独运行，也可以和其它工具配合，以提供简便的操作流程。</blockquote><p>GitHub：<a href="https://github.com/v2ray/v2ray-core">https://github.com/v2ray/v2ray-core</a><br>官网：<a href="https://www.v2ray.com">https://www.v2ray.com</a><br>客户端下载：<a href="https://github.com/v2ray/v2ray-core/releases">https://github.com/v2ray/v2ray-core/releases</a></p><!--more--><p><strong>V2Ray 在以下平台中可用：</strong></p><p>Windows 7 及之后版本（x86 / amd64）；<br>Mac OS X 10.10 Yosemite 及之后版本（amd64）；<br>Linux 2.6.23 及之后版本（x86 / amd64 / arm / arm64 / mips64 / mips）；<br>包括但不限于 Debian 7 / 8、Ubuntu 12.04 / 14.04 及后续版本、CentOS 6 / 7、Arch Linux；<br>FreeBSD (x86 / amd64)；<br>OpenBSD (x86 / amd64)；<br>Dragonfly BSD (amd64)；</p><p><strong>Linux 安装脚本</strong></p><p>V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。</p><p>运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon</p><pre><code>bash &lt;(curl -L -s https://install.direct/go.sh)
</code></pre><p>此脚本会自动安装以下文件：</p><ul><li><code>/usr/bin/v2ray/v2ray</code>：V2Ray 程序；</li><li><code>/usr/bin/v2ray/v2ctl</code>：V2Ray 工具；</li><li><code>/etc/v2ray/config.json</code>：配置文件；</li><li><code>/usr/bin/v2ray/geoip.dat</code>：IP 数据文件</li><li><code>/usr/bin/v2ray/geosite.dat</code>：域名数据文件</li></ul><p>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。</p><p>运行脚本位于系统的以下位置：</p><ul><li><code>/etc/systemd/system/v2ray.service</code>: Systemd</li><li><code>/etc/init.d/v2ray</code>: SysV</li></ul><p>脚本运行完成后，你需要：</p><p>编辑 <code>/etc/v2ray/config.json</code> 文件来配置你需要的代理方式；<br>运行 <code>service v2ray start</code> 来启动 V2Ray 进程；<br>之后可以使用 <code>service v2ray start|stop|status|reload|restart|force-reload</code> 控制 V2Ray 的运行。</p><p><strong>config.json格式</strong></p><pre><code>}
  &quot;log&quot;: {},
  &quot;api&quot;: {},
  &quot;dns&quot;: {},
  &quot;stats&quot;: {},
  &quot;routing&quot;: {},
  &quot;policy&quot;: {},
  &quot;reverse&quot;: {},
  &quot;inbounds&quot;: [],
  &quot;outbounds&quot;: [],
  &quot;transport&quot;: {}
}
</code></pre><p><strong>服务器config.json的配置</strong></p><pre><code>{
  &quot;log&quot; : {
    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,
    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,
    &quot;loglevel&quot;: &quot;warning&quot;
  },
  &quot;inbounds&quot;: [{
    &quot;port&quot;: port,
    &quot;listen&quot;:&quot;127.0.0.1&quot;,
    &quot;protocol&quot;: &quot;vmess&quot;,
    &quot;settings&quot;: {
      &quot;clients&quot;: [
        {
          &quot;id&quot;: &quot;UUID&quot;,
          &quot;level&quot;: 1,
          &quot;alterId&quot;: 64
        }
      ]
    },
    &quot;streamSettings&quot;: {
        &quot;network&quot;: &quot;ws&quot;,
        &quot;wsSettings&quot;: {
            &quot;connectionReuse&quot;: true,
            &quot;path&quot;: &quot;/proxy/path&quot;
        }
    }
  }],
  &quot;outbounds&quot;: [{
    &quot;protocol&quot;: &quot;freedom&quot;,
    &quot;settings&quot;: {}
  },{
    &quot;protocol&quot;: &quot;blackhole&quot;,
    &quot;settings&quot;: {},
    &quot;tag&quot;: &quot;blocked&quot;
  }],
  &quot;routing&quot;: {
    &quot;rules&quot;: [
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;ip&quot;: [&quot;geoip:private&quot;],
        &quot;outboundTag&quot;: &quot;blocked&quot;
      }
    ]
  }
}
</code></pre><p>port：v2ray监听端口，如果使用Nginx端口转发需要做对应设置<br>id：输入一个UUID，可在<a href="https://www.uuidgenerator.net/">UUID Generator</a>生成一个，服务端和客户端要一致<br>path：我用的是ws协议，此路径为虚拟网站路径，需要在Nginx里定义</p><p>修改好后运行：<code>service v2ray restart</code>启动服务</p><p><strong>Nginx.conf配置</strong></p><pre><code>    location /proxy/path {
        proxy_redirect             off;
        proxy_pass                 http://127.0.0.1:port;
        proxy_http_version         1.1;
        proxy_set_header           Upgrade $http_upgrade;
        proxy_set_header           Connection &quot;upgrade&quot;;
        proxy_set_header           Host $http_host;
    }
</code></pre><p>修改完成后运行：<code>service nginx reload</code>重新加载配置文件</p><p><strong>客户端config.json配置</strong></p><pre><code>{
  &quot;log&quot;: {
    &quot;loglevel&quot;: &quot;warning&quot;
  },
  &quot;inbounds&quot;: [{
    &quot;port&quot;: 1080,
    &quot;listen&quot;: &quot;127.0.0.1&quot;,
    &quot;tag&quot;: &quot;socks-inbound&quot;,
    &quot;protocol&quot;: &quot;socks&quot;,
    &quot;settings&quot;: {
      &quot;auth&quot;: &quot;noauth&quot;,
      &quot;udp&quot;: false,
      &quot;ip&quot;: &quot;127.0.0.1&quot;
    },
    &quot;sniffing&quot;: {
      &quot;enable&quot;: true,
      &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]
    },
    &quot;allocate&quot;: {
      &quot;strategy&quot;: &quot;always&quot;,
      &quot;refresh&quot;: 5,
      &quot;concurrency&quot;: 3
    }
  },{
    &quot;port&quot;: 1082,
    &quot;listen&quot;: &quot;127.0.0.1&quot;,
    &quot;tag&quot;: &quot;http-inbound&quot;,
    &quot;protocol&quot;: &quot;http&quot;,
    &quot;settings&quot;: {
      &quot;auth&quot;: &quot;noauth&quot;,
      &quot;udp&quot;: false,
      &quot;ip&quot;: &quot;127.0.0.1&quot;
    },
    &quot;sniffing&quot;: {
      &quot;enable&quot;: true,
      &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]
    },
    &quot;allocate&quot;: {
      &quot;strategy&quot;: &quot;always&quot;,
      &quot;refresh&quot;: 5,
      &quot;concurrency&quot;: 3
    }
  }],
  &quot;outbounds&quot;: [{
    &quot;protocol&quot;: &quot;vmess&quot;,
    &quot;settings&quot;: {
      &quot;vnext&quot;: [
        {
          &quot;address&quot;: &quot;you.domain&quot;,
          &quot;port&quot;: 443,
          &quot;users&quot;: [
            {
              &quot;id&quot;: &quot;UUID&quot;,
              &quot;alterId&quot;: 64,
              &quot;security&quot;: &quot;auto&quot;,
              &quot;level&quot;: 1
            }
          ]
        }
      ]
    },
    &quot;tag&quot;: &quot;out-Proxy&quot;,
    &quot;streamSettings&quot;: {
      &quot;network&quot;: &quot;ws&quot;,
      &quot;security&quot;: &quot;tls&quot;,
      &quot;tlsSettings&quot;: {
        &quot;serverName&quot;: &quot;you.domain&quot;
      },
      &quot;wsSettings&quot;: {
        &quot;path&quot;: &quot;/proxypath&quot;
      }
    },
    &quot;mux&quot;: {
      &quot;enabled&quot;: true,
      &quot;concurrency&quot;: 8
    }
  },{
    &quot;protocol&quot;: &quot;blackhole&quot;,
    &quot;settings&quot;: {},
    &quot;tag&quot;: &quot;blocked&quot;
  },{
    &quot;protocol&quot;: &quot;freedom&quot;,
    &quot;settings&quot;: {},
    &quot;tag&quot;: &quot;direct&quot;
  }],
  &quot;routing&quot;: {
    &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;,
    &quot;rules&quot;:[
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;ip&quot;: [&quot;geoip:private&quot;],
        &quot;outboundTag&quot;: &quot;blocked&quot;
      },
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;domain&quot;: [&quot;geosite:category-ads&quot;],
        &quot;outboundTag&quot;: &quot;blocked&quot;
      },
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;domain&quot;: [
          &quot;360.com&quot;,
          &quot;360.cn&quot;,
          &quot;api.map.baidu.com&quot;,
          &quot;ps.map.baidu.com&quot;,
          &quot;sv.map.baidu.com&quot;,
          &quot;offnavi.map.baidu.com&quot;,
          &quot;newvector.map.baidu.com&quot;,
          &quot;ulog.imap.baidu.com&quot;,
          &quot;newloc.map.n.shifen.com&quot;,
          &quot;api.map.baidu.com&quot;,
          &quot;ps.map.baidu.com&quot;,
          &quot;sv.map.baidu.com&quot;,
          &quot;offnavi.map.baidu.com&quot;,
          &quot;newvector.map.baidu.com&quot;,
          &quot;ulog.imap.baidu.com&quot;,
          &quot;newloc.map.n.shifen.com&quot;
        ],
        &quot;ip&quot;: [
          &quot;14.63.198.45/32&quot;,
          &quot;23.42.186.24/32&quot;,
          &quot;23.66.147.48/32&quot;,
          &quot;59.110.16.35/32&quot;,
          &quot;101.227.12.0/23&quot;,
          &quot;101.227.14.0/24&quot;,
          &quot;101.227.119.0/24&quot;,
          &quot;101.227.200.0/24&quot;,
          &quot;106.11.11.86/32&quot;,
          &quot;107.20.211.189/32&quot;,
          &quot;108.61.200.51/32&quot;,
          &quot;111.63.135.0/24&quot;,
          &quot;111.206.13.60/30&quot;,
          &quot;111.206.13.64/28&quot;,
          &quot;111.206.13.80/32&quot;,
          &quot;111.206.13.250/31&quot;,
          &quot;111.206.22.0/24&quot;,
          &quot;113.207.57.24/32&quot;,
          &quot;115.29.247.48/32&quot;,
          &quot;116.206.22.7/32&quot;,
          &quot;117.34.51.0/24&quot;,
          &quot;119.188.13.0/24&quot;,
          &quot;120.26.151.246/32&quot;,
          &quot;120.55.199.139/32&quot;,
          &quot;120.76.189.132/32&quot;,
          &quot;120.77.11.172/32&quot;,
          &quot;120.132.63.203/32&quot;,
          &quot;121.42.144.95/32&quot;,
          &quot;121.43.75.169/32&quot;,
          &quot;121.201.11.95/32&quot;,
          &quot;121.201.108.2/32&quot;,
          &quot;121.251.255.0/24&quot;,
          &quot;122.72.50.17/32&quot;,
          &quot;122.226.223.163/32&quot;,
          &quot;123.57.94.184/32&quot;,
          &quot;123.125.111.0/24&quot;,
          &quot;123.125.117.0/24&quot;,
          &quot;123.125.118.0/24&quot;,
          &quot;123.206.1.246/32&quot;,
          &quot;124.116.241.0/24&quot;,
          &quot;140.205.36.26/32&quot;,
          &quot;180.76.155.58/32&quot;,
          &quot;180.76.163.245/32&quot;,
          &quot;180.76.171.28/32&quot;,
          &quot;180.76.190.68/32&quot;,
          &quot;182.48.119.159/32&quot;,
          &quot;183.131.79.130/32&quot;,
          &quot;211.137.132.89/32&quot;,
          &quot;221.179.183.0/24&quot;,
          &quot;221.179.191.0/24&quot;
        ],
        &quot;outboundTag&quot;: &quot;blocked&quot;
      },
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;domain&quot;: [
          &quot;apple.com&quot;,
          &quot;icloud.com&quot;,
          &quot;itunes.com&quot;,
          &quot;mzstatic.com&quot;,
          &quot;icloud-content.com&quot;,
          &quot;geosite:cn&quot;
        ],
        &quot;ip&quot;: [
          &quot;geoip:cn&quot;
        ],
        &quot;outboundTag&quot;: &quot;direct&quot;
      },
      {
        &quot;type&quot;: &quot;field&quot;,
        &quot;ip&quot;: [
          &quot;8.8.8.8&quot;
        ],
        &quot;outboundTag&quot;: &quot;out-Proxy&quot;
      },
      {
        &quot;type&quot;: &quot;chinasites&quot;,
        &quot;outboundTag&quot;: &quot;direct&quot;
      },
      {
        &quot;type&quot;: &quot;chinaip&quot;,
        &quot;outboundTag&quot;: &quot;direct&quot;
      }
    ]
  },
  &quot;dns&quot;: {
    &quot;hosts&quot;: {
      &quot;domain:360.com&quot;: &quot;127.0.0.1&quot;
    },
    &quot;servers&quot;: [
      &quot;1.1.1.1&quot;,
      {
        &quot;address&quot;: &quot;114.114.114.114&quot;,
        &quot;port&quot;: 53,
        &quot;domains&quot;: [
          &quot;geosite:cn&quot;
        ]
      },
      &quot;8.8.8.8&quot;,
      &quot;localhost&quot;
    ]
  },
  &quot;policy&quot;: {
    &quot;levels&quot;: {
      &quot;0&quot;: {
        &quot;uplinkOnly&quot;: 0,
        &quot;downlinkOnly&quot;: 0
      }
    },
    &quot;system&quot;: {
      &quot;statsInboundUplink&quot;: false,
      &quot;statsInboundDownlink&quot;: false
    }
  },
  &quot;other&quot;: {}
}
</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/80.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/80.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[HTML5视频嵌入test]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/64.html" />
<id>https://blog.niekun.net/archives/64.html</id>
<updated>2019-02-19T01:50:00-05:00</updated>
<published>2019-02-19T01:50:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[测试视频：         video is not supported       var x = document.getElementsByClassName(&quot;movie&quot;);    v...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/64.html" xml:lang="zh-CN"><![CDATA[
<p>测试视频：</p><iframe class="movie" width="100%" src="//player.bilibili.com/player.html?aid=44031474&cid=77121958&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<video controls class="movie" width="100%" >
    <source src="myuploads/PianistAtPublic.mp4" type="video/mp4">
    video is not supported
</video>

<script type="text/javascript">   
    var x = document.getElementsByClassName("movie");
    var i;
    for (i = 0; i < x.length; i++) {
        x[i].style.height=x[i].scrollWidth*9/16+"px";
    }
</script><p>官方文档：<a href="https://html.spec.whatwg.org/#the-video-element">https://html.spec.whatwg.org/#the-video-element</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/64.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/64.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用Cloudflare的CDN服务]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/54.html" />
<id>https://blog.niekun.net/archives/54.html</id>
<updated>2019-02-19T01:03:00-05:00</updated>
<published>2019-02-19T01:03:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[Cloudflare以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。通过基于反向代理的内容分发网络（Content Delivery Network,CDN）及分布式域名解析服务（...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/54.html" xml:lang="zh-CN"><![CDATA[
<blockquote>Cloudflare以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。通过基于反向代理的内容分发网络（Content Delivery Network,CDN）及分布式域名解析服务（Distributed Domain Name Server），Cloudflare可以帮助受保护站点抵御包括拒绝服务攻击在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、加载速度以改善访客体验。</blockquote><p>官网：<a href="https://cloudflare.com">https://cloudflare.com</a><br>官方手册：<a href="https://support.cloudflare.com/hc/en-us/categories/200275218">https://support.cloudflare.com/hc/en-us/categories/200275218</a></p><!--more--><hr><p>首先在官网注册账号，完成后点击右上角 + Add site，添加你的域名</p><p>输入你的域名后点击 add site，cloudflare会检测你的域名和ip，可能需要等待一会儿。</p><p><img src="https://niekun.net/usr/uploads/2019/02/3955777234.png" alt="1.png" title="1.png"></p><p>扫描成功后点击 Next，出现选择套餐，选择 free plan 后点击 Confirm Plan。</p><p><img src="https://niekun.net/usr/uploads/2019/02/3561875926.png" alt="2.png" title="2.png"></p><p>会显示当前发现的 DNS records 列表，包含你的域名。在列表里，选择你需要开启cloudflare的子域名，点击右侧的云标识使能。一些records, 像是 MX, 不要让它通过 Cloudflare (no cloud).</p><p><img src="https://niekun.net/usr/uploads/2019/02/278986894.png" alt="3.png" title="3.png"></p><p>最后一步，会给你提供 Cloudflare nameservers。需要将这个NS填到你的域名提供商的设置里。设置完成后，如果更新完成，cloudflare里对应status会显示active。</p><p><img src="https://niekun.net/usr/uploads/2019/02/1567082378.png" alt="4.png" title="4.png"></p><p>以上就完成了cloudflare的启用，NS的刷新可能需要几个小时才完成。</p><p>接下来可以进入对应域名的 Crypto 栏设置 Universal SSL等相关优化参数。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/54.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/54.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Freenom申请免费域名并免费续期]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/38.html" />
<id>https://blog.niekun.net/archives/38.html</id>
<updated>2019-02-18T21:22:00-05:00</updated>
<published>2019-02-18T21:22:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[Freenom是世界上第一个也是唯一的免费域名提供商。 我们的使命是帮助各国人在网上发展自己的数字经济。 免费域名的工作机制与任何其他域名完全一致。 你可以用它作为您的网站，博客，电子邮件帐户或...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/38.html" xml:lang="zh-CN"><![CDATA[
<blockquote>Freenom是世界上第一个也是唯一的免费域名提供商。 我们的使命是帮助各国人在网上发展自己的数字经济。 免费域名的工作机制与任何其他域名完全一致。 你可以用它作为您的网站，博客，电子邮件帐户或其他！ 您可以选择运行免费域名与网址转发，免费Freenom DNS服务或您自己的DNS（域名服务器）。</blockquote><p>以上引用自freenom官网。</p><p>官网：<a href="https://www.freenom.com">https://www.freenom.com</a><br>可用免费域名：.TK / .ML / .GA / .CF / .GQ<br>注册和续费：1至12个月 免费更新(无限延期)</p><!--more--><h2>注册账户及免费域名购买</h2><p>进入官网，点击下方提示框注册 sign up<br>注册完成后，点击service - register a new domian</p><p><img src="https://niekun.net/usr/uploads/2019/02/72773715.png" alt="1.png" title="1.png"></p><p>开始搜索想要的域名，点击check availability，注意只需要输入前缀，不需要加域名后缀</p><p><img src="https://niekun.net/usr/uploads/2019/02/450344699.png" alt="2.png" title="2.png"></p><p>选择好想要的免费域名后，点击右侧的 get it now，然后在网页最上边右侧点击checkout</p><p>下一步在右侧period选择 12 months @ free，然后continue</p><p><img src="https://niekun.net/usr/uploads/2019/02/2819897032.png" alt="3.png" title="3.png"></p><p>Review & Checkout界面填写你的一些信息，点击complete order完成购买。</p><h2>域名解析</h2><p>service - mydomain 查看当前已有域名，申请时间及过期时间</p><p><img src="https://niekun.net/usr/uploads/2019/02/3322400795.png" alt="4.png" title="4.png"></p><p>选择刚申请的域名，点击右侧manage domain进入管理界面</p><p>使用freenomDNS默认的DNS服务器：<br>点击management tools - nameservers，选择Use default nameservers (Freenom Nameservers)，点击change nameservers</p><p><img src="https://niekun.net/usr/uploads/2019/02/3621112652.png" alt="5.png" title="5.png"></p><p>点击manage freenomDNS开始设置域名解析，添加两条A记录,target里填写你的服务器ip，点击save changes保存</p><p><img src="https://niekun.net/usr/uploads/2019/02/2038856321.png" alt="6.png" title="6.png"></p><p>域名解析一般需要一点时间，等待一会儿应该就可以访问你的域名了。</p><h2>免费续期</h2><p>由于免费域名最长为12个月，到期后会自动收回，所以需要在到期前手动续期一下。<br>免费续期时间为到期前14天内可申请，到期前freenom会发送邮件提醒。</p><p>进入service - renew domain，开始续期</p><p><img src="https://niekun.net/usr/uploads/2019/02/1364999776.png" alt="7.png" title="7.png"></p><p>这里会列出你的所有域名状态，及剩余到期时间，如果剩余时间在14天内，可点击右侧renew this domain进入续期界面。(我的域名剩余时间大于14天，所以还无法续期)</p><p><img src="https://niekun.net/usr/uploads/2019/02/4053540757.png" alt="8.png" title="8.png"></p><p>进入续期界面后右侧选择 12 months @ free，点击order now完成免费续期。</p><p><img src="https://niekun.net/usr/uploads/2019/02/2721123740.png" alt="9.png" title="9.png"></p><p>返回后可以看到剩余时间已经加上1年了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/38.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/38.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用acme.sh生成 ssl 证书并部署到 Nginx]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/34.html" />
<id>https://blog.niekun.net/archives/34.html</id>
<updated>2019-02-18T20:02:00-05:00</updated>
<published>2019-02-18T20:02:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书.官方说明：https://github.com/Neilpang/acme.sh安装acme.sh安装很...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/34.html" xml:lang="zh-CN"><![CDATA[
<p>acme.sh 实现了 <code>acme</code> 协议, 可以从 letsencrypt 生成免费的证书.</p><p>官方说明：<a href="https://github.com/Neilpang/acme.sh">https://github.com/Neilpang/acme.sh</a></p><h2>安装acme.sh</h2><p>安装很简单:</p><pre><code>apt-get install curl
curl  https://get.acme.sh | sh
</code></pre><p>安装过程进行了以下几步:</p><ul><li>把 acme.sh 安装到你的 root 目录下: <code>/root/.acme.sh/</code></li><li>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.</li><li>在 /root/.bashrc 创建 一个 bash 的 alias: <code>alias acme.sh=&quot;/root/.acme.sh/acme.sh&quot;</code></li></ul><p>cronjob 的任务可以使用命令 <code>crontab -e</code> 查看。</p><!--more--><p>新版的acme.sh是在 .bashrc 里引用了<code>. &quot;/root/.acme.sh/acme.sh.env&quot;</code>，此文件里定义了上面的alias。<br>如果安装完成后无法运行命令：<code>acme.sh</code>，试着运行：<code>source ~/.bashrc</code>重新加载alias，或者检查此文件内容。</p><h2>生成证书</h2><p>acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: <strong>http 和 dns 验证</strong>。dns 验证可以生成泛域名的证书，更加方便的适用于二级域名。</p><h4>http 方式</h4><p>需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.</p><pre><code>acme.sh  --issue  -d domain.you -d www.domain.you -d abc.domain.you --webroot  /your/www/root
</code></pre><p>只需要指定域名, 可以同时生成多个域名到一个证书，并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p><h4>dns 方式</h4><p>可以使用域名解析服务商的 api 来解析，我使用的是 cloudflare 作域名解析，进入 cf 的对应域名，在网站右下角有 account ID，记录下来，然后点击 get your api token：<br><img src="https://niekun.net/usr/uploads/2020/03/2057100712.png" alt="2020-03-06T01:22:00.png" title="2020-03-06T01:22:00.png"></p><p>点击 create token：<br><img src="https://niekun.net/usr/uploads/2020/03/3512310951.png" alt="2020-03-06T01:06:17.png" title="2020-03-06T01:06:17.png"></p><p>增加如下内容：<br><img src="https://niekun.net/usr/uploads/2020/03/104997018.png" alt="2020-03-06T01:12:34.png" title="2020-03-06T01:12:34.png"></p><p>点击确认后，会显示 token，记录下来：<br><img src="https://niekun.net/usr/uploads/2020/03/1869846058.png" alt="2020-03-06T01:15:22.png" title="2020-03-06T01:15:22.png"></p><p>在终端根据上面的 account ID 和 token 输入如下命令：</p><pre><code>export CF_Token=&quot;sdfsdfsdfljlbjkljlkjsdfoiwje&quot;
export CF_Account_ID=&quot;xxxxxxxxxxxxx&quot;
</code></pre><p>然后开始生成证书，可以指定顶级域名和泛域名：</p><pre><code>acme.sh --issue --dns dns_cf -d example.com -d *.example.com
</code></pre><p>CF_Tokenand CF_Account_ID will be saved in ~/.acme.sh/account.conf and will be reused when needed.</p><p>没有报错信息，代表生成成功，如果有报错，查看生成 api token 时候的权限设置有没有问题。</p><h2>安装证书</h2><p>默认生成的证书都放在安装目录下: <code>/root/.acme.sh/</code>, 请不要直接使用此目录下的文件, 例如: 不要直接让 <code>nginx/apache</code> 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p><p>正确的使用方法是使用 <code>--installcert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p><pre><code>acme.sh --install-cert -d domain.you \
--key-file       /etc/nginx/domain.you/key.pem  \
--fullchain-file /etc/nginx/domain.you/cert.pem \
--reloadcmd     &quot;service nginx force-reload&quot;</code></pre><p>以上命令安装证书后，会每 60 天自动更新证书，并自动运行 <code>service nginx force-reload</code>。我喜欢将证书放到 nginx/domain.you 目录下。</p><h2>配置Nginx.conf</h2><pre><code>server {
    listen                443 ssl;
    listen                [::]:443 ssl;
    server_name           domain.you;
    keepalive_timeout     70;

    ssl_protocols         TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers           AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;
    ssl_certificate       /etc/nginx/domain.you/cert.pem;
    ssl_certificate_key   /etc/nginx/domain.you/key.pem;
    ssl_session_cache     shared:SSL:10m;
    ssl_session_timeout   10m;
    ...
}
</code></pre><p>重启Nginx服务： <code>service nginx force-reload</code></p><p>这里用的是 <code>service nginx force-reload</code>, 不是 <code>service nginx reload</code>, 据测试, <code>reload</code> 并不会重新加载证书, 所以用的 <code>force-reload</code></p><h2>更新证书</h2><p>目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p><h2>更新acme.sh</h2><p>升级 acme.sh 到最新版 :</p><pre><code>acme.sh --upgrade
</code></pre><p>如果你不想手动升级, 可以开启自动升级:</p><pre><code>acme.sh  --upgrade  --auto-upgrade
</code></pre><p>之后, acme.sh 就会自动保持更新了.</p><p>你也可以随时关闭自动更新:</p><pre><code>acme.sh --upgrade  --auto-upgrade  0
</code></pre><p>以上就是使用acme.sh生成免费证书的简单过程，安装完成后使用https登录你的网站看能否正常访问，如果不能试着重启系统。</p><p>配置完成后可以到 ssl labs 测试：<a href="https://www.ssllabs.com/ssltest/index.html">https://www.ssllabs.com/ssltest/index.html</a><br>关于 Nginx 安全性更强的配置参考: <a href="https://niekun.net/archives/187.html">https://niekun.net/archives/187.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/34.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/34.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Nginx 安装/编译教程]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/30.html" />
<id>https://blog.niekun.net/archives/30.html</id>
<updated>2019-02-18T03:57:00-05:00</updated>
<published>2019-02-18T03:57:00-05:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[我的VPS上的Nginx记得还是一年前安装的，一直没有升级，最近发现版本都到了1.14了，我的还是1.4，就想做一次升级。由于使用Nginx用到一些配置文件，所以我预计升级会导致配置文件恢复到默...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/30.html" xml:lang="zh-CN"><![CDATA[
<p>我的VPS上的<code>Nginx</code>记得还是一年前安装的，一直没有升级，最近发现版本都到了1.14了，我的还是1.4，就想做一次升级。</p><p>由于使用<code>Nginx</code>用到一些配置文件，所以我预计升级会导致配置文件恢复到默认，所以查询了一些资料后，安全的做了升级。</p><!--more--><hr><p>备份nginx.conf配置文件：</p><pre><code>cp nginx.conf nginx.conf.bak
</code></pre><h2>从官方 ppa 源安装</h2><p>我将自定义server放在单独文件夹内 /etc/nginx/my-server/, 所以配置文件是安全的，升级后需要重新在 nginx.conf 里 include 一下即可。</p><p>安装依赖包:</p><pre><code>apt-get install curl gnupg2 ca-certificates lsb-release
</code></pre><p>设置安装稳定版:</p><pre><code>echo &quot;deb http://nginx.org/packages/ubuntu `lsb_release -cs` nginx&quot; \
    | sudo tee /etc/apt/sources.list.d/nginx.list</code></pre><p>导入 nginx 官方 key 使 apt 可以鉴定来源:</p><pre><code>curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add -
</code></pre><p>Verify that you now have the proper key:</p><pre><code>apt-key fingerprint ABF5BD827BD9BF62
</code></pre><p>The output should contain the full fingerprint 573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62 as follows:</p><pre><code>pub   rsa2048 2011-08-19 [SC] [expires: 2024-06-14]
      573B FD6B 3D8F BC64 1079  A6AB ABF5 BD82 7BD9 BF62
uid   [ unknown] nginx signing key &lt;signing-key@nginx.com&gt;</code></pre><p>安装Nginx，期间会提示有些文件要修改，根据提示覆盖<code>Y</code>或查看不同<code>D</code>，'N'保留原文件:</p><pre><code>apt-get update
apt-get install nginx
</code></pre><p>如果安装失败，提示 error 类似：/var/cache/apt/archives/nginx_1.14.1-1~trusty_amd64.deb，运行下面命令：</p><pre><code>apt-get -f install
apt-get remove nginx-common
apt-get install nginx
</code></pre><p>安装完成后，打开备份的nginx.conf.bak文件，将里面你之前做了自定义修改的字段复制回当前nginx.conf文件内，或者恢复单独的在文件夹的配置文件，并在 nginx.conf 里 include 一下。</p><p>检查配置文件是否正确：</p><pre><code>service nginx configtest
</code></pre><p>重启<code>Nginx</code>服务：</p><pre><code>service nginx reload
service nginx start
</code></pre><p>以上就完成了从官方源 Nginx 的安装/升级。</p><h2>从源码编译安装</h2><p>nginx源码编译适用于需要安装第三方的一些模块的情况，例如需要 fancyindex 等模块。</p><p>nginx 使用 GNU 编译系统，使用 configure 和 make 来工作，关于 GNU 编译系统的详细说明参考：<a href="https://blog.niekun.net/archives/883.html">https://blog.niekun.net/archives/883.html</a></p><p>首先检查是否安装了 <strong>g++</strong> 编译器，执行：</p><pre><code>gcc -v
</code></pre><p>如果返回错误，说明缺少 gcc 编译器：</p><pre><code>sudo apt install gcc g++ -y
</code></pre><p>从此处下载最新源码：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p>下载源码并解压：</p><pre><code>wget http://nginx.org/download/nginx-1.17.6.tar.gz
tar -zxvf nginx-1.17.6.tar.gz
</code></pre><p>下载第三方模块，如：fancyindex：</p><pre><code>git clone https://github.com/aperezdc/ngx-fancyindex.git ngx-fancyindex
</code></pre><p>运行配置脚本：</p><pre><code>cd nginx-1.17.6
./configure --add-module=../ngx-fancyindex [其他参数项]
</code></pre><p>如果要加入多个第三方模块，需要单独再用一个 --add-module=...</p><p>其他参数项:<br>如果不知道该加入那些附加编译参数，通过 nginx -V 可以查看当前官方预编译版本的配置变量。</p><p>nginx 官方编译版本默认的附加传递参数 extra desired options 如下：</p><pre><code>--prefix=/etc/nginx \
--sbin-path=/usr/sbin/nginx \
--modules-path=/usr/lib/nginx/modules \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/run/nginx.lock \
--http-client-body-temp-path=/var/cache/nginx/client_temp \
--http-proxy-temp-path=/var/cache/nginx/proxy_temp \
--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
--http-scgi-temp-path=/var/cache/nginx/scgi_temp \
--user=nginx \
--group=nginx \
--with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module \
--with-cc-opt='-g -O2 -fPIE -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'</code></pre><p>官方编译手册里面列出了所有可用的编译参数：<a href="http://nginx.org/en/docs/configure.html">http://nginx.org/en/docs/configure.html</a></p><p>执行后如果有报错，一般是设定参数里有需要的依赖环境未安装，如：openssl，PCRE Library 等。根据提示安装需要的库再次执行 configure。</p><p>编译和安装：</p><pre><code>make
make install
</code></pre><p>如果安装失败，提示 error，尝试运行下面命令，然后再次执行上面的 make install：</p><pre><code>apt-get -f install
apt-get remove nginx-common
</code></pre><p>安装完成后的设置和上面 ppa 安装类似。</p><p>如果运行 <code>service nginx start</code> 后，nginx 无法运行，查看 80 端口是否被占用，选择卸载或 kill 相关进程：</p><pre><code>lsof -i:80
</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/30.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/30.html" thr:count="0"/>
</entry>
</feed>