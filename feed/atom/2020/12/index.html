<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/2020/12/"
>
<title type="text">Marco Nie - 2020年12月</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2020-12-08T21:37:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/2020/12/" />
<id>https://blog.niekun.net/feed/atom/2020/12/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/2020/12/" />
<entry>
<title type="html"><![CDATA[c++ 字符串数组指针的研究]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1968.html" />
<id>https://blog.niekun.net/archives/1968.html</id>
<updated>2020-12-08T21:37:00+08:00</updated>
<published>2020-12-08T21:37:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。一个简单的测试：    const char* test1 = &amp;quot;abc...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1968.html" xml:lang="zh-CN"><![CDATA[
<p>在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。</p><p>一个简单的测试：</p><pre><code>    const char* test1 = &quot;abc&quot;;
    const string test2 = &quot;abc&quot;;

    cout &lt;&lt; test1 &lt;&lt; endl;
    cout &lt;&lt; *test1 &lt;&lt; endl;
    cout &lt;&lt; test2 &lt;&lt; endl;
    cout &lt;&lt; sizeof (test1) &lt;&lt; endl;
    cout &lt;&lt; sizeof (test2) &lt;&lt; endl;</code></pre><p>输出如下：</p><pre><code>abc
a
abc
8
24</code></pre><!--more--><p>以前我的教程里提到过，字符串就相当于一个字符数组。指针会指向它的首个字符地址。<code>test1</code> 指针理论上存储着字符串的首地址。</p><p>但我们可以看到直接输出 <code>test1</code> 会得到实际字符串内容，而不是首个字符地址。输出 <code>*test</code> 会得到正常的首字符内容。</p><p>字符串指针使用 sizeof 得到这个指针所占用内存大小，而不是字符串内容的大小。</p><p>下面测试 int 型数组：</p><pre><code>    const int test3[] = {1, 3 ,5};
    const int* test4 = test3;

    cout &lt;&lt; test3 &lt;&lt; endl;
    cout &lt;&lt; test4 &lt;&lt; endl;
    cout &lt;&lt; test4[0] &lt;&lt; endl;
    cout &lt;&lt; *test4 &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4) &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4[0]) &lt;&lt; endl;</code></pre><p>输出结果：</p><pre><code>0x7ffee8cbaa58
0x7ffee8cbaa58
1
1
8
4</code></pre><p>可以看到直接输出数组名称或指针名称得到的是数组所在地址。<code>*test</code> 和 <code>test[0]</code> 会得到数组第一位内容。</p><p>test4 是一个指针，所以 sizeof 得到的是这个指针做占用的内存空间而不是数组本身占用空间。无法通过 sizeof 计算出数组个数。</p><p>下面做最后一个测试：</p><pre><code>const char* test5[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

const string test6[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

int x = sizeof (test5)/sizeof(test5[0]);
cout &lt;&lt; sizeof(test5) &lt;&lt; endl;
cout &lt;&lt; sizeof(test5[0]) &lt;&lt; endl;
cout &lt;&lt; test5 &lt;&lt; endl;
cout &lt;&lt; *test5 &lt;&lt; endl;
cout &lt;&lt; test5[0] &lt;&lt; endl;
cout &lt;&lt; *test5[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;

cout &lt;&lt; &quot;*************\n&quot;;

x = sizeof (test6)/sizeof(test6[0]);
cout &lt;&lt; sizeof(test6) &lt;&lt; endl;
cout &lt;&lt; sizeof(test6[0]) &lt;&lt; endl;
cout &lt;&lt; test6 &lt;&lt; endl;
cout &lt;&lt; *test6 &lt;&lt; endl;
cout &lt;&lt; test6[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;</code></pre><p>输出结果如下：</p><pre><code>0x7ffee596ea40
abc
abc
a
4
32
8
*************
0x7ffee596e9e0
abc
abc
4
96
24</code></pre><p><strong>由于字符串本身就是一个字符数组，所以一个字符串数组相当于一个二维的数组。定义字符串数组的指针，就是数组中每个字符串对应的指针的集合。</strong>所以这个数组指针本身不是字符串类型的，而它的每个指针元素都是字符串指针类型的。</p><p>可以看到类似于第一组测试，非字符串的指针直接输出指针名称，所以 <code>test5</code> 得到字符串数组的地址。</p><p><code>*test5</code> 和 <code>test5[0]</code> 都表示指针数组第一个元素，也就是字符串类型的指针，根据第一组实验可以知道使用字符串指针名称输出本身字符串而不是地址，所以输出此指针可以直接得到字符串内容。</p><p><code>*test5[0]</code> 就是字符串指针的首字符地址内容，也就是得到第一个字符串第一个字符的内容。</p><p>test5 指针数组使用 sizeof 得到的是这个指针数组总共占用的内存大小，也就是每个指针大小的总和。除以单个指针大小就可以得到这个数组指针的个数，也就是对应指向的数组的元素个数。</p><p>test6 字符串数组使用 sizeof 得到的是这个字符串数组所有元素的占用内存大小，除以单个字符串大小就可以得到这个数组的元素个数。</p><p>我们可以看到 test5 和 test6 使用 sizeof 都可以得到数组的元素个数，但他们的原理是完全不同的，一个是使用指针的内存大小，一个是使用数组本身的内存大小。</p><p><strong>总结：</strong><br>字符串的指针名称可以直接输出字符串内容而不是地址。其他指针类型指向的数据，如字符，数字，字符串数组，number 型数组等，指针名输出的都是数据地址。</p><p>指针使用 sizeof 得到的是指针所占用的内存大小。可以使用 <code>sizeof(*Pointer)</code> 得到数据本身大小。</p><p>字符串数组的指针使用 sizeof 得到指针数组的总大小，可以用来间接计算数组元素个数。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1968.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1968.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[macOS 下使用 QT 部署工具 macdeployqt]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1966.html" />
<id>https://blog.niekun.net/archives/1966.html</id>
<updated>2020-12-05T23:53:15+08:00</updated>
<published>2020-12-05T23:53:15+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。工具路径在 QT ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1966.html" xml:lang="zh-CN"><![CDATA[
<p>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。</p><p>工具路径在 QT 安装目录的对应编译器 bin 目录下，如：<code>/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt</code></p><p>为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：</p><p>打开 <code>~/.zshrc</code> 添加如下内容，可以使用 vim 来操作：</p><pre><code>export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin</code></pre><p>编辑完成后关闭文件，刷新源：</p><pre><code>source ~/.zshrc
</code></pre><p>现在就可以直接使用命令了：</p><pre><code>macdeployqt -h

</code></pre><!--more--><p>部署的方法是直接在 macdeployqt 后提供 app 路径：</p><pre><code>macdeployqt path/to/test.app
</code></pre><p>执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3770174957.jpg" alt="Screen Shot 2020-12-05 at 23.49.48.jpg" title="Screen Shot 2020-12-05 at 23.49.48.jpg"></p><p>如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 <code>app/Contents/Frameworks</code> 文件夹内。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1966.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1966.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[QT 添加第三方库]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1958.html" />
<id>https://blog.niekun.net/archives/1958.html</id>
<updated>2020-12-02T11:52:00+08:00</updated>
<published>2020-12-02T11:52:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。GUI 添加使用 GUI 添加的好处是比较直观，使用鼠标点击...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1958.html" xml:lang="zh-CN"><![CDATA[
<p>如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。</p><h3>GUI 添加</h3><p>使用 GUI 添加的好处是比较直观，使用鼠标点击即可。</p><p>右键项目名称，点击 add library：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3998509933.jpg" alt="1.jpg" title="1.jpg"></p><!--more--><p>选中 external library 点击 next：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/1625536441.jpg" alt="2.jpg" title="2.jpg"></p><p>选择头文件所在目录路径：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3830480933.jpg" alt="3.jpg" title="3.jpg"></p><p>如果有 lib 库文件的话需要链接进来，没有的话可以不设置：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/1700799379.jpg" alt="4.jpg" title="4.jpg"></p><p>其他保持默认然后点击 next 完成添加。</p><p>我们打开 pro 文件可以看到在文件最后添加了相关内容：</p><pre><code>win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dlld
else:unix: LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll

INCLUDEPATH += $$PWD/../../../Library/boost_1_72_0
DEPENDPATH += $$PWD/../../../Library/boost_1_72_0</code></pre><h3>pro 文件添加</h3><p>根据添加一个第三方库所增加的语句，我们可以手动直接编辑 pro 文件完成添加：</p><ul><li><code>LIBS</code> 指定 lib 库文件路径，没有的话不需要定义</li><li><code>INCLUDEPATH</code> 指头文件所在目录</li><li><code>DEPENDPATH</code> 定义和头文件相同目录即可</li></ul><p>例如我们添加一个 boost filesystem 库到项目：</p><pre><code>LIBS += -L&quot;/path/to/boost_1_72_0/stage/lib/&quot; \
        -llibboost_filesystem-mgw81-mt-x32-1_72 \
        -llibboost_regex-mgw81-mt-x32-1_72

INCLUDEPATH += &quot;/path/to/boost_1_72_0&quot;
DEPENDPATH += &quot;/path/to/boost_1_72_0&quot;</code></pre><p><code>LIBS</code> 中，使用 <code>-L</code> 添加 lib 库目录，使用 <code>-l</code> 添加具体某个库文件，可以不写文件后缀。</p><p>以上就是 QT 中添加第三方库的方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1958.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1958.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Macros 聚集 in c++]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1956.html" />
<id>https://blog.niekun.net/archives/1956.html</id>
<updated>2020-12-01T11:37:00+08:00</updated>
<published>2020-12-01T11:37:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1956.html" xml:lang="zh-CN"><![CDATA[
<p>在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。</p><p>有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符作为 macro 名称，甚至是 c 关键词。</p><!--more--><h3>object 形式</h3><p>object 形式的 macro 就是简单的使用一个 identifier 代替代码片段。使用 <code>#define</code> 定义一个 macro：</p><pre><code>#define TESTINT 1024

void main() {
    int a = TESTINT;
    cout &lt;&lt; a &lt;&lt; endl;
}

//output:
//1024</code></pre><p>也可以定义一个片段：</p><pre><code>#define NUMBERS 1, 2, 3

void main() {
    int x[] = { NUMBERS };
    //int x[] = { 1, 2, 3 };这两句效果相同
}</code></pre><p>也可以多层定义：</p><pre><code>#define NUMBER1 1
#define NUMBER2 NUMBER1</code></pre><p>以上示例中 NUMBER2 等于 NUMBER1。</p><h3>function 形式</h3><p>可以定义 function 形式的 macro，需要在定义中 macro 名称后加上圆括号<code>()</code>。例如：</p><pre><code>#define lang_init()  c_init()</code></pre><p>定义后就可以使用 <code>lang_init()</code> 来调用 <code>c_init()</code> 了，类似于 alias。</p><p>object 类型的 macro 可以和 function 类型的 macro 同名，区别就是有没有圆括号：</p><pre><code>#define test 100
#define test() func()

void main() {
    int a = test;
    test();
}</code></pre><p>以上就是对 macro 的简单介绍。</p><p>参考链接：<br><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1956.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1956.html" thr:count="0"/>
</entry>
</feed>