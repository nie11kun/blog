<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - Linux</title>
<link>https://blog.niekun.net/category/Linux/</link>
<atom:link href="https://blog.niekun.net/feed/category/Linux/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Tue, 27 Oct 2020 22:32:30 +0800</lastBuildDate>
<pubDate>Tue, 27 Oct 2020 22:32:30 +0800</pubDate>
<item>
<title>Linux 的 ip 命令使用教程</title>
<link>https://blog.niekun.net/archives/1885.html</link>
<guid>https://blog.niekun.net/archives/1885.html</guid>
<pubDate>Tue, 27 Oct 2020 22:32:30 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Linux 的 ip 命令使用教程]]></description>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1885.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1885.html</wfw:commentRss>
</item>
<item>
<title>使用 dnsmasq 和 iptables 控制域名流量</title>
<link>https://blog.niekun.net/archives/1872.html</link>
<guid>https://blog.niekun.net/archives/1872.html</guid>
<pubDate>Mon, 26 Oct 2020 22:29:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[dnsmasq 是处理 dns 请求的工具，实现域名请求解析到目标 IP 地址的过程。可以方便的管理本机或局域网设备的域名解析服务，使用教程参考：https://blog.niekun.net/...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>dnsmasq 是处理 dns 请求的工具，实现域名请求解析到目标 IP 地址的过程。可以方便的管理本机或局域网设备的域名解析服务，使用教程参考：<a href="https://blog.niekun.net/archives/1869.html">https://blog.niekun.net/archives/1869.html</a></p><p>iptables 是网络防火墙规则管理/修改工具，管理网络数据包的处理和转发。使用教程参考：<a href="https://blog.niekun.net/archives/1863.html">https://blog.niekun.net/archives/1863.html</a></p><p>iptables 管理某个源地址或目标地址的流量时，只能识别 IP 地址，比如：</p><pre><code># -s 匹配源地址流量,接收来自 192.168.1.230 发往本机的流量：
iptables -t filter -A INPUT -s 192.168.1.230 -j ACCEPT

# -d 匹配目标地址的流量,丢弃发往 192.168.1.123 的流量：
iptables -t filter -A OUTPUT -d 192.168.1.123 -j DROP</code></pre><!--more--><p><strong>如果要使用 iptables 管理某域名的流量，可以使用 dnsmasq-full 里的 ipset 工具标记并保存域名包含的 IP 地址池，然后在 iptables 中调取。</strong></p><p>使用命令查看当前安装版本的 dnsmasq 是否支持 ipset：</p><p>查询版本：</p><pre><code>dnsmasq -v
</code></pre><p>信息里 Compile time options 可以看到当前安装版本支持的选项功能 ，如：ipset</p><pre><code>root@OpenWrt:/etc# dnsmasq -v
Dnsmasq version 2.80  Copyright (c) 2000-2018 Simon Kelley
Compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP conntrack ipset auth DNSSEC no-ID loop-detect inotify dumpfile
...</code></pre><p>如果没有 ipset 就需要手动安装 dnsmasq-full 版本了，升级方法参考：<a href="https://blog.niekun.net/archives/1869.html">https://blog.niekun.net/archives/1869.html</a></p><h3>域名解析标记</h3><p>首先建立我们自定义的 ipset 表来存储解析的 IP 地址：</p><pre><code>ipset create block hash:ip
</code></pre><p>可以查询当前这个列表是空的：</p><pre><code>root@OpenWrt:~# ipset list block
Name: block
Type: hash:ip
Revision: 4
Header: family inet hashsize 1024 maxelem 65536
Size in memory: 88
References: 0
Number of entries: 0
Members:</code></pre><p>使用 dnsmasq 的 ipset 命令做域名解析结果标记和存储，在 dnsmasq 的配置文件，如：<code>/etc/dnsmasq.conf</code> 中加入如下语句：</p><pre><code>ipset=/360.com/block
</code></pre><p>重启 ndsmasq 服务：</p><pre><code>systemctl restart dnsmasq
</code></pre><p>使用 nslookup 命令对 360.com 域名进行 dns 查询：</p><pre><code>root@OpenWrt:/etc# nslookup 360.com
Server:        127.0.0.1
Address:    127.0.0.1#53

Name:      360.com
Address 1: 180.163.251.93
Address 2: 36.110.213.45</code></pre><p>这时候重新查看建立的 ipset 表内容：</p><pre><code>root@OpenWrt:/etc# ipset list block
Name: block
Type: hash:ip
Revision: 4
Header: family inet hashsize 1024 maxelem 65536
Size in memory: 184
References: 0
Number of entries: 2
Members:
36.110.213.45
180.163.251.93</code></pre><p>可以看到域名对应的 IP 地址已经记录到了 block 表内。</p><h3>流量处理</h3><p>iptables 可以调用 ipset 表来对流量进行处理，使用 <code>-I</code> 参数将规则添加到链表最上方以确保顺利匹配，使用 <code>-m set --match-set 列表名 dst</code> 匹配目标地址，或 <code>-m set --match-set 列表名 src</code> 匹配原地址，下面举例说明：</p><pre><code># 屏蔽 block 表地址的访问
iptables -t filter -I INPUT -m set --match-set block src -j DROP

# 允许 allow 表地址的访问
iptables -t filter -I INPUT -m set --match-set allow src -j RETURN</code></pre><p>iptables 设置完成后就可以测试对应域名是否受防火墙规则控制了。</p><p>查询路由表加入的规则：</p><pre><code>iptables -t filter -L -n
</code></pre><p>如果要删除 INPUT 路由链第一条规则，使用命令：</p><pre><code>iptables -t filter -D INPUT 1
</code></pre><p>以上就是使用 dnsmasq 的 ipset 功能实现 iptables 对域名流量的控制。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1872.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1872.html</wfw:commentRss>
</item>
<item>
<title>dnsmasq 使用教程</title>
<link>https://blog.niekun.net/archives/1869.html</link>
<guid>https://blog.niekun.net/archives/1869.html</guid>
<pubDate>Sun, 25 Oct 2020 07:51:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[dnsmasq 提供 DNS 缓存/查询服务和 DHCP(Dynamic Host Configuration Protocol) 服务等功能，用来管理本地局域网络系统。内置于常见的 Linux...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>dnsmasq 提供 DNS 缓存/查询服务和 DHCP(Dynamic Host Configuration Protocol) 服务等功能，用来管理本地局域网络系统。内置于常见的 Linux 分发版，openWrt，macOS 系统中。</p><h3>安装</h3><p>直接使用包管理器安装：</p><pre><code>apt install dnsmasq
</code></pre><p>查询版本：</p><pre><code>dnsmasq -v
</code></pre><p>信息里 <strong>Compile time options</strong> 可以看到当前安装版本支持的选项功能 ，如：<code>ipset</code></p><pre><code>root@OpenWrt:/etc# dnsmasq -v
Dnsmasq version 2.80  Copyright (c) 2000-2018 Simon Kelley
Compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP conntrack ipset auth DNSSEC no-ID loop-detect inotify dumpfile

This software comes with ABSOLUTELY NO WARRANTY.
Dnsmasq is free software, and you are welcome to redistribute it
under the terms of the GNU General Public License, version 2 or 3.</code></pre><p>启动服务：</p><pre><code>systemctl start dnsmasq
</code></pre><p>服务启动后，会监听本地或局域网内的 DNS 请求并根据配置规则进行处理。</p><!--more--><h3>DNS 服务</h3><h4>Linux DNS 请求处理流程</h4><p><code>test.com</code> -&gt; <code>/etc/hosts</code> -&gt; <code>/etc/resolv.conf</code> -&gt; <code>dnsmasq</code></p><p>以上每个过程中只要得到了解析的 IP 地址则直接结束剩下的处理过程。</p><p><code>/etc/hosts</code> 文件是 Linux 系统默认的 hosts 文件，一般发起的 DNS 请求会首先查询此 hosts 文件，如果没有匹配上则从 <code>/etc/resolv.conf</code> 文件找 DNS 服务器进行进一步查询。</p><p><code>/etc/resolv.conf</code> 文件是 linux 系统的默认 dns 配置文件，一般情况下里面定义的域名服务器地址为本地：127.0.0.1 地址，由于 dnsmasq 默认监听本地及局域网 53 端口，则 DNS 请求就会传入 dnsmasq 进行进一步解析。</p><p>下面介绍 hosts 文件和 resolv 文件的意义。</p><h4>hosts</h4><p>hosts 文件主要用来指定某个域名的解析 IP，通常用来处理局域网设备的域名解析到对应设备 IP。一般情况下局域网设备设置的域名不能在公共 DNS 服务器进行解析。系统默认的 hosts 文件地址：<code>/etc/hosts</code>。</p><p>文件格式：</p><pre><code>127.0.0.1 localhost
192.168.1.123 test1.home.lan
192.168.1.124 test2.home.lan</code></pre><p>使用 hosts 文件也可以用来进行域名欺骗，实现广告屏蔽等功能，比如我想要屏蔽 360 的所有访问：</p><pre><code>127.0.0.1 360.com</code></pre><p>dnsmasq 可以选择使用自定义的 hosts 文件。</p><h4>resolv.conf</h4><p>resolv.conf 文件定义了 DNS 服务器地址，dns 请求会转发到设置的地址上。可以指定多个服务器进行顺序查询直到解析到 IP 地址，指定为本地地址 127.0.0.1 会转发到本地 dnsmasq 进行处理。<code>/etc/resolv.conf</code> 是系统默认解析服务器配置文件。</p><p>文件格式：</p><pre><code>nameserver 127.0.0.1
nameserver 192.168.1.1
nameserver 114.114.114.114</code></pre><p>系统默认的 <code>/etc/resolv.conf</code> 文件在每次系统启动会根据 DHCP 分配情况自动生成，一般指向本地地址或局域网网关。dnsmasq 可以配置自定义的 resolv 文件可以设置公网的 DNS 解析服务器，也就是上游 DNS 服务器。</p><h4>dnsmasq 处理流程简介</h4><p><code>dnsmasq</code> -&gt; <code>hosts.dnsmasq</code> -&gt; <code>/etc/dnsmasq.conf</code> / <code>dnsmasq.conf</code> -&gt; <code>resolv.dnsmasq.conf</code></p><p>DNS 请求传入 dnsmasq 后通过其配置文件来进行 DNS 查询，首先查询 hosts 文件，如果设置了自定义 hosts 文件和系统默认 hosts 一起查询，没有匹配到的话就进入 conf 配置文件内部的 server 及 address 项进行匹配，如果依然没有结果则查询 relolv 自定义配置文件定义的上游 DNS 服务器。</p><p><code>/etc/dnsmasq.d</code> 文件夹和 <code>/etc/dnsmasq.conf</code> 文件是 dnsmasq 的配置路径，可以设置监听地址，自定义 hosts.dnsmasq 文件地址，自定义 resolv.dnsmasq.conf 文件地址，也可以在文件内直接指定某域名使用的 DNS 解析服务器等。</p><p><code>/etc/dnsmasq.d</code> 文件夹可以存放用户自定义的 dnsmasq 配置文件，效果等同于直接写入 dnsmasq.conf 文件内，方便整理自定义规则。</p><h4>dnsmasq 配置文件</h4><p>下面介绍 dnsmasq 配置常用的语句：</p><pre><code># 监听地址：
# 如果只写 127.0.0.1 则只处理本机的 DNS 解析，不写这句默认监听所有网口
listen-address=127.0.0.1,192.168.8.132

# 指定自定义 hosts 文件：
addn-hosts=/etc/hosts.dnsmasq

# 指定上游 DNS 服务列表的配置文件
resolv-file=/etc/resolv.dnsmasq.conf

# 按照 DNS 列表一个个查询，否则将请求发送到所有 DNS 服务器
strict-order

# 表示对下面设置的所有 server 发起查询请求，选择响应最快的服务器的结果
all-servers

# 指定默认查询的上游服务器
server=8.8.8.8
server=114.114.114.114

# 指定 .cn 的域名全部通过 114.114.114.114 这台国内DNS服务器来解析
server=/cn/114.114.114.114

# 给 *.apple.com 和 taobao.com 使用专用的 DNS
server=/taobao.com/223.5.5.5
server=/.apple.com/223.6.6.6

# 增加一个域名，强制解析到所指定的地址上，dns 欺骗
address=/360.com/127.0.0.1

# 设置DNS缓存大小(单位：DNS解析条数)
cache-size=500

# 存储域名解析的 IP 地址结果存储到 saveresult 的 ipset 结果中，可以交给iptables识别和转发
ipset=/test.com/saveresult</code></pre><h3>DHCP 服务</h3><p>待整理。。。</p><h3>升级 dnsmasq-full</h3><p>openWrt 默认安装的 dnsmasq 缺少一些选项功能，如：ipset，可以安装 dnsmasq-full 来实现更多功能，由于 dnsmasq 管理着域名解析工作，卸载 dnsmasq 后会导致无法正确解析域名从无法联网。有 2 种方法避免这种情况：</p><ul><li>修改 <code>resolv.conf</code> 文件手动指定 DNS 服务器</li><li>提前下载好 dnsmasq-full 安装文件。</li></ul><h4>手动指定 DNS 解析地址</h4><p>修改 <code>/etc/resolv.conf</code> 文件，指定上游 DNS 服务器：</p><pre><code>nameserver 114.114.114.114
</code></pre><p>卸载及安装新程序：</p><pre><code>opkg remove dnsmasq &amp;&amp; opkg install dnsmasq-full
</code></pre><h4>提前下载安装包</h4><pre><code># 下载安装包
opkg download dnsmasq-full
# 查看下载的安装包名称：
ls
# 尝试安装，会提示失败，但可以安装好需要的依赖包
opkg install dnsmasq-full
# 删除原 dnsmasq
opkg remove dnsmasq
# 安装下载好的包
opkg install dnsmasq-full_2.80-15_x86_64.ipk
# 安装完成后可以删除安装包文件
rm dnsmasq-full_2.80-15_x86_64.ipk </code></pre><h3>参考链接</h3><p><a href="https://www.solarck.com/openwrt-v2ray.html">一文玩转V2ray 透明代理</a><br><a href="http://www.enkichen.com/2017/05/23/dnsmasq-introduce/">Dnsmasq 介绍与使用</a><br><a href="https://blog.csdn.net/lvshaorong/article/details/52981169">Dnsmasq+ipset+iptables基于域名的流量管理</a></p>
]]></content:encoded>
<slash:comments>3</slash:comments>
<comments>https://blog.niekun.net/archives/1869.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1869.html</wfw:commentRss>
</item>
<item>
<title>iptables 使用教程</title>
<link>https://blog.niekun.net/archives/1863.html</link>
<guid>https://blog.niekun.net/archives/1863.html</guid>
<pubDate>Fri, 23 Oct 2020 09:59:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[ipatbles 是 Linux 下的网络防火墙规则管理/修改工具，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。用来识别路由表中特定的流量然后执行设定的规...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>ipatbles 是 Linux 下的网络防火墙规则管理/修改工具，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。用来识别路由表中特定的流量然后执行设定的规则。只用于处理 IPv4 数据包；而对于 IPv6 数据包，则使用类似的 ip6tables 命令。</p><h3>基本概念</h3><p>结构：</p><ul><li>Tables 路由表：用来区分不同类型的数据包，如 filter，nat，mangle，每个表包含几个路由链</li><li>Chain 路由链：流量的类型，如 INPUT ，FORWARD ，OUTPUT ，每种类型流量可以设置不同规则</li><li>Rule 规则：用来匹配特定类型的流量，如匹配来自 192.168.1.230 的流量</li><li>Target 目标：用来处理匹配到的流量，如 ACCEPT, DROP, QUEUE.</li><li>Policy 策略：是默认的处理动作，用来处理没有匹配到的流量，如 ACCEPT or DROP.</li></ul><p>iptables、ip6tables等都使用Xtables框架。存在“表（tables）”、“链（chain）”和“规则（rules）”三个层面。</p><p>每个“表”指的是不同类型的数据包处理流程，如filter表表示进行数据包过滤，而nat表针对连接进行地址转换操作。每个表中又可以存在多个“链”，系统按照预订的规则将数据包通过某个内建链，例如将从本机发出的数据通过OUTPUT链。在“链”中可以存在若干“规则”，这些规则会被逐一进行匹配，如果匹配，可以执行相应的动作，如修改数据包，或者跳转。跳转可以直接接受该数据包或拒绝该数据包，也可以跳转到其他链继续进行匹配，或者从当前链返回调用者链。当链中所有规则都执行完仍然没有跳转时，将根据该链的默认策略（“policy”）执行对应动作；如果也没有默认动作，则是返回调用者链。</p><!--more--><pre><code>                                           netfilter hooks

                                  +-----------&gt; local +-----------+
                                  |             process           |
                                  |                               |
                                  |                               |
                                  |                               |
                                  |                               v
  MANGLE            +-------------+--------+
  FILTER            |                      |               +----------------------+    RAW
  SECURITY          |        input         |               |                      |    conntrack
  SNAT              |                      |               |     output           |    MANGLE
                    +------+---------------+               |                      |    DNAT
                           ^                               +-------+--------------+    routing
                           |                                       |                   FILTER
                           |                                       |                   SECURITY
                           |            +---------------------+    |         +-------------+
     +-----------+                      |                     |    +-------&gt; |             |
+--&gt; |pre routing+----  route    -----&gt; |      forward        |              |post routing +----&gt;
     |           |      lookup          |                     +------------&gt; |             |
     +-----------+                      +---------------------+              +-------------+
     
     RAW                                       MANGLE                         MANGLE
     conntrack                                 FILTER                         SNAT
     MANGLE                                    SECURITY
     DNAT
     routing
     </code></pre><p><strong>内建的路由表：</strong></p><ul><li>filter: 是默认的表，如果不指明表则使用此表。其通常用于过滤数据包。It includes chains like INPUT, OUTPUT and FORWARD.</li><li>nat : 用于地址转换操作。It includes PREROUTING and POSTROUTING chains.</li><li>mangle : 用于修改或标记数据包。</li><li>raw : 用于处理异常。Built-in chains are PREROUTING and OUTPUT.</li><li>security : Used for Mandatory Access Control</li></ul><p><strong>内建的路由链：</strong></p><ul><li>INPUT :输入链。发往本机的数据包通过此链</li><li>FORWARD :转发链。本机转发的数据包通过此链</li><li>OUTPUT :输出链。从本机发出的数据包通过此链</li><li>PREROUTING :路由前链，在处理路由规则前通过此链，通常用于目的地址转换（DNAT）</li><li>POSTROUTING :路由后链，完成路由规则后通过此链，通常用于源地址转换（SNAT）</li></ul><p><strong>Note: 用户可以创建自定义路由链</strong></p><p><strong>目标：</strong></p><ul><li>RETURN 允许并结束在 chains 里继续匹配</li><li>ACCEPT 允许但依然要在其他 chains 里继续进行匹配</li><li>REJECT 拒绝</li><li>DROP 丢弃</li><li>REDIRECT 重定向。只适用于 NAT 路由表的 PREROUTING 和 OUTPUT 路由链</li><li>MARK 只适用于 mangle 路由表。用来给特定流量做标记。</li></ul><pre><code>root@OpenWrt:~# iptables -h
iptables v1.8.3

Usage: iptables -[ACD] chain rule-specification [options]
       iptables -I chain [rulenum] rule-specification [options]
       iptables -R chain rulenum rule-specification [options]
       iptables -D chain rulenum [options]
       iptables -[LS] [chain [rulenum]] [options]
       iptables -[FZ] [chain] [options]
       iptables -[NX] chain
       iptables -E old-chain-name new-chain-name
       iptables -P chain target [options]
       iptables -h (print this help information)

Commands:
Either long or short options are allowed.
  --append  -A chain        Append to chain
  --check   -C chain        Check for the existence of a rule
  --delete  -D chain        Delete matching rule from chain
  --delete  -D chain rulenum
                Delete rule rulenum (1 = first) from chain
  --insert  -I chain [rulenum]
                Insert in chain as rulenum (default 1=first)
  --replace -R chain rulenum
                Replace rule rulenum (1 = first) in chain
  --list    -L [chain [rulenum]]
                List the rules in a chain or all chains
  --list-rules -S [chain [rulenum]]
                Print the rules in a chain or all chains
  --flush   -F [chain]        Delete all rules in  chain or all chains
  --zero    -Z [chain [rulenum]]
                Zero counters in chain or all chains
  --new     -N chain        Create a new user-defined chain
  --delete-chain
            -X [chain]        Delete a user-defined chain
  --policy  -P chain target
                Change policy on chain to target
  --rename-chain
            -E old-chain new-chain
                Change chain name, (moving any references)
Options:
    --ipv4    -4        Nothing (line is ignored by ip6tables-restore)
    --ipv6    -6        Error (line is ignored by iptables-restore)
[!] --protocol    -p proto    protocol: by number or name, eg. `tcp'
[!] --source    -s address[/mask][...]
                source specification
[!] --destination -d address[/mask][...]
                destination specification
[!] --in-interface -i input name[+]
                network interface name ([+] for wildcard)
 --jump    -j target
                target for rule (may load target extension)
  --goto      -g chain
                              jump to chain with no return
  --match    -m match
                extended match (may load extension)
  --numeric    -n        numeric output of addresses and ports
[!] --out-interface -o output name[+]
                network interface name ([+] for wildcard)
  --table    -t table    table to manipulate (default: `filter')
  --verbose    -v        verbose mode
  --wait    -w [seconds]    maximum wait to acquire xtables lock before give up
  --wait-interval -W [usecs]    wait time to try to acquire xtables lock
                default is 1 second
  --line-numbers        print line numbers when listing
  --exact    -x        expand numbers (display exact values)
[!] --fragment    -f        match second or further fragments only
  --modprobe=&lt;command&gt;        try to insert modules using this command
  --set-counters PKTS BYTES    set the counter during insert/append
[!] --version    -V        print package version.</code></pre><p><strong>语法结构：</strong></p><pre><code>iptables -t [TABLE] [-A/-C/-D...] [CHAIN] rule -j Target
</code></pre><h3>路由链操作</h3><h4>-A 链添加规则</h4><p><code>-A</code> 在链表后添加规则和动作，新加的规则排在表的最后。</p><p>允许所有发往本机的流量：</p><pre><code>iptables -t filter -A INPUT -j ACCEPT
</code></pre><h4>-I 插入规则</h4><p><code>-I</code> 指令添加规则并可指定新规则在链表的位置，不指定排序数字的话默认插入的规则放置到路由链第一条。</p><p>新建规则并作为 INPUT 路由链第一条规则：</p><pre><code>iptables -t filter -I INPUT -j ACCEPT
</code></pre><p>新建规则并作为 INPUT 路由链第二条规则：</p><pre><code>iptables -t filter -I INPUT 2 -j ACCEPT
</code></pre><p>由于链表的规则是顺序读取的，所以将规则放在前面有时候会确保规则的正确执行，使用 <code>-I</code> 参数比较合适。</p><h4>-D 链删除规则</h4><p>删除设定的发往本机的编号为 2 的规则：</p><pre><code>iptables -t filter -D INPUT 2
</code></pre><h4>-C 链检查规则是否存在</h4><p>检查是否有丢弃来自 192.168.1.123 的流量的规则：</p><pre><code>iptables -t filter -C INPUT -s 192.168.1.123 -j DROP
</code></pre><h4>-L 路由规则列表</h4><p>列出当前设定的所有规则并按顺序排序：</p><pre><code>iptables -L -n
</code></pre><p>列出特定路由表的规则：</p><pre><code>iptbales -t [TABLE] -L
</code></pre><p>列出特定路由表的某条链的规则：</p><pre><code>iptbales -t [TABLE] -L INPUT
</code></pre><h4>举例说明</h4><p>分别使用 <code>-A</code> <code>-I</code> 建立规则，然后 <code>-L</code> 查看规则，<code>-D</code> 删除规则：</p><pre><code>$ iptables -I INPUT -s 192.168.1.101 -j ACCEPT
$ iptables -A INPUT -s 192.168.1.102 -j ACCEPT
$ iptables -I INPUT -s 192.168.1.103 -j ACCEPT
$ iptables -I INPUT 2 -s 192.168.1.104 -j ACCEPT

$ iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  192.168.1.103        anywhere            
ACCEPT     all  --  192.168.1.104        anywhere            
ACCEPT     all  --  192.168.1.101        anywhere            
ACCEPT     all  --  192.168.1.102        anywhere

$ iptables -D INPUT 2
$ iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  192.168.1.103        anywhere            
ACCEPT     all  --  192.168.1.101        anywhere            
ACCEPT     all  --  192.168.1.102        anywhere</code></pre><h3>规则匹配</h3><h4>-p 匹配特定协议的流量</h4><p>可能的流量类型: tcp, udp, icmp, ssh etc.</p><p>屏蔽对本机的 ping 请求：</p><pre><code>iptables -t filter -A INPUT -p icmp -j DROP
</code></pre><p>丢弃发往本机的 udp 流量：</p><pre><code>iptables -t filter -A INPUT -p udp -j DROP
</code></pre><h4>--dport 匹配特定端口</h4><p>丢弃访问本机 1080 端口的 tcp 流量：(默认是 filter 路由表)</p><pre><code>iptables -A INPUT -p tcp --dport 1080 -j DROP
</code></pre><h4>-s 匹配源地址流量</h4><p>接收来自 192.168.1.230 发往本机的流量：</p><pre><code>iptables -t filter -A INPUT -s 192.168.1.230 -j ACCEPT
</code></pre><h4>-d 目标地址的流量</h4><p>丢弃发往 192.168.1.123 的流量：</p><pre><code>iptables -t filter -A OUTPUT -d 192.168.1.123 -j DROP
</code></pre><h4>-i 匹配特定网络入口的流量：</h4><p>丢弃所有来自 wlan0 无线网口的流量：</p><pre><code>iptables -t filter -A INPUT -i wlan0 -j DROP
</code></pre><h4>-o 匹配特定网络出口的流量：</h4><p>丢弃所有发往 eth0 网口的流量：</p><pre><code>iptables -t filter -A OUTPUT -i eth0 -j DROP
</code></pre><h4>允许 loopback 本地访问</h4><p>允许来自本地的访问(127.0.0.1) 非常重要，应该保证为打开状态：(<code>lo</code> 表示本机网口-interface)</p><pre><code>iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
</code></pre><h3>规则动作</h3><h4>-j 规则匹配后的动作</h4><p>丢弃所有转发链流量：</p><pre><code>iptables -t filter -A FORWARD -j DROP
</code></pre><h3>-m 匹配参数的使用</h3><h4>-m multiport 同时处理多端口</h4><p>允许访问本机的多个端口的 tcp 流量：(默认是 filter 路由表)</p><pre><code>iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -j ACCEPT
</code></pre><h4>-m mac 匹配特定 mac 地址</h4><p>丢弃某个 mac 地址对本地的访问：</p><pre><code>iptables -A INPUT -m mac --mac-source 00:00:00:00:00:00 -j DROP
</code></pre><h3>路由转发</h3><p>将特定的流量转发到另一个地方，需要用到 PREROUTING 路由表来预处理流量。</p><p>将来自 eth0 网口的访问本机 25 端口的 tcp 流量转发到 2525 端口：</p><pre><code>iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 25 -j REDIRECT --to-port 2525
</code></pre><h3>新建路由链</h3><p>通过新建自定义路由链，可以放入自定义的规则到里面。<strong>自定义规则并不能被直接使用</strong>，需要使用系统内置的 chains 然后 jump 到自定义 chain。</p><p>语法：</p><pre><code>iptables -t [TABLE] -N [CHAIN]
</code></pre><p>在 NAT 路由表下新建路由链 custom-chain：</p><pre><code>iptables -t nat -N custom-chain
</code></pre><p>查看新建的路由链：</p><pre><code>iptables -L custom-chain
</code></pre><p>将流量转到自定义路由链：</p><pre><code>iptables -A INPUT -p tcp -j custom-chain
</code></pre><h3>标记流量</h3><p>MARK 目标用来给流量做标记，方便识别及处理。只适用于 mangle 路由表：</p><pre><code>iptables -t mangle -A PREROUTING -p udp --dport 53 -j MARK --set-mark 1
</code></pre><h3>常用命令</h3><p>清除设置的规则，默认为 filter 路由表：</p><pre><code>iptables -t [TABLE] -F
</code></pre><p>保存规则：</p><pre><code>iptables-save &gt; /path/to/file
</code></pre><p>恢复规则：</p><pre><code>iptables-restore &lt; /path/to/file
</code></pre><h3>参考文章</h3><p><a href="https://www.geeksforgeeks.org/iptables-command-in-linux-with-examples/">iptables command in Linux with Examples</a><br><a href="https://www.tecmint.com/linux-iptables-firewall-rules-examples-commands/">25 Useful IPtable Firewall Rules Every Linux Administrator Should Know</a><br><a href="https://zh.wikipedia.org/wiki/Iptables">iptables wikipedia</a><br><a href="https://gist.github.com/mcastelino/c38e71eb0809d1427a6650d843c42ac2">https://gist.github.com/mcastelino/c38e71eb0809d1427a6650d843c42ac2</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1863.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1863.html</wfw:commentRss>
</item>
<item>
<title>vmware 虚拟机安装 openWRT 及路由配置</title>
<link>https://blog.niekun.net/archives/1818.html</link>
<guid>https://blog.niekun.net/archives/1818.html</guid>
<pubDate>Thu, 15 Oct 2020 16:51:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[openWrt 是专门为嵌入式设备设计的 Linux 系统，常用来作为软路由系统使用。LEDE 和 openWrt 已经合并到一起。官网：https://openwrt.org/由于最近研究软路...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>openWrt 是专门为嵌入式设备设计的 Linux 系统，常用来作为软路由系统使用。LEDE 和 openWrt 已经合并到一起。</p><p>官网：<a href="https://openwrt.org/">https://openwrt.org/</a></p><p>由于最近研究软路由，所以先再 Windows 上使用 VMware 虚拟机安装测试 openWrt。</p><!--more--><h3>固件下载及转换</h3><p>openWrt 固件也是区分不同硬件平台的，需要根据硬件情况下载对应的系统镜像。</p><p>官方固件下载地址：<a href="https://downloads.openwrt.org/">https://downloads.openwrt.org/</a></p><p>目前最新的版本是 19.07.4，我电脑是 x86 平台 64位系统需下载 x86_64 固件，进入列表下载 <code>combined-ext4.img.gz</code> 到本地:<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2820863057.jpg" alt="1.jpg" title="1.jpg"></p><p>将下载的压缩包解压出 img 镜像文件。由于我是虚拟机安装，所以需要将下载的 img 镜像转换为 VMware 的虚拟硬盘格式：<code>.vmdk</code>，最方便的是使用 Linux 工具 <code>qemu-img</code> 来完成，这里我是用 wsl 子系统来处理：</p><pre><code>apt install qemu qemu-utils
qemu-img convert -f raw -O vmdk openwrt-19.07.4-x86-64-combined-ext4.img openwrt-19.07.4-x86-64-combined-ext4.vmdk</code></pre><p>完成后得到 vmdk 文件。</p><h3>建立虚拟机</h3><p>新建虚拟机，选择自定义模式：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1077455176.jpg" alt="2.jpg" title="2.jpg"></p><p>硬件兼容选择最新的即可：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1008180166.jpg" alt="3.jpg" title="3.jpg"></p><p>然后选择稍后安装操作系统：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/689721582.jpg" alt="4.jpg" title="4.jpg"></p><p>系统选择 Linux 系统，19.07 版本是 4.14 内核，我下载的是 64 位固件，所以选择<strong>其他 Linux 4.x内核，64位</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1075618772.jpg" alt="5.jpg" title="5.jpg"></p><p>虚拟机名称自己定义：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2232764296.jpg" alt="6.jpg" title="6.jpg"></p><p>处理器默认即可：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1085680336.jpg" alt="7.jpg" title="7.jpg"></p><p>内存分配1G：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/89327964.jpg" alt="8.jpg" title="8.jpg"></p><p>剩下的全部默认确定即可，虚拟机初步建立完成。</p><p>下一步开始配置虚拟网卡用来分配给 openwrt 的 lan 内网网卡，点击<strong>编辑 - 虚拟网络编辑器</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1374273348.jpg" alt="9.jpg" title="9.jpg"></p><p>点击右下角<strong>更改设置</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/691892215.jpg" alt="10.jpg" title="10.jpg"></p><p>点击<strong>添加网络</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1419508697.jpg" alt="11.jpg" title="11.jpg"></p><p>选择一个可用的网络点击确定，我选择 vnet2：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/44933613.jpg" alt="12.jpg" title="12.jpg"></p><p>选择<strong>仅主机模式</strong>，由于 openwrt 自带 DHCP 控制所以这里取消勾选 DHCP 服务：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2381585332.jpg" alt="13.jpg" title="13.jpg"></p><p>点击确认，完成虚拟网卡的建立，子网 IP 段是 192.168.111.0，子网掩码 255.255.255.0。</p><p>下面编辑刚才建立的虚拟机，点击<strong>编辑虚拟机设置</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1011907668.jpg" alt="14.jpg" title="14.jpg"></p><p>移除不需要的硬件，包括硬盘，保留网络适配器。快捷键 alt + R：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/731943422.jpg" alt="15.jpg" title="15.jpg"></p><p>将上面转换的 vmdk 文件拷贝到此虚拟机文件夹：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1633164225.jpg" alt="16.jpg" title="16.jpg"></p><p>点击添加硬件：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1582850006.jpg" alt="17.jpg" title="17.jpg"></p><p>选择<strong>硬盘</strong>，点击下一步：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1091507877.jpg" alt="18.jpg" title="18.jpg"></p><p>选择<strong>使用现有虚拟磁盘</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/3795351894.jpg" alt="19.jpg" title="19.jpg"></p><p>选择刚才复制到目录的 vmdk 文件，点击完成：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/3286075109.jpg" alt="20.jpg" title="20.jpg"></p><p>选择<strong>转换</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/3939975986.jpg" alt="21.jpg" title="21.jpg"></p><p>再次添加一个网络适配器：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/903097129.jpg" alt="22.jpg" title="22.jpg"></p><p>这里我们有了两个网络适配器，第一个分配给 lan 第二个分配给 wan，注意顺序，openWrt 默认识别第一个网卡为 lan。</p><p>第一个网卡 lan 设置为我们刚才建立的虚拟网卡 vnet2，用来给 openWrt 路由的内网使用：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2504631771.jpg" alt="23.jpg" title="23.jpg"></p><p>第二个网卡 wan 设置为桥接模式，用来连接物理外网：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2177677516.jpg" alt="24.jpg" title="24.jpg"></p><p>确认后启动虚拟机，等待进入进入系统。<strong>进入系统后可以设置一个快照方便以后恢复。</strong></p><h3>网络配置</h3><p>进入系统后，我们需要设置 lan 的 IP 地址为我们创建的虚拟网卡所在的 IP 段，就能从主机访问 openwrt 了。</p><p>需要编辑 <code>/etc/config/network</code> 配置文件，默认配置文件如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/3506271504.jpg" alt="25.jpg" title="25.jpg"></p><p>这里我们需要关闭网桥模式(用 #井号 屏蔽)，然后修改 lan 段里的 ipaddr 地址为虚拟网卡网段。我们这里修改为 <code>192.168.111.2</code>:<br><img src="https://blog.niekun.net/usr/uploads/2020/10/265255040.jpg" alt="40.jpg" title="40.jpg"></p><p>修改完成后 reboot 系统。</p><p>重启完成后使用 <code>ip addr</code> 查看系统网络配置，可以看到 wan 口 eth1 分配到主机网络所在局域网 IP 地址，lan 口 eth0 是虚拟网卡 IP 地址：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2989248495.jpg" alt="39.jpg" title="39.jpg"></p><p>使用 ping 查看是否可以连接外网：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/3233271645.jpg" alt="31.jpg" title="31.jpg"></p><p>如果无法 ping 通，则需要检查配置问题。</p><p>主机网络适配器里找到 vnet 2 虚拟网卡：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/133092593.jpg" alt="29.jpg" title="29.jpg"></p><p>查看信息，ip 地址是否正确，<strong>注意</strong>如果 openwrt 里的 IP 设置为了 <code>192.168.111.1</code>，则这里的IPv4 地址就需要修改为其他地址了，不然就冲突了：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/43426789.jpg" alt="30.jpg" title="30.jpg"></p><p>这时候使用主机访问 <code>192.168.111.2</code> 应该就可以进入 LuCl 界面了：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/811268622.jpg" alt="28.jpg" title="28.jpg"></p><p>默认没有密码，可以使用 <code>passwd</code> 设置登录密码。</p><p>我们先给 openWrt 设置一个静态 wan 口 Ip，这样局域网设备就可以方便访问了。点击 network - interface：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/1641305336.jpg" alt="32.jpg" title="32.jpg"></p><p>wan 口配置点击 edit：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2975940019.jpg" alt="33.jpg" title="33.jpg"></p><p>protocol 选择 static address，点击 switch protocol：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2765529412.jpg" alt="34.jpg" title="34.jpg"></p><p>设置本地局域网内的 IP 地址，网关地址和 DNS 地址，点击保存：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2870937409.jpg" alt="38.jpg" title="38.jpg"></p><p>点击 save：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/366895487.jpg" alt="36.jpg" title="36.jpg"></p><h3>更换国内源</h3><p>由于虚拟机内不方便复制粘贴文本，我们使用 ssh 连接虚拟机：<br><img src="https://blog.niekun.net/usr/uploads/2020/10/2079947691.jpg" alt="37.jpg" title="37.jpg"></p><p>类似于 Debian，openWrt 也有包管理系统 <code>opkg</code>。默认都是国外源地址访问比较慢，可以替换为国内镜像地址，这里使用清华园镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/openwrt/">https://mirrors.tuna.tsinghua.edu.cn/help/openwrt/</a></p><p>列表路径是：<code>/etc/opkg/</code>，有两个 conf 文件：<code>distfeeds.conf</code>, <code>customfeeds.conf</code></p><p>一键替换命令：</p><pre><code>sed -i 's_downloads.openwrt.org_mirrors.tuna.tsinghua.edu.cn/openwrt_' /etc/opkg/distfeeds.conf
</code></pre><p>更新列表：</p><pre><code>opkg update
</code></pre><p>安装常用工具：</p><pre><code>opkg install vim-full curl luci-i18n-base-zh-cn ca-certificates luci-ssl-openssl
</code></pre><h3>使用第三方源</h3><p><strong>使用第三方源步骤：</strong></p><ul><li>添加 第三方源 key 文件</li><li>源仓库地址加入 <code>/etc/opkg/customfeeds.conf</code> 文件</li><li>opkg update</li></ul><p>源仓库地址格式：</p><pre><code>src/gz example_feed_name http://www.example.com/path/to/files
</code></pre><p><strong>示例，加入第三方开发者 kuoruan 的源：</strong></p><p>添加 key：</p><pre><code>wget -O kuoruan-public.key http://openwrt.kuoruan.net/packages/public.key
opkg-key add kuoruan-public.key</code></pre><p>添加仓库地址到配置文件：</p><pre><code>echo &quot;src/gz kuoruan_universal http://openwrt.kuoruan.net/packages/releases/all&quot; \
  &gt;&gt; /etc/opkg/customfeeds.conf

opkg update</code></pre><h3>参考链接：</h3><p><a href="https://openwrt.org/docs/guide-user/virtualization/vmware">https://openwrt.org/docs/guide-user/virtualization/vmware</a><br><a href="https://github.com/kuoruan/luci-app-v2ray">https://github.com/kuoruan/luci-app-v2ray</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1818.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1818.html</wfw:commentRss>
</item>
<item>
<title>wsl 2 激活 systemd</title>
<link>https://blog.niekun.net/archives/1805.html</link>
<guid>https://blog.niekun.net/archives/1805.html</guid>
<pubDate>Tue, 13 Oct 2020 12:03:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[wsl 默认不支持 systemd，执行 systemd 命令会返回错误提示：# hostnamectlSystem has not been booted with systemd as in...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>wsl 默认不支持 systemd，执行 systemd 命令会返回错误提示：</p><pre><code># hostnamectl
System has not been booted with systemd as init system (PID 1). Can't operate.
Failed to create bus connection: Host is down</code></pre><p>可以安装第三方的工具 genie 来激活 systemd。</p><p>GitHub：<a href="https://github.com/arkane-systems/genie">https://github.com/arkane-systems/genie</a></p><!--more--><h3>安装</h3><p>添加第三方 apt 库，在 <code>/etc/apt/sources.list.d</code> 目录下新建文件 <code>wsl-translinux.list</code>，文件内容如下：</p><pre><code>deb [trusted=yes] https://wsl-translinux.arkane-systems.net/apt/ /</code></pre><p>更新库列表：</p><pre><code>apt update &amp;&amp; apt upgrade
</code></pre><p>安装依赖包：</p><p>安装 Microsoft 依赖，下载对应系统版本的 prod 包：<a href="https://packages.microsoft.com/config/">https://packages.microsoft.com/config/</a>：</p><pre><code>curl -O https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
dpkg -i packages-microsoft-prod.deb</code></pre><p>安装其他依赖：</p><pre><code>apt update &amp;&amp; apt install apt-transport-https daemonize dotnet-runtime-3.1</code></pre><p>安装 genie：</p><pre><code>apt install systemd-genie
</code></pre><h3>使用</h3><p>退出 wsl 系统后关闭 所有已打开的 wsl：</p><pre><code>wsl --shutdown
</code></pre><p>启动 wsl：</p><pre><code>wsl genie -s
</code></pre><p>启动的 Linux 系统就可以正常使用 systemd 了。</p><p>参考链接：<br><a href="https://gist.github.com/djfdyuruiry/6720faa3f9fc59bfdf6284ee1f41f950">https://gist.github.com/djfdyuruiry/6720faa3f9fc59bfdf6284ee1f41f950</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1805.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1805.html</wfw:commentRss>
</item>
<item>
<title>wls 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置</title>
<link>https://blog.niekun.net/archives/1801.html</link>
<guid>https://blog.niekun.net/archives/1801.html</guid>
<pubDate>Tue, 13 Oct 2020 10:01:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[在升级到 wsl 2 后发现一些网络问题和之前的 wsl 不一样了，主要是 DNS 解析和 wsl 和 Windows 网络互访问题，这里介绍如何处理。DNS 解析wsl 2 使用的 DNS 解...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在升级到 wsl 2 后发现一些网络问题和之前的 wsl 不一样了，主要是 DNS 解析和 wsl 和 Windows 网络互访问题，这里介绍如何处理。</p><h3>DNS 解析</h3><p>wsl 2 使用的 DNS 解析服务器设置在文件：<code>/etc/resolv.conf</code> 内设置，这是一个 link 文件，真正的文件路径是：<code>/run/resolvconf/resolv.conf</code>，这个文件是每次 wsl 启动时自动生成的，内容如下：</p><pre><code># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.24.144.1</code></pre><!--more--><p>nameserver 后面的就是指定的 DNS 服务器地址。我发现有时候分配的服务器地址是无效的，如：<code>127.0.0.53</code>，使用 ping 来测试发现提示无法解析地址。需要设置一个固定的 DNS 地址，方法如下：</p><ul><li>新建文件：<code>/etc/wsl.conf</code>，内容如下：</li></ul><pre><code>[network]
generateResolvConf = false</code></pre><p>以上配置好就不会自动创建 <code>/run/resolvconf/resolv.conf</code> 文件了。</p><p>退出 wsl，关机然后重新启动：</p><pre><code>exit
wsl --shutdown
wsl
</code></pre><p>删除 link 文件：<code>/etc/resolv.conf</code>:</p><pre><code>rm /etc/resolv.conf
</code></pre><p>然后新建 <code>/etc/resolv.conf</code> 文件，内容如下，可自定义 nameserver 地址：</p><pre><code>nameserver 114.114.114.114
</code></pre><p>再次退出 wsl，关机然后重新启动：</p><pre><code>exit
wsl --shutdown
wsl
</code></pre><p>查看 <code>/etc/resolv.conf</code> 文件是否是之前自定义的地址：</p><pre><code>cat /etc/resolv.conf
</code></pre><p>测试网络服务：</p><pre><code>ping niekun.net
</code></pre><p>参考链接：<a href="https://github.com/microsoft/WSL/issues/5256#issuecomment-666545999">https://github.com/microsoft/WSL/issues/5256#issuecomment-666545999</a></p><h3>网络访问配置</h3><p>以前使用 wsl 时 Linux 子系统和 Windows 主机的网络好像是直接互通的，比如我在 Windows 下建立了一个 http 网页 <code>http://127.0.0.1:6000</code>，可以在 Linux 子系统下直接访问地址 <code>http://127.0.0.1:6000</code>，同理对于 Windows 主机访问 Linux 子系统的服务也是可以使用 localhost 直接访问的。</p><p>在升级到 wsl 2 后发现这一特性没有了，无法直接通过 localhost 地址来互通，查询官方说明关于<a href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions#accessing-network-applications">wsl 2 访问网络服务</a> 的方法可以实现访问，但是每次关机后 wsl 和 Windows 本地地址会发生变化不方便使用。</p><p><strong>可以设置静态 IP 来固定地址。Windows 终端下执行下面命令：</strong></p><p>在 wsl 下增加 IP 地址：<code>192.168.50.16</code>，名称为：<code>eth0:1</code>:(以 Ubuntu 系统为例)</p><pre><code>wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
</code></pre><p>在 Windows 10 下增加一个 IP 地址：(此命令需要管理员权限执行)</p><pre><code>netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
</code></pre><p>执行后，在 wsl 下通过 IP：<code>192.168.50.88</code> 访问 Windows 服务。在 Windows 下通过 IP：<code>192.168.50.16</code> 访问 wsl 服务。</p><p>完成后再终端使用 ipconfig 查看设置：</p><pre><code>Ethernet adapter vEthernet (WSL):

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe60::b525:6b90:8fb0:f513%58
   IPv4 Address. . . . . . . . . . . : 172.23.64.1
   Subnet Mask . . . . . . . . . . . : 255.255.240.0
   IPv4 Address. . . . . . . . . . . : 192.168.50.88
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :</code></pre><p>以上两个命令可以写在一个 powershell 脚本文件内，脚本内设置管理员权限执行，由于需要管理员权限所以<strong>无法通过建立 shortcut 放到开机自启动文件夹来自动启动址</strong>。</p><p><code>wsl_ip.ps1</code> 脚本内容如下，会自动请求管理员权限：</p><pre><code>if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;))  
{  
  $arguments = &quot;&amp; '&quot; +$myinvocation.mycommand.definition + &quot;'&quot;
  Start-Process powershell -Verb runAs -ArgumentList $arguments
  Break
}

wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
</code></pre><p>为了方便使用，可以将脚本路径加入系统 PATH 中，这样可以方便的在终端直接运行脚本，PATH 设置参考：<a href="https://blog.niekun.net/archives/413.html">https://blog.niekun.net/archives/413.html</a></p><p>完成后打开终端直接执行命令：<code>wsl_ip</code> 即可快速设置 IP。</p><p>参考链接：<a href="https://github.com/MicrosoftDocs/WSL/issues/418#issuecomment-648570865">https://github.com/MicrosoftDocs/WSL/issues/418#issuecomment-648570865</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1801.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1801.html</wfw:commentRss>
</item>
<item>
<title>echo 命令的使用</title>
<link>https://blog.niekun.net/archives/1781.html</link>
<guid>https://blog.niekun.net/archives/1781.html</guid>
<pubDate>Wed, 30 Sep 2020 09:23:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[echo 是常用的终端命令，常用来输出字符串。配合命令的 option 选项可以实现多种输出方式。语法结构：echo [option(s)] [string(s)]常规使用输出字符串：$ ech...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>echo 是常用的终端命令，常用来输出字符串。配合命令的 option 选项可以实现多种输出方式。</p><h3>语法结构：</h3><pre><code>echo [option(s)] [string(s)]
</code></pre><h3>常规使用</h3><h4>输出字符串：</h4><pre><code>$ echo i have a dream
i have a dream</code></pre><!--more--><h4>输出变量：</h4><pre><code>$ x=10
$ echo $x
10</code></pre><h4>输出目录下所有文件名：</h4><pre><code>$ echo *
Business Card Template - PiXimperfect.psd Telegram Desktop Video desktop.ini echo.txt test1.txt test2.txt</code></pre><h4>输出特定名称的文件名：</h4><pre><code>$ echo *.txt
echo.txt test1.txt test2.txt</code></pre><h4>将字符串输出到文件：</h4><pre><code>$ echo 'abc' &gt; test.txt
$ cat test.txt
abc</code></pre><h3>使用 <code>-e</code> 选项识别字符串内的转义符 <code>\</code></h3><h4><code>\b</code> 表示清除字符间空格</h4><pre><code>$ echo -e 'a \bb \bc'
abc</code></pre><h4><code>\n</code> 表示换行</h4><pre><code>$ echo -e 'a\nb\nc'
a
b
c</code></pre><h4><code>\t</code> 表示添加制表符</h4><pre><code>$ echo -e 'a\tb\tc'
a       b       c</code></pre><p>可以结合 <code>\n</code> <code>\t</code> 使用：</p><pre><code>$ echo -e '\ta\n\tb\n\tc'
        a
        b
        c</code></pre><h4><code>\v</code> 表示添加垂直方向制表符</h4><pre><code>$ echo -e 'a\vb\vc'
a
 b
  c</code></pre><h4><code>\r</code> 表示丢弃前面的字符串</h4><pre><code>$ echo -e 'a\rbc'
bc</code></pre><h4><code>\c</code> 表示丢弃后面的字符串</h4><pre><code>$ echo -e 'a\cbc'
aroot@localhost$</code></pre><p>以上就是 <code>echo</code> 命令的简单使用方法。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1781.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1781.html</wfw:commentRss>
</item>
<item>
<title>Failed to parse PID from file /opt/nginx/logs/nginx.pid 处理</title>
<link>https://blog.niekun.net/archives/1763.html</link>
<guid>https://blog.niekun.net/archives/1763.html</guid>
<pubDate>Tue, 22 Sep 2020 16:27:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天在使用 journalctl 查看 nginx 日志时看到在每次启动服务后会出现一条错误信息：$ journalctl -u nginx...nginx.service: Failed to...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天在使用 <code>journalctl</code> 查看 nginx 日志时看到在每次启动服务后会出现一条错误信息：</p><pre><code>$ journalctl -u nginx
...
nginx.service: Failed to parse PID from file /opt/nginx/logs/nginx.pid: Invalid argument
...
</code></pre><p>查找了下原因，可能是 nginx 在启动时创建 nginx.pid 文件前 systemd 就在请求这个文件，所以出错了。</p><p>解决办法就是题前手动创建 systemd 需要的文件：</p><pre><code>mkdir /etc/systemd/system/nginx.service.d
printf &quot;[Service]\nExecStartPost=/bin/sleep 0.1\n&quot; &gt; /etc/systemd/system/nginx.service.d/override.conf
systemctl daemon-reload</code></pre><p>以上处理就可以解决问题。</p><p>参考链接：<br><a href="https://bugs.launchpad.net/ubuntu/+source/nginx/+bug/1581864">https://bugs.launchpad.net/ubuntu/+source/nginx/+bug/1581864</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1763.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1763.html</wfw:commentRss>
</item>
<item>
<title>从源码编译安装 python</title>
<link>https://blog.niekun.net/archives/1758.html</link>
<guid>https://blog.niekun.net/archives/1758.html</guid>
<pubDate>Mon, 21 Sep 2020 16:35:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。</p><h3>下载源码包</h3><p>python 官网：<a href="https://www.python.org/">https://www.python.org/</a></p><p>当前最新版是 3.8.5，在这个页面找到地址：<a href="https://www.python.org/downloads/release/python-385/">https://www.python.org/downloads/release/python-385/</a></p><p><img src="https://blog.niekun.net/usr/uploads/2020/09/3204471917.jpg" alt="1.jpg" title="1.jpg"></p><!--more--><p>下载 tgz 压缩包到本地并解压：</p><pre><code>cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz</code></pre><h3>环境安装</h3><p>编译需要安装一些依赖：</p><pre><code>apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
</code></pre><h3>编译</h3><p>python 源码使用标准 GNU 编译系统，详细说明参考：<a href="https://blog.niekun.net/archives/883.html">https://blog.niekun.net/archives/883.html</a></p><p>将 python 安装到 <code>/opt</code> 目录，先创建文件夹：</p><pre><code>mkdir /opt/python3.8.5
</code></pre><p>然后配置 configure：</p><pre><code>cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \</code></pre><p>没有错误提示的话就开始编译和安装：</p><pre><code>make
make install
</code></pre><p>安装完成后测试执行：</p><pre><code>/opt/python3.8.5/bin/python3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>下面将可执行文件加入系统路径，创建软连接：</p><pre><code>ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
</code></pre><p>测试运行：</p><pre><code>python --version
</code></pre><h3>安装 pip</h3><p>源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。</p><p>官网：<a href="https://pip.pypa.io/en/stable/installing/">https://pip.pypa.io/en/stable/installing/</a></p><p>下载脚本到本地：</p><pre><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code></pre><p>使用刚才安装的 python 执行脚本：</p><pre><code>/opt/python3.8.5/bin/python3 get-pip.py
</code></pre><p>pip 的安装路径是 <code>/opt/python3.8.5/bin/</code>，测试命令：</p><pre><code>/opt/python3.8.5/bin/pip3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>添加软连接到系统路径：</p><pre><code>ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
</code></pre><p>测试命令：</p><pre><code>pip --version
</code></pre><h3>参考链接</h3><p><a href="https://docs.rstudio.com/resources/install-python-source/">https://docs.rstudio.com/resources/install-python-source/</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1758.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1758.html</wfw:commentRss>
</item>
</channel>
</rss>