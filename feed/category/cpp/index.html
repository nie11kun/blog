<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - c++</title>
<link>https://blog.niekun.net/category/cpp/</link>
<atom:link href="https://blog.niekun.net/feed/category/cpp/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Sat, 07 Nov 2020 15:53:00 +0800</lastBuildDate>
<pubDate>Sat, 07 Nov 2020 15:53:00 +0800</pubDate>
<item>
<title>C++ 入门教程 -- 判断及循环</title>
<link>https://blog.niekun.net/archives/1895.html</link>
<guid>https://blog.niekun.net/archives/1895.html</guid>
<pubDate>Sat, 07 Nov 2020 15:53:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[if 判断if 申明的使用场景：当一个判断条件达到是执行指令。语法结构：if (condition) {    statements}]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>if 判断</h3><p><code>if</code> 申明的使用场景：当一个判断条件达到是执行指令。</p><p>语法结构：</p><pre><code>if (condition) {
    statements
}</code></pre><!--more--><p>示例：</p><pre><code>if (7 &gt; 4) {
  cout &lt;&lt;  &quot;Yes&quot;; 
}

// Outputs &quot;Yes&quot;</code></pre><p>可以使用的相关性判断器：</p><ul><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li><li><code>==</code></li><li><code>!=</code></li></ul><p>当条件不满足是，也可以执行命令：</p><pre><code>if (condition) {
  //statements
}
else {
 //statements
}</code></pre><p>if else 指令可以多次嵌套使用：</p><pre><code>int age = 18;
if (age &gt; 14) {
  if(age &gt;= 18) {
    cout &lt;&lt; &quot;Adult&quot;;
  }
  else {
    cout &lt;&lt; &quot;Teenager&quot;;
  }
}
else {
  if (age &gt; 0) {
    cout &lt;&lt; &quot;Child&quot;;
  }
  else {
    cout &lt;&lt; &quot;Something's wrong&quot;;
  }
}</code></pre><p>当命令只有一句时可以省略大括号：</p><pre><code>int a = 10;
if (a &gt; 4)
  cout &lt;&lt; &quot;Yes&quot;;
else
  cout &lt;&lt; &quot;No&quot;;</code></pre><h3>while 循环</h3><p>一个 while 循环重复的执行设置的命令，直到设置的条件不满足为止。</p><p>语法：</p><pre><code>while (condition) {
   statement(s);
}</code></pre><p>示例：</p><pre><code>int num = 1;
while (num &lt; 6) {
  cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl;
  num = num + 1;
}</code></pre><p>当 num 变量小于 6 满足时，循环执行大括号内的指令，直到 num 的值大于等于 6 则跳出循环继续执行下面的指令。以上示例中当 num 第五次自加后结果为 6，则下一次循环开始时判断条件就为 false 了，就会跳出循环。</p><h3>for 循环</h3><p>for 循环指令可以实现指定循环次数，语法结构如下：</p><pre><code>for ( init; condition; increment ) {
  statement(s);
}</code></pre><ul><li>init 用来设置变量初值，且只设置一次</li><li>condition 用来给定执行循环的条件，满足则执行循环内指令</li><li>increment 设置循环条件的变量值如何变化</li></ul><p>示例：</p><pre><code>for (int x = 1; x &lt; 10; x++) {
 // some code
 }</code></pre><p>定义并设置 x 变量初值 1，循环条件是 x 小于 10，每次循环后 x 自加 1。</p><p>变量变化量可以自定：</p><pre><code>for (int a = 0; a &lt; 50; a+=10) {
  cout &lt;&lt; a &lt;&lt; endl;
}
/* Outputs
0
10
20
30
40
*/</code></pre><h3>do while 循环</h3><p>不同于 while 循环，do while 循环首先执行一次循环内的指令，再判断条件是否满足。</p><p>语法：</p><pre><code>do {
   statement(s);
} while (condition);</code></pre><p>示例：</p><pre><code>int a = 0;
do {
  cout &lt;&lt; a &lt;&lt; endl;
  a++;
} while(a &lt; 5);

/* Outputs
0
1
2
3
4
*/</code></pre><p>do while 即使条件不满足也至少会执行一次循环内的命令。</p><h3>switch 指令</h3><p>当需要根据一个变量值为不同的结果时执行不同的指令时可以使用 switch 指令。</p><p>语法：</p><pre><code>switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
    default:
    statement(s);
}</code></pre><p>当变量的值匹配到 <strong>switch</strong> 里定义的一个 value 值后，会执行此 case 下的指令。<br>使用 <strong>break</strong> 来跳出 switch 指令，如果不写的话会顺序执行下面的case 指令，即使变量值并没有匹配到这个 case。<br><strong>default</strong> 用来定义当以上设置的 case 都没有匹配上时执行的指令。</p><h3>逻辑操作符</h3><p>有三个逻辑操作符：</p><ul><li>&& 与</li><li>|| 或</li><li>!  非</li></ul><p>与指令：当两个条件都满足时为 true：</p><pre><code>int age = 20;
if (age &gt; 16 &amp;&amp; age &lt; 60) {
  cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted&quot;</code></pre><p>或指令：当任意一个条件满足时为 true：</p><pre><code>int age = 16;
int score = 90;
if (age &gt; 20 || score &gt; 50) {
    cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted!&quot;</code></pre><p>非指令：当条件不满足时为 true：</p><pre><code>int age = 10;
if ( !(age &gt; 16) ) {
  cout &lt;&lt; &quot;Your age is less than 16&quot; &lt;&lt; endl;
}

// Outputs &quot;Your age is less than 16&quot;</code></pre><p>以上就是常用的判断及循环指令用法。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1895.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1895.html</wfw:commentRss>
</item>
<item>
<title>C++ 入门教程 -- 基础概念</title>
<link>https://blog.niekun.net/archives/1894.html</link>
<guid>https://blog.niekun.net/archives/1894.html</guid>
<pubDate>Sat, 07 Nov 2020 15:13:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。下面用几篇文章介绍 c++ 的...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。</p><p>下面用几篇文章介绍 c++ 的基础用法。</p><!--more--><h3>结构</h3><p>c++ 程序是一个集成很多命令和描述的集合，以下是一个模板程序：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

// comment
int main()
{
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; &quot;WOW&quot; &lt;&lt; &quot;\n&quot;;
    return 0;
}
/*
comments
*/</code></pre><p>所有 c++ 程序的入口都是 <code>main()</code> function，使用大括号 <code>{}</code> 将 function 的内容包围起来，括号内的指令在 fuction 运行时执行。每句指令结尾使用分号<code>;</code> 结束。</p><p><code>cout</code> 是 <code>iostream</code> 的一个 object，功能是输出信息到标准的输出设备，一般是显示屏上。<code>&lt;&lt;</code> 是 insertion operator 用来将后面的字符串传入 cout 指令最后输出到显示屏。可以使用多个 <code>&lt;&lt;</code> 将信息连起来。</p><p><code>iostream</code> 是头文件，里面包含各种程序执行需要的功能模块，使用 <code>#include</code> 调用头文件。iostream 包含输入输出数据块的 stream object。</p><p>每个 <code>namespace</code> 是一个申明区域，定义了程序调用 function 或 object 时的类型，<code>using namespace std</code> 告诉程序默认使用 <code>std</code> 类型的元素。在命令中可以直接写 std 中定义的元素：</p><pre><code>cout &lt;&lt; &quot;Hello world!&quot;;
std::cout &lt;&lt; &quot;Hello world!&quot;;</code></pre><p>以上两种写法效果是一样的，表示使用  std 类型的 cout 指令。</p><p>也可以写自定义的申明如：</p><pre><code>namespace fs = boost::filesystem;
fs:path testpath;
</code></pre><p>以上申明意思是用 <code>fs</code> 表示 <code>boost::filesystem</code> 类型，然后定义一个 <code>boost::filesystem::path</code> 类型的变量。</p><p>cout 执行后默认不添加行结束符号，添加一个 <code>endl</code> object 来实现换行操作。也可以添加字符串 <code>\n</code> 表示换行。</p><p>反斜杠 <code>\</code> 是转义符用来输入特殊意义的符号，如：<code>\n</code> 表示换行。</p><p><code>//</code> 双斜杠用来添加单行注释信息，斜杠所在的行不会被编译。<br><code>/*....*/</code> 用来表示注释区域，这一段的内容都不被编译。</p><h3>变量</h3><p>定义一个变量会请求一个内存空间来存储变量值。编译器需要在定义变量时指定变量类型，类型可以是系统内置的也可以是自定义的。定义的个体可以是变量，function，class 等：</p><pre><code>int testVar = 10;
</code></pre><p>以上定义了一个 int 整数型的变量 testVar 并赋值为 10，注意变量名是区分大小写的，也就是 testVar 和 testvar 代表两个不同的变量。</p><pre><code>double testDouble1, testDouble2;
</code></pre><p>也可以同时定义两个变量。</p><p><strong>根据需求设置变量类型，可以优化内存占用空间。</strong></p><p>示例：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int a = 30;
    int b = 12;
    int sum = a + b;
    cout &lt;&lt; sum;
    return 0;
}
//Outputs 42</code></pre><p>定义的变量可以在后续程序中赋值：</p><pre><code>int a;
int b = 1;

a = 2;
b = 3;</code></pre><h3>输入参数</h3><p>使用 <code>cin</code> 来请求用户输入数据，用 extraction operator 来将输入数据提取到别处：</p><pre><code>int a;
cin &gt;&gt; a;</code></pre><p>以上程序定义一个 int 型变量，然后提示用户输入一个数据存储到变量 a 中。</p><p>结合输入输出可以实现简单的交互操作：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

int main() 
{
  int a, b;
  int sum;
  cout &lt;&lt; &quot;Enter a number \n&quot;;
  cin &gt;&gt; a;
  cout &lt;&lt; &quot;Enter another number \n&quot;;
  cin &gt;&gt; b;
  sum = a + b;
  cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; endl;

  return 0;
}</code></pre><h3>运算符</h3><p>c++ 支持以下运算符：</p><ul><li><ul><li>加</li></ul></li><li><ul><li>减</li></ul></li><li><ul><li>乘</li></ul></li><li>/ 除</li><li>% 模(整除后的余数)</li></ul><pre><code>int a = 1 + 1;
int b = 5 * 6;
int c = 5 % 2;
int d = 5 + 2 * 2;
int e = (5 + 2) * 2;

cout &lt;&lt; c &lt;&lt; endl;

//output: 1</code></pre><p>如果对变量本身的加减乘除操作可以简写：</p><pre><code>x *= 3; // equivalent to x = x * 3
x /= 2; // equivalent to x = x / 2
x %= 4; // equivalent to x = x % 4</code></pre><p>对本身自加或自减操作，有两种方式：后缀和前缀：</p><pre><code>x++; //后缀，相当于 x = x + 1
x--;
++x;
--x;
</code></pre><p>使用后缀方式是先执行表达式再自加，前缀方式是先自加再执行表达式：</p><pre><code>int a = 1;
int b = a++;
int c = ++a;

//b = 1
//c = 3</code></pre><p>以上是基础概念及指令。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1894.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1894.html</wfw:commentRss>
</item>
<item>
<title>Windows 下编译 boost 静态库</title>
<link>https://blog.niekun.net/archives/1174.html</link>
<guid>https://blog.niekun.net/archives/1174.html</guid>
<pubDate>Thu, 27 Feb 2020 13:39:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[boost 是很流行的一个 c++ 库，他的部分模块使用只需要引用 head 文件即可，部分需要编译链接库才能使用。下面介绍如何编译模块的静态链接库。官方网站：https://www.boost...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://niekun.net/usr/uploads/2020/02/2617505775.png" alt="2020-02-27T01:06:24.png" title="2020-02-27T01:06:24.png"></p><p>boost 是很流行的一个 c++ 库，他的部分模块使用只需要引用 head 文件即可，部分需要编译链接库才能使用。下面介绍如何编译模块的静态链接库。</p><p>官方网站：<a href="https://www.boost.org/">https://www.boost.org/</a><br>开始教程：<a href="https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html">https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html</a><br>官方编译教程：<a href="https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#prepare-to-use-a-boost-library-binary">https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#prepare-to-use-a-boost-library-binary</a><br>关于 B2 编译系统：<a href="https://boostorg.github.io/build/">https://boostorg.github.io/build/</a><br>关于 Microsoft Visual C++(MSVC) 版本号：<a href="https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering">https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering</a><br>关于静态库和动态库：</p><!--more--><h3>boost 库下载</h3><p>从官方链接下载最新版 boost 库：<a href="https://www.boost.org/users/download/">https://www.boost.org/users/download/</a></p><p>解压到磁盘目录，最好放置在单独管理软件环境库的目录，方便管理。</p><p>需要编译库文件才能使有的模块如下：</p><pre><code>    - atomic
    - chrono
    - container
    - context
    - contract
    - coroutine
    - date_time
    - exception
    - fiber
    - filesystem
    - graph
    - graph_parallel
    - headers
    - iostreams
    - locale
    - log
    - math
    - mpi
    - program_options
    - python
    - random
    - regex
    - serialization
    - stacktrace
    - system
    - test
    - thread
    - timer
    - type_erasure
    - wave</code></pre><h3>编译器配置</h3><p>各平台支持的编译器类型：<a href="https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#identify-your-toolset">https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#identify-your-toolset</a></p><p>Windows 下支持的编译器是：gcc 和 msvc，我电脑安装的是 visual studio 2019 的 c++ 开发包，所以我使用 msvc 作为编译器。</p><p>使用 msvc 编译，需要在 c++ 开发包的基础上在 visual studio installer 里安装 Windows CRT SDK，不然在执行 bootstrap 时会报错：<br><img src="https://niekun.net/usr/uploads/2020/02/2125873377.png" alt="2020-02-27T01:24:42.png" title="2020-02-27T01:24:42.png"></p><p>booost 支持指定 msvc 版本，所以首先查看我安装的 msvc 版本，可以在 visual studio installer 里查看当前安装的 msvc：<br><img src="https://niekun.net/usr/uploads/2020/02/67995277.png" alt="2020-02-27T01:23:36.png" title="2020-02-27T01:23:36.png"></p><p>或者可以通过 VS 版本号来查询 msvc 版本：<a href="https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering">https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering</a></p><p>打开 boost 文件夹目录下的 bootstrap.bat 可以看到在执行脚本时也可以通过参数指定 msvc 版本：</p><pre><code>SET TOOLSET=msvc

IF &quot;%1&quot;==&quot;gcc&quot; SET TOOLSET=gcc

IF &quot;%1&quot;==&quot;vc71&quot; SET TOOLSET=msvc : 7.1
IF &quot;%1&quot;==&quot;vc8&quot; SET TOOLSET=msvc : 8.0
IF &quot;%1&quot;==&quot;vc9&quot; SET TOOLSET=msvc : 9.0
IF &quot;%1&quot;==&quot;vc10&quot; SET TOOLSET=msvc : 10.0
IF &quot;%1&quot;==&quot;vc11&quot; SET TOOLSET=msvc : 11.0
IF &quot;%1&quot;==&quot;vc12&quot; SET TOOLSET=msvc : 12.0
IF &quot;%1&quot;==&quot;vc14&quot; SET TOOLSET=msvc : 14.0
IF &quot;%1&quot;==&quot;vc141&quot; SET TOOLSET=msvc : 14.1
IF &quot;%1&quot;==&quot;vc142&quot; SET TOOLSET=msvc : 14.2</code></pre><h3>编译模块</h3><p>首先通过 boost 文件夹目录下的 <strong>bootstrap.bat</strong> 来安装 Boost.Build (b2) 编译工具。</p><p>关于什么是 Boost.Build (b2) 参考：<a href="https://boostorg.github.io/build/">https://boostorg.github.io/build/</a></p><p>使用 vc++ 的终端来执行脚本如 native tool cmd，也可以在终端下指定 msvc 版本来编译，将目录 cd 到 boost 目录然后运行 bootstrap，使用 vc142 作为参数：<br><img src="https://niekun.net/usr/uploads/2020/02/3871338465.png" alt="2020-02-27T01:34:41.png" title="2020-02-27T01:34:41.png"></p><p>如果出错，会在 boost 目录下生成 bootstrap.log 文件，查看具体出错信息。</p><p>成功执行后在 boost 目录会有一个 b2.exe 文件，执行 .\b2 --help 可以查看帮助，下面需要这个 b2 来编辑模块库文件。</p><p>再次打开终端，切换到 boost 目录，运行下面的命令：</p><pre><code>cd \TOYOURBOOSTPATH
b2 --toolset=msvc-14.2 link=static runtime-link=static --build-type=complete stage
</code></pre><p><strong>--toolset=msvc-14.2</strong>       定义了编译器名称<br><strong>link=static</strong>               定义了链接库为静态，就是将链接库本身编译为静态的<br><strong>runtime-link=static</strong>       定义了运行链接库为静态，就是程序使用此库打包时为静态的<br><strong>--build-type=complete</strong> 定义了编译所有支持的变种库<br><strong>stage</strong>                 定义了库文件路径：<strong>.\stage\lib</strong>。想要更换其他路径使用 <strong>--stagedir=directory</strong> 参数来定义</p><p>关于 link 和 runtime-link 参考：<a href="https://www.quora.com/What-is-the-difference-between-static-runtime-and-dynamic-linking">https://www.quora.com/What-is-the-difference-between-static-runtime-and-dynamic-linking</a></p><p>其他可用的参数使用 <strong>b2 --help</strong> 来查看。</p><p>成功编译完成后，链接库文件在 <strong>.\stage\lib\</strong> 目录下。</p><h3>boost 库的使用</h3><p>使用 boost 库需要将 head 头文件文件夹和 lib 链接库文件夹在编译器里指定。</p><p>官方手册：<a href="https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#link-your-program-to-a-boost-library">https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#link-your-program-to-a-boost-library</a></p><p>head 文件夹路径：PathTo\boost_1_72_0\boost<br>lib 库文件夹路径：PathTo\boost_1_72_0\stage\lib</p><p><strong>下面介绍在 visual studio 2019 如何使用 boost。</strong></p><p>打开 c++ 项目文件，在右侧 <strong>solution explorer</strong> 中，在项目名右键点击 <strong>properties</strong> 或者 快捷键 alt + enter：<br><img src="https://niekun.net/usr/uploads/2020/02/1425466925.png" alt="2020-02-27T05:27:40.png" title="2020-02-27T05:27:40.png"></p><p>选择 <strong>c/c++ - general</strong>，右侧菜单 <strong>additional include directories</strong> 中输入 boost 根路径：<br><img src="https://niekun.net/usr/uploads/2020/02/2349038897.png" alt="2020-02-27T05:29:56.png" title="2020-02-27T05:29:56.png"></p><p>选择 <strong>linker - general</strong>，右侧菜单 <strong>additional library directories</strong> 中输入 lib 路径，来包含 lib 库文件：<br><img src="https://niekun.net/usr/uploads/2020/02/1912327834.png" alt="2020-02-27T05:33:05.png" title="2020-02-27T05:33:05.png"></p><p>由于我们编译的是静态链接库，所以需要将 runtime library 设置为静态，选择 <strong>c/c++ - code generation</strong>，右侧菜单 <strong>runtime library</strong> 选择 <strong>MT/MTD</strong>，MT 代表 release，MTD 代表 debug：<br><img src="https://niekun.net/usr/uploads/2020/02/2344815031.png" alt="2020-02-27T05:36:13.png" title="2020-02-27T05:36:13.png"></p><p>以上就把 boost 连接到了环境中，使用只需要 include 需要的模块即可，例如：</p><pre><code>#include &quot;boost/filesystem.hpp&quot;

</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1174.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1174.html</wfw:commentRss>
</item>
<item>
<title>boost库里使用path的指针问题</title>
<link>https://blog.niekun.net/archives/95.html</link>
<guid>https://blog.niekun.net/archives/95.html</guid>
<pubDate>Thu, 21 Feb 2019 14:03:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[近期在开发过程中遇到一个奇怪的问题，当我复制一个文件夹到新目录时候总是失败，查看日志发现是传递地址出错了。我是使用的是Boost的filesystem C++库处理文件，下面是代码片段，将pat...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>近期在开发过程中遇到一个奇怪的问题，当我复制一个文件夹到新目录时候总是失败，查看日志发现是传递地址出错了。<br>我是使用的是Boost的filesystem C++库处理文件，下面是代码片段，将path类型的地址放入一个指针，然后调用其他function：</p><pre><code>fs::path childDir = np;
childDir += &quot;/\\&quot; + dir_itr-&gt;path().filename().string();
const char* c_childDir = childDir.string().c_str();
</code></pre><p>我在本机实验是没有问题，但在他人电脑上提示directory error。<br>我将path里的地址先存放到一个string里然后在转换为char*，发现问题解决了。<br>我想可能的原因就是path不能直接使用其指针地址。下面是修改后的程序片段：</p><pre><code>string s_childDir = newDir;
s_childDir += &quot;/\\&quot; + dir_itr-&gt;path().filename().string();
const char* c_childDir = s_childDir.c_str();
</code></pre><p>以上就是关于boost库里使用path的指针问题的解决方法。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/95.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/95.html</wfw:commentRss>
</item>
</channel>
</rss>