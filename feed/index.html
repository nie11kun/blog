<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<atom:link href="https://blog.niekun.net/feed/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description>you are the company you keep...</description>
<lastBuildDate>Thu, 04 Feb 2021 21:36:00 +0800</lastBuildDate>
<pubDate>Thu, 04 Feb 2021 21:36:00 +0800</pubDate>
<item>
<title>node.js 入门教程之四 -- Event Loop</title>
<link>https://blog.niekun.net/archives/2100.html</link>
<guid>https://blog.niekun.net/archives/2100.html</guid>
<pubDate>Thu, 04 Feb 2021 21:36:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Event Loop 事件循环event loop 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>Event Loop 事件循环</h3><p><strong>event loop</strong> 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node.js 能够变得如此流行的原因之一。</p><p>node.js 代码运行在单进程中，也就是说它在一刻只能执行一个任务。这一限制特性使得我们不用担心任务间冲突问题。我们在变开发中只需要专注于代码本身，同时应避免进程阻塞，例如同步方式等待网络请求，死循环等。</p><p>通常情况下，浏览器中的每个 tab 页面都是都有各自独立的 event loop，防止某个页面的死循环或过高的资源消耗影响到整个浏览器的体验。我们只需要关注于我们的代码运行在一个单一的 event loop 中，编程中要注意到这一点，防止进程阻塞。</p><!--more--><p>JavaScript 代码中如果有长时间等待 return 返回给 event loop 控制时，任何其他代码将会被阻塞，也会阻塞页面 UI 单元，用户在此期间无法进行点击，滚动等操作。</p><p>几乎所有的 JavaScript 原生 IO 指令都是 non-blocking 非阻塞式的，例如：网络请求，文件读写等，阻塞是一种 exception 例外情况，这也是 JavaScript 大量的使用 callback 方式，以及最近引入的 promise 和 async/await。</p><h4>call stack 调用结构</h4><p>JavaScript 的 call 调用过程的结构遵循 LIFO (Last In, First Out)，也就是总是先响应最近的任务。</p><p>event loop 总是连续的检查 call stack 看是否有任务需要执行。在这个过程中，它会将发现的任务添加到 call stack 中并按顺序执行。</p><p>下面是一个简单的示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    bar();
    baz();
}

foo();

//output:
//foo
//bar
//baz</code></pre><p>在以上示例中，首先会调用 foo()，在 foo 中首先会调用 bar()，然后调用 baz()。call stack 执行过程如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2945905311.png" alt="2021-02-02T13:21:33.png" title="2021-02-02T13:21:33.png"></p><p>在 event loop 的每次 iteration 递归执行中会查询 call stack 中是否有需要执行的任务，如果有则执行它，直到 loop 结束为止，如下是循环中的全过程：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/627372670.png" alt="2021-02-02T13:23:25.png" title="2021-02-02T13:23:25.png"></p><p>以上示例说明了 JavaScript 在一般情况下按顺序执行代码的过程。下面介绍如何将一个 function 推迟到 call stack 递归到最后时再被调用。</p><p>需要使用以下的代码指令：</p><pre><code>setTimeout(() =&gt; {}, 0)
</code></pre><p>以上代码调用了 setTimeout 延时 function，但是将延时设置为 <code>0</code>，这样的意义就是要求它在可以执行的时候立刻执行其中定义的 function。那么如何才能让其在层级的最后再执行 function 呢？下面是一个完整的片段：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    baz();
}

foo();

//output:
//foo
//baz
//bar</code></pre><p>以上示例中，我们在 foo 中先调用 setTimeout function，并将时间设置为 0，要求其在可以执行时立刻执行内部定义的指令，以上示例循环的 call stack 过程如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/281898740.png" alt="2021-02-04T12:49:01.png" title="2021-02-04T12:49:01.png"></p><p>下面时循环的顺序执行全过程：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2606253446.png" alt="2021-02-04T12:50:30.png" title="2021-02-04T12:50:30.png"></p><p>为什么会是这样的执行顺序呢？为什么 setTimeout 时间设置为 0 反而最后才执行其 function？下面做介绍。</p><h4>Message Queue 消息队列</h4><p>当 <code>setTimeout()</code> 被调用时，浏览器或 node.js 会开启一个定时器，当定时时间到达时，这里我们设置为 0 也就是立刻到达了时间，callback 响应的 function 会被放到 Message Queue 消息队列中。</p><p>Message Queue 消息队列也管理着用户主动触发的一些事件如鼠标点击键盘输入等，或者 fetch 获取响应信息，这些消息按顺序排列着等待被代码执行。</p><p><strong>call stack</strong> 和 <strong>Message Queue</strong> 是互相独立的，event loop 循环时 call stack 中的任务是优先的，它会首先查找 call stack 中需要执行的代码并按顺序执行，当 satck 执行完成后再去查看 Message Queue 中需要处理的任务。</p><p>我们并不需要等待一些 functions 如 setTimeout 或 fetch 这些任务的执行过程，因为这些工作由浏览器提供且这些任务运行在它们单独的线程中。例如当我们设置了 setTimeout 2 秒的定时，我们并不需要停下来等待这 2 秒钟，而是会执行层级中接下来的指令。</p><h4>Job Queue 任务队列</h4><p>ES6 中引入了一种新的 <strong>Job Queue</strong> 任务队列概念，也就是 <strong>Promise</strong>。提供了在条件到达后立刻执行被调用 function 的方法，而不是等待到 call stack 结束。</p><p>当 <strong>Promise</strong> 定义的 <strong>resolve</strong> 条件满足时，会在当前 function 执行结束后立刻执行 <strong>resolve</strong> function。</p><p>简单的区分 <strong>Message Queue</strong> 和 <strong>Job Queue</strong>：<strong>Message Queue</strong> 会将出现的每个任务按顺序排列到队列最后，等待排队执行。而 <strong>Job Queue</strong> 就像拿到了快捷车票，会在前一个指令结束后立刻跳转到这个任务上来。</p><p>下面是一个示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();

//output:
//foo
//baz
//should be right after baz, before bar
//bar</code></pre><p>以上示例可以看到，<strong>promise</strong> 定义之后会运行 <strong>baz</strong> function，然后 <strong>promise</strong> 的 <strong>resolve</strong> 条件会立刻得到满足，此时异步任务会在 <strong>baz</strong> 执行结束后立刻被响应而不是排列到队列最后。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2100.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2100.html</wfw:commentRss>
</item>
<item>
<title>Windows 10 配置共享文件夹</title>
<link>https://blog.niekun.net/archives/2103.html</link>
<guid>https://blog.niekun.net/archives/2103.html</guid>
<pubDate>Wed, 03 Feb 2021 10:28:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近研究了下 Windows 的共享设置，目的是在同一局域网下共享文件夹给其他设备读写。下面从原理和实际操作上介绍下共享过程。SMBWindows 共享使用 Server Message Blo...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近研究了下 Windows 的共享设置，目的是在同一局域网下共享文件夹给其他设备读写。下面从原理和实际操作上介绍下共享过程。</p><h3>SMB</h3><p>Windows 共享使用 Server Message Block (SMB) 协议，它可以让应用程序访问本机网络下的其他设备的文件及服务。</p><p>SMB 是 IBM 在 1980 年代创造的协议，目前已经有了很多的升级及分支。</p><p>SMB 协议允许应用程序访问远程主机的文件和资源如打印机等，也可以同远程主机上设置了接收 SMB 协议的应用程序通信。它运行在网络的 layer 7 层，也就是 application 应用层，使用 TCP/IP 的 445 端口传输数据。</p><p>从 Windows 95 开始，微软将引入了 SMB 协议的支持。Linux 端，samba 作为一个开源软件提供 SMB 的支持。</p><!--more--><p>SMB 协议也是在不断发展的，下面是一个简单的版本更新过程：</p><ul><li>SMB 1.0 (1984): IBM 为 DOS 下的文件共享创造了 SMB</li><li>CIFS (1996): 微软开发了 SMB 的分支版本并集成在 Windows 95，添加了大文件的支持，直接在 TCP/IP 传输</li><li>SMB 2.0 (2006): 在 Windows Vista 和 Windows Server 2008 中发布. 提升了性能</li><li>SMB 2.1 (2010): 在 Windows Server 2008 R2 和 Windows 7 中发布</li><li>SMB 3.0 (2012): 在 Windows 8 和 Windows Server 2012 中发布. 提升了性能，增加备份，安全和管理功能</li><li>SMB 3.02 (2014): 在 Windows 8.1 和 Windows Server 2012 R2 中发布. 提升性能并完全停止支持 CIFS/SMB 1.0</li><li>SMB 3.1.1 (2015): 在 Windows 10 和 Windows Server 2016 中发布</li></ul><p>在 2017 年，利用 SMB 1.0 的漏洞，WannaCry 勒索软件在互联网中大规模传播，微软虽然立刻发布了补丁，但专家还是建议立刻停止运行 SMB 1.0 协议。</p><h3>Windows 设置共享</h3><p>下面介绍在 Windows 10 中配置共享文件夹。</p><p>首先打开控制面板，进入 network and Internet：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3484356955.jpg" alt="1.jpg" title="1.jpg"></p><p>点击 network and sharing center：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/1555287216.jpg" alt="2.jpg" title="2.jpg"></p><p>点击 change advanced sharing settings：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3540072456.jpg" alt="3.jpg" title="3.jpg"></p><p>在 current profile 中打开网络发现和文件共享：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/87039655.jpg" alt="4.jpg" title="4.jpg"></p><p>然后在 all network 中关闭密码保护(否则在其他设备访问时会提示输入账户密码)：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/368588129.jpg" alt="5.jpg" title="5.jpg"></p><p>控制面板配置完成后，我们开始配置需要共享的文件夹。</p><p>在需要共享的文件夹上点击右键，选择属性：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/244669714.jpg" alt="6.jpg" title="6.jpg"></p><p>在 share 选项卡中点击 share：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3905984961.jpg" alt="7.jpg" title="7.jpg"></p><p>在下拉菜单中选择 everyone，然后点击 add：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/1822670699.jpg" alt="8.jpg" title="8.jpg"></p><p>修改此文件夹的读写权限，我这里设置读和写：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3658771641.jpg" alt="9.jpg" title="9.jpg"></p><p>点击 share 开启共享：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3388059287.jpg" alt="10.jpg" title="10.jpg"></p><p>返回属性栏，点击 advanced share：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/1235392306.jpg" alt="11.jpg" title="11.jpg"></p><p>选中 share this folder：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2162677218.jpg" alt="12.jpg" title="12.jpg"></p><p>点击 permission：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2270117126.jpg" alt="13.jpg" title="13.jpg"></p><p>设置共享权限，我这里设置为可读写：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2247707898.jpg" alt="14.jpg" title="14.jpg"></p><p>确认后共享文件夹就配置完成了。</p><h3>访问共享文件</h3><p>下面介绍在其他局域网设备访问主机的共享文件夹。</p><h4>Windows</h4><p>在 Windows 上，打开 file explorer，点击 network：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3714944153.jpg" alt="15.jpg" title="15.jpg"></p><p>在右侧就是本地网络下启用了网络发现的设备列表，点击进入设置了共享文件夹的设备名称就可以访问了：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/1841189733.jpg" alt="16.jpg" title="16.jpg"></p><p>也可以在地址栏直接输入共享路径地址，以双反斜线<code>\\</code>开头后面是设备 IP 或名称，如：<code>\\DESKTOP-BS3C55D</code>。</p><p>关于设备的名称，可以在终端通过 <code>whoami</code> 命令查询：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/969206228.jpg" alt="17.jpg" title="17.jpg"></p><h4>iPhone</h4><p><strong>在支持 SMB 协议的设备或应用程序中都可以打开 Windows 共享的文件</strong>，下面介绍通过 iPhone 的 files app 来连接到 Windows 共享目录。</p><p><strong>打开 files app，点击右上角的 <code>...</code> 选择 connect to server：</strong><br><img src="https://blog.niekun.net/usr/uploads/2021/02/765618703.jpg" alt="IMG_3227.jpg" title="IMG_3227.jpg"></p><p><strong>在 server 中输入共享主机的地址，这里直接输入 IP 地址：</strong><br><img src="https://blog.niekun.net/usr/uploads/2021/02/323133738.png" alt="IMG_3229.PNG" title="IMG_3229.PNG"></p><p><strong>选择 guest 点击 next：</strong><br><img src="https://blog.niekun.net/usr/uploads/2021/02/2346742928.png" alt="IMG_3230.PNG" title="IMG_3230.PNG"></p><p><strong>完成后就可以访问到共享目录了：</strong><br><img src="https://blog.niekun.net/usr/uploads/2021/02/989176749.png" alt="IMG_3232.PNG" title="IMG_3232.PNG"></p><p>如果文件夹设置的是可读写权限，就可以在手机上传输文件到共享目录了。</p><p>参考链接：<br><a href="https://searchnetworking.techtarget.com/definition/Server-Message-Block-Protocol">Server Message Block Protocol (SMB protocol)</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2103.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2103.html</wfw:commentRss>
</item>
<item>
<title>解除 UWP 应用的网络隔离</title>
<link>https://blog.niekun.net/archives/2098.html</link>
<guid>https://blog.niekun.net/archives/2098.html</guid>
<pubDate>Tue, 02 Feb 2021 09:33:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Microsoft store 里都是 UWP 应用，运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Microsoft store 里都是 UWP 应用，运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。该机制也阻止了 UWP 应用访问 localhost，如果你的代理地址在本地地址，UWP 就无法访问。</p><p>有两种方法来解除某个 UWP 应用的沙盒隔离，一种是使用系统自带的工具 <strong>CheckNetIsolation</strong>，一种是使用第三方工具 <strong>fiddler</strong>。</p><h3>CheckNetIsolation</h3><p>Windows 10 自带了一个 CheckNetIsolation 工具，可以解除 UWP 应用的网络隔离，使之可以正常访问本地地址在终端执行以下指令即可：</p><pre><code>CheckNetIsolation.exe loopbackexempt -a -p=SID
</code></pre><p>SID(security identifier) 是每个 UWP 应用独有的识别码，可以从注册表中获得应用的 SID 码。</p><!--more--><p>快捷键 win + R 打开运行窗口，输入 regedit 进入注册表。访问如下路径：<code>\HKEY_CURRENT_USER\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\</code>：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3861334125.jpg" alt="1.jpg" title="1.jpg"></p><p>此路径下的左侧文件夹名称就是当前安装的每个 UWP 应用的 SID 码，右侧的 DisplayName 就是应用的名称，可以用来帮助找到需要的应用 SID。</p><p>复制需要解除隔离的应用的 SID 码执行上面的命令即可。然后应用就可以正常访问本地地址了，也可以使用抓包工具获取到流量。</p><h3>fiddler</h3><p>也可以使用第三方软件来实现以上任务，这里介绍 fiddler。</p><p>fiddler 是一款免费的网络调试代理工具。官网地址：<a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></p><p>下载安装后打开应用，点击左上角的 WinConfig：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/186160648.jpg" alt="2.jpg" title="2.jpg"></p><p>会弹出所有 UWP 应用列表，找到需要解除隔离的应用，点击左侧的选择框，然后点击 save change 即可：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2421167178.jpg" alt="3.jpg" title="3.jpg"></p><p>此时再次运行对应的应用，就可以在 fiddler 看到应用的流量信息了。<strong>注意 fiddler 需要一直保持开启状态解除隔离才会生效。</strong></p><p>使用 fiddler 还可以方便的设置代理服务，使选中的应用通过代理访问网络，点击 tools - options：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3134568243.jpg" alt="4.jpg" title="4.jpg"></p><p>在弹出栏中，点击 gateway，选择 manual proxy configuration：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3205051089.jpg" alt="5.jpg" title="5.jpg"></p><p>第一行设置代理地址，模式为：</p><pre><code>proxyserver:8080
</code></pre><p>也可以根据网络协议设置：</p><pre><code>http=httpproxy:8080;https=httpsproxy:8080
</code></pre><p>第二行设置 bypass 忽略列表，可以设置忽略代理本地地址或其他需要排除的地址：</p><pre><code>&lt;local&gt;;*.extranet.example.com;
</code></pre><p>点击 ok 保存后即可，此时在 WinConfig 中选中的 UWP 应用就会通过代理地址访问网络。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2098.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2098.html</wfw:commentRss>
</item>
<item>
<title>创建新文件 in Linux</title>
<link>https://blog.niekun.net/archives/2086.html</link>
<guid>https://blog.niekun.net/archives/2086.html</guid>
<pubDate>Thu, 28 Jan 2021 08:17:25 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[下面介绍几种常用的命令行创建新文件的方法。touch：touch test1.txt&gt;:&gt; test2.txtcat:cat /dev/null &gt; test3.txtecho...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>下面介绍几种常用的命令行创建新文件的方法。</p><p><strong>touch</strong>：</p><pre><code>touch test1.txt
</code></pre><p><strong>&gt;</strong>:</p><pre><code>&gt; test2.txt
</code></pre><p><strong>cat</strong>:</p><pre><code>cat /dev/null &gt; test3.txt
</code></pre><p><strong>echo</strong>:</p><pre><code>echo &gt; test4.txt
</code></pre><p><strong>vim</strong>:</p><pre><code>vim test5.txt
:wq
</code></pre><p>使用中选择最简单的方式即可。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2086.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2086.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之三 -- npm</title>
<link>https://blog.niekun.net/archives/2085.html</link>
<guid>https://blog.niekun.net/archives/2085.html</guid>
<pubDate>Tue, 26 Jan 2021 15:45:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[调用 node.js 文件node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。语法如下：const libra...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>调用 node.js 文件</h3><p>node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。</p><p>语法如下：</p><pre><code>const library = require('./libs')</code></pre><p>和导入其他第三方模块类似使用 <strong>require</strong> 指令，需要指定 node.js 文件路径。以上示例表示导入当前目录下的 <strong>libs.js</strong> 文件。</p><p>js 文件中默认定义的 objects 等元素是私有的，不能够被外部使用。在被导入的文件中，需要在引用前 expose 暴漏出需要被外部使用的功能。需要使用到 module system 的 <strong>module.exports</strong> API 来实现。</p><!--more--><p>当给一个 <strong>object</strong> 或 <strong>function</strong> 赋予 <strong>exports</strong> 属性时，就表明这些元素可以暴漏给外部。<strong>有两种方法来实现</strong>。</p><p><strong>第一种方法</strong>是将某个 object 直接赋值给 <strong>module.exports</strong>，<strong>module.exports</strong> 是 module system 的一个 object 用来将某个 object 暴漏出来，且只能在一个文件中赋值给某一个元素，下面是一个示例：</p><p><strong>libs.js</strong> 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}

module.exports = person;</code></pre><p><strong>main.js</strong> 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.age);

//OUTPUT:
//20</code></pre><p>上面示例中，我们将 <strong>libs.js</strong> 文件的 <strong>person</strong> object 赋值给了 <strong>module.exports</strong>，在 <strong>main.js</strong> 中调用 <strong>libs.js</strong> 文件后，<strong>main.js</strong> 中的 <strong>libs</strong> object 就相当于 <strong>person</strong> object。</p><p>我们可以发现，这种定义方法可以将某个 node.js 文件中的一个 object 暴漏给外部使用。</p><p><strong>第二种方法</strong>是将需要暴漏的元素定义为 <strong>exports</strong> 的 properties，这种方式可以将多个 objects 或 function 暴漏给外部。</p><p>libs.js 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}
exports.person = person;

exports.car = {
    brand: 'bmw',
    color: 'red'
}</code></pre><p>main.js 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.person.age);
console.log(libs.car.brand);

//OUTPUT:
//20
//bmw</code></pre><p>以上示例中，我们先在 <strong>libs.js</strong> 中定义了两个 object，并都作为 <strong>exports</strong> 的一个 property，可以看到有两种方式定义。在 <strong>main.js</strong> 中调用后，通过调用 <strong>libs</strong> object 对应的 properties 名称即可调用对应暴露的元素。</p><h3>npm 包管理器</h3><p><strong>npm</strong> 是 <strong>node.js</strong> 的标准包管理器。</p><p>一开始，npm 作为下载和管理 node.js 包的依赖的工具，现在也成为了 JavaScript 前端开发工具。</p><h4>下载包</h4><p>如果项目中有 <strong>package.json</strong> 文件，可以通过下面指令自动安装所有在文件中定义的模块，安装路径为 <strong>node_modules</strong> 文件夹内：</p><pre><code>npm install
</code></pre><p>安装某一个模块包：</p><pre><code>npm install &lt;package-name&gt;
</code></pre><p>在项目中安装的包会自动添加条目到 <strong>package.json</strong> 文件中。也可以在安装时使用 <code>--save</code> 选项来添加到文件。</p><h4>更新包</h4><p>更新项目中所有包：</p><pre><code>npm update
</code></pre><p>更新某一个包：</p><pre><code>npm update &lt;package-name&gt;
</code></pre><h4>执行任务</h4><p><strong>package.json</strong> 文件内支持定义指定的命令行指令，通过下面的语法来执行：</p><pre><code>npm run &lt;task-name&gt;
</code></pre><p>指令定义在 <strong>scripts</strong> 块内，例如：</p><pre><code>{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;
  }
}</code></pre><p>此时我们在终端执行下面命令：</p><pre><code>$ npm run start
Debugger attached.

&gt; start
&gt; uname -r

5.8.0-38-generic
Waiting for the debugger to disconnect...</code></pre><p>可以看到通过 run 定义命令的名称就可以执行对应的命令。</p><h4>包安装路径</h4><p>当使用 npm 安装包时，可以定义两种安装模式：</p><ul><li>local install 逻辑安装</li><li>global install 全局安装</li></ul><p>默认情况下当我们使用下面指令安装包：</p><pre><code>npm install chalk
</code></pre><p>包会安装到当前项目路径下的 node_modules 文件夹内。此时 npm 会将对应包的信息写入 <strong>package.json</strong> 文件内的 <strong>dependencies</strong> 块内，如：</p><pre><code>{
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }
}</code></pre><p>全局安装通过 <code>-g</code> 标记实现：</p><pre><code>npm install -g chalk
</code></pre><p>使用全局安装模式时，npm 不会将包安装到项目路径下，而是 <strong>global</strong> location 路径下。通过 <code>npm root -g</code> 命令可以返回 golbal 路径的地址，Linux 默认地址为：<code>/usr/local/lib/node_modules</code>，Windows 默认地址为：<code>C:\Users\YOU\AppData\Roaming\npm\node_modules</code>。</p><h4>可执行程序</h4><p>当安装一个包后，我们通过 <strong>require</strong> 关键词来调用模块：</p><pre><code>const inquirer = require('inquirer')
</code></pre><p>当安装的包是可执行程序的时候呢？当安装的包含有可执行程序时，程序会放在 <code>node_modules/.bin/</code> 文件夹内，关于如何运行这些可执行程序，我们通过 <strong>cowsay</strong> 包来演示。</p><p>首先安装 <strong>cowsay</strong>，这里安装到 global 路径下：</p><pre><code>npm install -g cowsay
</code></pre><p>我的 global 路径地址为：<code>/opt/node-v15.5.1-linux-x64/lib/node_modules</code>，可执行文件被安装在 <code>/opt/node-v15.5.1-linux-x64/bin/</code> 目录下：</p><pre><code>cowsay -&gt; ../lib/node_modules/cowsay/cli.js</code></pre><p>查看属性可以看到此可执行文件是指向 cli.js 的一个链接。</p><p>通过 <strong>npx</strong> 命令可以方便的执行此程序，不需要提供程序所在路径：</p><pre><code>$ npx cowsay wow
 _____
&lt; wow &gt;
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre><h3>package.json 文件</h3><p>package.json 文件是其项目的一个声明，它可以用来做一些完全没有关联的事情。例如，它是配置工具的仓库，也存储着 npm 安装的包的版本信息。</p><p>下面是最简单的文件形式：</p><pre><code>{}
</code></pre><p>文件需要遵守 json 格式，否则无法被程序读取其定义的内容。没有什么内容是必须的，所以可以是一个简单的大括号。如果你要做一个通过 npm 分享的 node.js 包，那么 package.json 文件需要定义一些必须的属性以供了解这个包的信息，后面会做详细介绍。</p><p>下面是另一个示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-node&quot;
}</code></pre><p>以上定义了一个 <strong>name</strong> property，定义了这个 app 或 package 的名称。文件和项目文件在同一文件夹下。</p><p>下面是一个更加复杂的示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A Vue.js project&quot;,
  &quot;main&quot;: &quot;src/main.js&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
    &quot;test&quot;: &quot;npm run unit&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
    &quot;babel-core&quot;: &quot;^6.22.1&quot;,
    &quot;babel-eslint&quot;: &quot;^8.2.1&quot;,
    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,
    &quot;babel-jest&quot;: &quot;^21.0.2&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;,
    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,
    &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.0.1&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.15.0&quot;,
    &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
    &quot;file-loader&quot;: &quot;^1.1.4&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;jest&quot;: &quot;^22.0.4&quot;,
    &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;,
    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;portfinder&quot;: &quot;^1.0.13&quot;,
    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,
    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,
    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
    &quot;vue-jest&quot;: &quot;^1.0.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
}</code></pre><p>包含了很多的属性设置：</p><ul><li><strong>version</strong> 表示当前版本号</li><li><strong>name</strong> 设置包名称</li><li><strong>description</strong> 对 app 简要的描述</li><li><strong>main</strong> 设置 app 的入口文件</li><li><strong>private</strong> 如果设置为 true 可以防止包被无意的发布到 npm</li><li><strong>scripts</strong> 定义可以运行的脚本命令</li><li><strong>dependencies</strong> npm 依赖包列表</li><li><strong>devDependencies</strong> 定义开发使用的 npm 包列表</li><li><strong>engines</strong> 设置 app 运行的 node 版本</li><li><strong>browserslist</strong> 指定支持的浏览器版本</li></ul><p>以上所有的属性都可以被 npm 或其他工具使用。</p><h4>常用属性</h4><p>下面介绍一些常规使用的属性，包括你在本地开发的项目也可以使用。</p><p><strong>name</strong> 定义app 名称：</p><pre><code>&quot;name&quot;: &quot;test-project&quot;
</code></pre><p>name 必须小于 214 个字符，不能含有空格，只能包含<strong>小写字母，横杠<code>-</code> 或下划线<code>_</code></strong>。如果将包发布到 npm，会生成一个独有的链接。</p><p><strong>author</strong> 定义作者信息：</p><pre><code>&quot;author&quot;: &quot;marco &lt;me@niekun.net&gt; (https://niekun.net)&quot;
</code></pre><p>或者：</p><pre><code>  &quot;author&quot;: {
    &quot;name&quot;: &quot;marco&quot;,
    &quot;email&quot;: &quot;me@niekun.net&quot;,
    &quot;url&quot;: &quot;https://niekun.net&quot;
  }</code></pre><p><strong>contributors</strong> 定义代码贡献者信息，可以包含多人：</p><pre><code>  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;marco&quot;,
      &quot;email&quot;: &quot;me@niekun.net&quot;,
      &quot;url&quot;: &quot;https://niekun.net&quot;
    }
  ]</code></pre><p><strong>bugs</strong> 定义反馈 bug 的链接，一般是 GitHub issue 页面：</p><pre><code>&quot;bugs&quot;: &quot;https://github.com/whatever/package/issues&quot;
</code></pre><p><strong>homepage</strong> 定义包的主页链接：</p><pre><code>&quot;homepage&quot;: &quot;https://whatever.com/package&quot;
</code></pre><p><strong>version</strong> 定义当前包的版本：</p><pre><code>&quot;version&quot;: &quot;1.0.0&quot;
</code></pre><p>此属性遵守 semantic versioning (semver) notation 语义版本标记语法。也就是由三个数字表示：x.x.x</p><p><strong>license</strong> 定义包的授权信息：</p><pre><code>&quot;license&quot;: &quot;MIT&quot;
</code></pre><p><strong>keywords</strong> 定义关于这个包实现功能的关键词，是一个数组：</p><pre><code>  &quot;keywords&quot;: [
    &quot;learning&quot;,
    &quot;nodejs&quot;
  ]</code></pre><p>使用 keywords 可以帮助别人找到你的包，或者在 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索关键词。</p><p><strong>description</strong> 定义一个对此 app 的简短描述：</p><pre><code>&quot;description&quot;: &quot;a node.js beginner guide&quot;
</code></pre><p><strong>repository</strong> 定义项目仓库地址：</p><pre><code>&quot;repository&quot;: &quot;github:whatever/node-project&quot;
</code></pre><p>注意如果不是使用的 GitHub 也可以定义其他工具：</p><pre><code>&quot;repository&quot;: &quot;gitlab:whatever/node-project&quot;
</code></pre><p>也可以明确的定义版本控制系统信息：</p><pre><code>  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/whatever/testing.git&quot;
  }</code></pre><p><strong>main</strong> 设置包的入口：</p><pre><code>&quot;main&quot;: &quot;./main.js&quot;
</code></pre><p><strong>private</strong> 如果设置为 true，可以防止包被无意的发布到 npm：</p><pre><code>&quot;private&quot;: &quot;true&quot;
</code></pre><p><strong>scripts</strong> 定义可执行的 node 脚本：</p><pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;,
    &quot;test&quot;: &quot;echo abcd&quot;
  }</code></pre><p>定义的脚本是命令行程序，通过 npm run xxx 执行，如：</p><pre><code>npm run start
</code></pre><p><strong>dependencies</strong> 定义 app 需要安装的 npm 依赖包：</p><pre><code>  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }</code></pre><p>当通过 <code>npm install &lt;PACKAGENAME&gt;</code> 安装包，会自动将包写入 package.json 文件的 dependencies 块。</p><p><strong>devDependencies</strong> 定义 app 开发需要的 npm 依赖包：</p><pre><code>&quot;devDependencies&quot;: {
  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
  &quot;babel-core&quot;: &quot;^6.22.1&quot;
}</code></pre><p>和 <strong>dependencies</strong> 的区别是这里定义的包只是在开发设备上安装，而不需要在执行设备上安装。开发包通过以下命令安装：</p><pre><code>npm install --save-dev &lt;PACKAGENAME&gt;
</code></pre><p><strong>engines</strong> 设置此包运行的 node 版本和其他命令版本：</p><pre><code>  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;=3.0.0&quot;
  }</code></pre><p><strong>browserslist</strong> 定义 app 支持的浏览器版本：</p><pre><code>&quot;browserslist&quot;: [
  &quot;&gt; 1%&quot;,
  &quot;last 2 versions&quot;,
  &quot;not ie &lt;= 8&quot;
]</code></pre><p>以上定义的意义是：支持所有类型浏览器的最近两个版本且需要至少有 1% 的占有率，不包括小于等于 IE8 版本的浏览器。浏览器占有率信息来自于 <a href="https://caniuse.com/">https://caniuse.com/</a> 统计。</p><h4>依赖包版本信息</h4><p>在 <strong>dependencies</strong> 和 <strong>devDependencies</strong> 中定义了依赖包列表，每个包都定义了版本信息，如：<strong>^0.13.0</strong> 或 <strong>~3.0.0</strong>，通过版本号前的符号可以们定义接受那些版本的升级，下面介绍版本标记的用法：</p><ul><li>无标记，如 1.0.0 定义只安装此版本的包</li><li><strong>latest</strong> 定义安装最新版本的包</li><li><strong>^</strong> 只能升级到不改变最左边第一个非零数字的版本，如定义 <strong>^0.13.0</strong>，通过 npm update 可以升级到 0.13.1 或 0.13.2，但不能升级到 0.14.0，定义 <strong>^1.13.0</strong>，能够升级到 1.13.1 或 1.14.0，不能升级到 2.0.0</li><li><strong>~</strong> 只能升级最后一位数字变化的版本，如 定义 <strong>~1.13.0</strong>，能够升级到 1.13.1，但不能升级到 1.14.0</li><li><strong>&gt;</strong> 接受大于定义的版本号的更新</li><li><strong>&gt;=</strong> 接受大于等于定义的版本号的更新</li><li><strong>&lt;</strong> 接受小于定义的版本号的更新</li><li><strong>&lt;=</strong> 接受小于等于定义的版本号的更新</li><li><strong>-</strong> 设置一个版本范围，如：1.0.0 - 2.0.0</li><li><strong>||</strong> 组合设置，如：&lt; 2.0.0 || &gt; 3.0.0</li></ul><p>更加详细的定义方法参考：<a href="https://nodejs.dev/learn/semantic-versioning-using-npm">https://nodejs.dev/learn/semantic-versioning-using-npm</a></p><h3>package-lock.json 文件</h3><p>在 npm 5 版本中 npm 引入了 package-lock.json 文件。</p><p>前面介绍了 package.json 文件，它是一个通用的被广泛使用的配置文件。package-lock.json 文件的目的是更加确切的追踪安装的依赖包的版本，以用来 100% 复制开发者的安装环境到其他安装者设备上，即使某些包已经够了更新版本。</p><p>这解决了一个 package.json 遗留的问题，在 package.json 中你可以定义某个包可接受的版本升级范围，版本格式遵守 semantic versioning (semver) notation 语义版本标记语法，例如：</p><ul><li><strong>~1.13.1</strong> 可以升级到 1.13.2，但不可以升级到 1.14.0</li><li><strong>^1.13.1</strong> 可以升级到 1.14.0，但不能升级到 2.0.0</li><li><strong>1.13.1</strong> 只能安装 1.13.1 版本，不能升级到其他任何版本</li></ul><p>你发布的包中并不包含开发环境中的  node_modules 文件夹因为它占用空间很大。当在其他设备中通过 <code>npm install</code>  命令安装依赖包时，竟会遵循上面定义的版本范围安装支持的最新版本到设备中，这就会导致用户安装的版本和你开发环境的版本不一致，可能导致 bug 的出现。</p><p>package-lock.json 中定义了你当前开发环境安装的各种依赖包的准确版本，这样通过 <code>npm install</code> 命令安装的就是其中定义的准确版本。</p><p>这一概念并不是 npm 独创的，其他编程语言也在使用类似的模式，如 php 的 Composer。</p><p>package-lock.json 文件需要打包在仓库中，以供其他人使用。当使用 <code>npm update</code> 更新包时，package-lock.json 中的定义也会同步更新。</p><p>下面是一个 package-lock.json 文件的示例，当我们执行 <code>npm install cowsay</code> 时，会创建以下内容：</p><pre><code>{
  &quot;requires&quot;: true,
  &quot;lockfileVersion&quot;: 1,
  &quot;dependencies&quot;: {
    &quot;ansi-regex&quot;: {
      &quot;version&quot;: &quot;3.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=&quot;
    },
    &quot;cowsay&quot;: {
      &quot;version&quot;: &quot;1.3.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz&quot;
,
      &quot;integrity&quot;: &quot;sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==&quot;,
      &quot;requires&quot;: {
        &quot;get-stdin&quot;: &quot;^5.0.1&quot;,
        &quot;optimist&quot;: &quot;~0.6.1&quot;,
        &quot;string-width&quot;: &quot;~2.1.1&quot;,
        &quot;strip-eof&quot;: &quot;^1.0.0&quot;
      }
    },
    &quot;get-stdin&quot;: {
      &quot;version&quot;: &quot;5.0.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g=&quot;
    },
    &quot;is-fullwidth-code-point&quot;: {
      &quot;version&quot;: &quot;2.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=&quot;
    },
    &quot;minimist&quot;: {
      &quot;version&quot;: &quot;0.0.10&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8=&quot;
    },
    &quot;optimist&quot;: {
      &quot;version&quot;: &quot;0.6.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-2j6nRob6IaGaERwybpDrFaAZZoY=&quot;,

      &quot;requires&quot;: {
        &quot;minimist&quot;: &quot;~0.0.1&quot;,
        &quot;wordwrap&quot;: &quot;~0.0.2&quot;
      }
    },
    &quot;string-width&quot;: {
      &quot;version&quot;: &quot;2.1.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==&quot;,
      &quot;requires&quot;: {
        &quot;is-fullwidth-code-point&quot;: &quot;^2.0.0&quot;,
        &quot;strip-ansi&quot;: &quot;^4.0.0&quot;
      }
    },
    &quot;strip-ansi&quot;: {
      &quot;version&quot;: &quot;4.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-qEeQIusaw2iocTibY1JixQXuNo8=&quot;,
      &quot;requires&quot;: {
        &quot;ansi-regex&quot;: &quot;^3.0.0&quot;
      }
    },
    &quot;strip-eof&quot;: {
      &quot;version&quot;: &quot;1.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=&quot;
    },
    &quot;wordwrap&quot;: {
      &quot;version&quot;: &quot;0.0.3&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o9XabNXAvAAI03I0u68b7WMFkQc=&quot;
    }
  }
}</code></pre><p>我们安装的 cowsay 有如下依赖，它们会被自动安装：</p><ul><li>get-stdin</li><li>optimist</li><li>string-width</li><li>strip-eof</li></ul><p>以上的依赖包可能也会有它们各自的其他依赖包，会自动安装相关其他包，每个包的依赖包在 <strong>requires</strong> 属性中定义。</p><p>所有的包以字母排序顺序在文件中。每个包都有 <strong>version</strong> 属性定义了各自当前安装的版本，<strong>resolved</strong> 定义了包地址，<strong>integrity</strong> 字符串用来验证包。</p><h3>包版本管理及安装</h3><p>下面的指令查询当前安装的所有包及其依赖包：</p><pre><code>npm list
</code></pre><p>输出信息示例：</p><pre><code>❯ npm list
/Users/joe/dev/node/cowsay
└─┬ cowsay@1.3.1
  ├── get-stdin@5.0.1
  ├─┬ optimist@0.6.1
  │ ├── minimist@0.0.10
  │ └── wordwrap@0.0.3
  ├─┬ string-width@2.1.1
  │ ├── is-fullwidth-code-point@2.0.0
  │ └─┬ strip-ansi@4.0.0
  │   └── ansi-regex@3.0.0
  └── strip-eof@1.0.0</code></pre><p>当然也可以直接打开 package-lock.json 文件查看，但这样不太方便观察结构。</p><p><code>npm list -g</code> 用来查看 global 安装的包。</p><p>如果只想查询顶层的包，也就是你主动通过 <code>npm install</code> 安装的那些包，可通过 <code>npm list --depth=0</code> 查询：</p><pre><code>❯ npm list --depth=0
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>也可以单独查询某个包：</p><pre><code>❯ npm list cowsay
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>使用下面命令查询某个包当前发布的最新版本：</p><pre><code>❯ npm view cowsay version
1.4.0</code></pre><p>要安装某个包的特定版本需要加上 <code>@</code> 标记：</p><pre><code>npm install cowsay@1.2.0
</code></pre><p>查看某个包的所有历史版本列表：</p><pre><code>$ npm view cowsay versions
[
  '1.0.0', '1.0.1', '1.0.2',
  '1.0.3', '1.1.0', '1.1.1',
  '1.1.2', '1.1.3', '1.1.4',
  '1.1.5', '1.1.6', '1.1.7',
  '1.1.8', '1.1.9', '1.2.0',
  '1.2.1', '1.3.0', '1.3.1',
  '1.4.0'
]</code></pre><p>通过 <code>npm update</code> 可以更新所有已安装的包，更新版本规则遵循 package.json 定义的版本升级范围，同时会更新 package-lock.json 文件内的当前包版本信息。</p><p>想要查询当前有哪些包有更新版本时，可以执行 <code>npm outdated</code> 命令：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1402612766.png" alt="2021-01-29T01:29:02.png" title="2021-01-29T01:29:02.png"></p><p>其中有些更新是大版本更新， <code>npm update</code> 并不会更新到这些大版本，因为这些更新可能包含有重大的变化。如果要强制更新到最新的版本包括大版本更新，可以按顺序执行下面的命令：</p><pre><code>npm install -g npm-check-updates
ncu -u
npm update</code></pre><p>使用下面命令卸载某个包：</p><pre><code>npm uninstall &lt;package-name&gt;
</code></pre><p>添加 <code>-S</code> 或 <code>--save</code> 标记删除 package.json 中的相关信息。如果要删除的包是一个开发包，在 devDependencies 中定义过，则需要添加 <code>-D</code> 或 <code>--save-dev</code> 标记来删除相关信息：</p><pre><code>npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;</code></pre><p>如果包是 global 安装的，则卸载需要添加 <code>-g</code> 标记：</p><pre><code>npm uninstall -g &lt;package-name&gt;
</code></pre><h3>npm local 和 global 安装</h3><p>本地包和全局包的区别是本地包通过 <code>npm install</code> 安装到当前项目下的 node_modules 文件夹内，全局包通过 <code>npm install -g</code> 安装到系统路径下，路径地址可通过 <code>npm root -g</code> 查询。</p><p>在程序中，只能 require 本地包：</p><pre><code>require('package-name')
</code></pre><p>通常情况下推荐所有的包都以本地模式安装。这可以让不同的程序使用各自不同版本的包。更新一个全局包会同时影响所有使用这个包的 app。</p><p>当一个包含有可执行程序时，应该安装为 global 全局包。这样所有的项目都可以调用执行。</p><h3>npm dependencies 和 devDependencies</h3><p>当通过 npm intall 安装包时，表示将包作为 dependency。包信息会自动写入 package.json 文件的 dependencies 块内。当安装时添加 <code>-D</code> 标记，表示将包作为 devdependency 安装。包信息会自动写入 devDependencies 块内。</p><p>开发包的目的是用来开发程序时使用，作为产品运行时是不需要的。</p><p>执行 npm install 会默认安装这些开发包。如果不需要安装开发包需要加上 <code>--production</code> 标记：</p><pre><code>npm install --production xxx
</code></pre><h3>npx 包运行器</h3><p>npx 可以用来运行 node.js 程序。node.js 开发者通常将大部分含有可执行程序的包作为 global 包发布，这样就使得可执行程序在系统 PATH 路径下可以被直接执行。但这样的弊端就是不能安装不同版本的包。</p><p>使用 npx 命令可以自动寻找 node_modules 文件夹内的对应的名称的可执行程序，而不需要知道程序具体的路径，也不需要以 global 方式安装包。</p><p>npx 另一个很好的功能是可以直接运行某些命令而不需要提前安装它们，还可以通过 <code>@</code> 标记来执行不同版本的同一命令。</p><p>cowsay 是一个很好的示例来说明 npx 的使用，如果我们以 global 模式安装 cowsay，可以通过下面方式执行：</p><pre><code>cowsay &quot;wow&quot;
</code></pre><p>以上命令只有通过 global 方式安装才能够正常执行，否则会报错提示命令不存在。</p><p>如果以 local 方式安装 cowsay，可以通过 npx 执行：</p><pre><code>npx cowsay &quot;Hello&quot;
</code></pre><p>通过 <code>@</code> 标记来执行不同版本的命令：</p><pre><code>npx node@10 -v #v10.18.1
npx node@12 -v #v12.14.1</code></pre><p>npm 也可以直接执行来自 url 的任意代码片段，而不仅限于 npm 官方渠道发布的包。下面示例是执行部署在 glist 的包：</p><pre><code>npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
</code></pre><p>可执行程序路径定义在 package.json 文件的 bin 属性内。</p><p>glist 包含内容如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1152197546.jpg" alt="1.jpg" title="1.jpg"></p><p>当然执行不受控制网络的代码需要多加注意。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2085.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2085.html</wfw:commentRss>
</item>
<item>
<title>服务器部署 WebDAV 服务</title>
<link>https://blog.niekun.net/archives/2074.html</link>
<guid>https://blog.niekun.net/archives/2074.html</guid>
<pubDate>Fri, 22 Jan 2021 11:16:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 GET、POS...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 <strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</p><p>简单说 webdav 就像一个网盘，可以远程访问他的目录名对其文件进行读写操作。</p><p><strong>WebDAV 允许客户端进行下列操作：</strong></p><ul><li>处理服务器上 WebDAV 发布目录中的资源</li><li>具有正确权限的用户可以在 WebDAV目录中复制和移动文件</li><li>修改与某些资源相关联的属性。例如，用户可写入并检索文件的属性信息</li><li>锁定并解锁资源以便多个用户可同时读取一个文件。但每次只能有一个人修改文件</li><li>搜索 WebDAV 目录中的文件的内容和属性</li></ul><!--more--><p>下面介绍如何在服务器上部署 WebDAV 服务。这里通过 nginx 来代理。</p><h3>编译 nginx</h3><p>我们通过 nginx 来代理 webdav 服务，nginx 自带有 ngx_http_dav_module 模块，但是其不支持一些 webdav 的 method 如：PROPFIND, OPTIONS, LOCK, UNLOCK。可以通过第三方模块来完整支持 webdav 的特性。</p><p>下载以下两个第三方模块：<br><strong>nginx-dav-ext-module</strong>：<a href="https://github.com/arut/nginx-dav-ext-module">https://github.com/arut/nginx-dav-ext-module</a><br><strong>headers-more-nginx-module</strong>：<a href="https://github.com/openresty/headers-more-nginx-module">https://github.com/openresty/headers-more-nginx-module</a></p><p>以上两个模块需要在编译时通过 <strong>--add-module</strong> 参数来引入模块，同时需要包含 <strong>--with-http_dav_module</strong> 模块，否则编译会报错。</p><p>从源码编译 nginx 参考我之前的教程：<a href="https://blog.niekun.net/archives/30.html">https://blog.niekun.net/archives/30.html</a></p><p>我使用的完整的编译参数如下：</p><pre><code>./configure --prefix=/opt/nginx-1.19.6 \
--user=nginx --group=nginx \
--with-compat --with-file-aio --with-threads \
--with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module \
--with-mail --with-mail_ssl_module \
--with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module \
--add-module=../echo-nginx-module \
--add-module=../ngx-fancyindex \
--add-module=../headers-more-nginx-module \
--add-module=../nginx-dav-ext-module</code></pre><h3>配置文件</h3><p>nginx 编译安装完成后，需要配置 conf 文件来使 webdav 生效。我提前已经设置了一个单独的子域名来访问 webdav 服务，且使用 ssl 加密。</p><p>首先建立 webdav 文件夹并设置正确的权限，否则在读写时会提示权限不足：</p><pre><code>mkdir /home/www/webdav
chown -R www-data:www-data /home/www/webdav</code></pre><p>如果想要限制用户访问，可以使用 <strong>ngx_http_auth_basic_module</strong> 模块来建立账号访问，具体参考：<a href="https://blog.niekun.net/archives/730.html">https://blog.niekun.net/archives/730.html</a></p><p>完整配置文件如下：</p><pre><code>dav_ext_lock_zone zone=foo:10m;
server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   webdav.xxx.xxx;
    include       my-server/ssl;

    # 限制访问
    auth_basic           &quot;Restricted Access&quot;;
    auth_basic_user_file ../users/.adminpasswd;

    # webdav 目录
    root /home/www/webdav;
    client_body_temp_path /opt/nginx/client_body_temp;

    # webdav 设置
    dav_access      user:rw  group:rw  all:r;
    dav_methods PUT DELETE MKCOL COPY MOVE;
    dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;
    dav_ext_lock zone=foo;
    create_full_put_path on;

    # 优化大文件上传
    send_timeout 3600;
    client_body_timeout 3600;
    keepalive_timeout 3600;
    lingering_timeout 3600;
    client_max_body_size 2G;

    location / {
        # 创建文件夹操作时结尾添加斜杠
        if ($request_method = MKCOL) {
            rewrite ^(.*[^/])$ $1/ break;
        }

        # 移动文件夹操作时结尾添加斜杠
        if (-d $request_filename) {
            rewrite ^(.*[^/])$ $1/;
            set $md /;
        }

        set $x $http_destination$request_method;
        if ($x ~ [^/]MOVE) {
            more_set_input_headers -r &quot;Destination: ${http_destination}${md}&quot;;
        }
    }

    # 拒绝 Windows 或 macos 多余文件上传到 webdav 路径
    location ~ \.(_.*|DS_Store|Spotlight-V100|TemporaryItems|Trashes|hidden|localized)$ {
        access_log  off;
        error_log   off;

        if ($request_method = PUT) {
            return 403;
        }
        return 404;
    }

    location ~ \.metadata_never_index$ {
        return 200 &quot;Don't index this drive, Finder!&quot;;
    }
}</code></pre><p>注意第一句 <strong>dav_ext_lock_zone</strong> 要放在 http 块内。否则会报错。</p><p>配置文件修改好后，使用下面指令测试配置是否正确：</p><pre><code>nginx -t
</code></pre><p>如果返回 ok 重启服务即可：</p><pre><code>systemctl restart nginx
</code></pre><h3>客户端连接</h3><p>nginx 配置好 webdav 模块并启动后，可以尝试在客户端访问。</p><p>Windows 的 file explorer 和 macos 的 finder 都可以直接连接 webdav。</p><h3>Windows 端</h3><p>在 file explorer 中点击 home - easy access - map as drive：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/797689005.jpg" alt="1.jpg" title="1.jpg"></p><p>在弹出窗口中点击 connect to a web site：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1204074620.jpg" alt="2.jpg" title="2.jpg"></p><p>点击 next 在地址栏输入服务器 nginx 定义的 webdav 访问地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/3507948553.jpg" alt="3.jpg" title="3.jpg"></p><p>点击 next 后如果设置了 <strong>auth_basic</strong> 会提示要求输入账户和密码，输入账户密码后就进入了 webdav 目录了，下面就可以测试新建文件，修改文件等操作。</p><p><strong>注意 Windows 中默认只有 https 方式访问的地址才可以设置 auth，否则不会弹出输入账户和密码的提示框，而是直接提示无法访问此地址。</strong>如果想要开放 http 方式的 auth 验证，需要修改注册表 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel</code> 的值为 2，然后重启系统即可，此键值定义为：</p><ul><li>0 - Basic authentication disabled</li><li>1 - Basic authentication enabled for SSL shares only</li><li>2 or greater - Basic authentication enabled for SSL shares and for non-SSL shares</li></ul><h3>macos 端</h3><h3>参考链接：</h3><p><a href="https://www.robpeck.com/2020/06/making-webdav-actually-work-on-nginx/">Making Native WebDAV Actually Work on nginx with Finder and Explorer</a><br><a href="https://www.codetd.com/en/article/9724623">Nginx repair of WebDAV functionality</a><br><a href="http://nginx.org/en/docs/http/ngx_http_dav_module.html">Module ngx_http_dav_module</a><br><a href="https://www.webdavsystem.com/server/prev/v2/documentation/authentication/basic_auth_vista/">Using Basic Authentication with Windows 7 and Windows Vista WebDAV Client</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2074.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2074.html</wfw:commentRss>
</item>
<item>
<title>修复 ubuntu vmware 虚拟机无法访问主机共享目录</title>
<link>https://blog.niekun.net/archives/2071.html</link>
<guid>https://blog.niekun.net/archives/2071.html</guid>
<pubDate>Fri, 15 Jan 2021 16:32:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 /mnt/hgfs 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 <code>/mnt/hgfs</code> 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载即可。</p><p>首先查看当前设置的共享目录有哪些：</p><pre><code>$ vmware-hgfsclient 
Development
Downloads
InstallationPackage</code></pre><p>挂载主机共享路径到虚拟机对应路径下，设置所有用户可访问：</p><pre><code>$ sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other
</code></pre><p>执行以上命令后，发现共享文件夹出现了：</p><pre><code>$ ls /mnt/hgfs/
Development  Downloads  InstallationPackage</code></pre><p>以上就是解决 VMware Linux 虚拟机没有自动挂载共享目录的方法。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2071.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2071.html</wfw:commentRss>
</item>
<item>
<title>c++ 类型转换</title>
<link>https://blog.niekun.net/archives/2066.html</link>
<guid>https://blog.niekun.net/archives/2066.html</guid>
<pubDate>Thu, 14 Jan 2021 11:58:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Implicit conversion 隐式转换当一个数据复制为兼容格式的类型时，隐式转换可以自动完成。请看下面示例：double a = 100.1;int b;b = a;cout &lt;...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>Implicit conversion 隐式转换</h3><p>当一个数据复制为兼容格式的类型时，隐式转换可以自动完成。</p><p>请看下面示例：</p><pre><code>double a = 100.1;
int b;
b = a;
cout &lt;&lt; b &lt;&lt; endl;

//output:
//100</code></pre><!--more--><p>以上示例中，我们将 <strong>double</strong> 类型的数据复制给 <strong>int</strong> 类型的变量，不会引起语法报错，这就是 <strong>Implicit</strong> 隐式类型转换，也叫 <strong>standard conversion</strong> 标准转换。标准转换对一些基本的数据类型有效，能够对一些 <strong>numerical</strong> 数值类型的数据间进行转换，如：double to int，int to float，short to double，int to bool 等，也可以在 pointer 指针类型间转换。</p><p>从小一些的整型如 short 转换到 int 类型，或者从 float 类型转换到 double 类型，这种转换过程叫做 <strong>promotion</strong> 晋升操作。这种转换可以确保原始数据完整的复制到目标数据类型中。</p><p>其他数学运算类型间的转换可能不一定会完整的保留原始数据，下面是几种情况举例：</p><ul><li>一个负整数转换为 unsigned 类型，结果为 unsigned 类型数据所能表达的最大值数据</li><li>转换为 bool 类型的数据时，对于数值类型原始数据为 0 时，对于指针类型指针数据为 null pointer 时，对应转换为 false。原始数据为所有其他情况时，转换结果为 true。</li><li>浮点型数据转换为整型数据，数据会被截取整数部分，如果数据结果超出目标数据类型所能表达的最大值，会得到 undefined</li></ul><p>我们可以看到，隐式转换可能会带来数据精度的丢失，编译器此时会提示一条 warning 警告。可以通过使用 <strong>explicit conversion</strong> 显式转换来避免警告信息。</p><h3>class 的隐式转换</h3><p>class 中的隐式转换通过以下三个 function 控制：</p><ul><li>单参数的 constructors 允许从一个特定类型的数据隐式转换构造为一个 object</li><li>通过等号操作符 Assignment operator 复用来隐式转换</li><li>类型传播符 Type-cast 来隐式转换为特定的类型</li></ul><p>下面示例解释各种方式的含义：</p><pre><code>class A {};

class B {
public:
    B(A a) {} //constructor: conversion from A
    B operator=(A a) {return *this;} // assignment operator: conversion from A
    operator A() {return A();} // type-cast: conversion to A
};

int main()
{
    A a; // instance a
    B b = a; // constructor b from a
    B c(a); // constructor c from a
    b = a; // assignment a to b
    a = b; // convert b to A type and assignment to a

    return 0;
}</code></pre><p>以上实例分别介绍了三种隐式转换的方式。</p><ul><li>构造器的一个传入参数为 A 类型数据，也就是等同于可以将 A 类型因素转换为 B 类型</li><li>通过操作符复用将等号<code>=</code> 重新定义，等号右边的为 A 类型数据时，以A类型数据作为构造器参数返回 B 类型 object 指针</li><li>当执行 B 类型数据赋值给 A 类型时，会通过类型传播符定义的 function 返回 A 类型 object</li></ul><p>构造器初始化 object时，当只有一个参数时，就相当于把传入数据转换为对应 object 类型了。上面示例中可以看到，有两种方法来构造 object：</p><pre><code>B b = a; // constructor b from a
B c(a); // constructor c from a</code></pre><p>以上两种方式都是将 a 作为初始化参数构造 B 类型的 object。</p><p>编写了等号操作符复用后，对某个指定类型的外部 object 进行等号操作时就会将其转换为当前 object 类型，而不会报错。</p><p>通过类型传播符可以将 object 转换为其他指定类型的 object。</p><p>关于操作符复用的语法参考我之前的教程：<a href="https://blog.niekun.net/archives/1920.html">https://blog.niekun.net/archives/1920.html</a></p><h3>explicit 关键词</h3><p>当调用一个 function 时，对于其传递参数 c++ 允许进行隐式转换，这在一些情况下会引起一些问题，因为我们并不是所有情况下都希望自动进行转换的。</p><p>在以上示例中加入 function：</p><pre><code>void function(B b) {}
</code></pre><p>此 function 有一个 B 类型的参数，但是在实际调用中，由于 B 中定义了 A 的隐式转换相关模块，所以我们在这里可以将 A 类型数据作为传入数据：</p><pre><code>fun(a);
</code></pre><p>实际中我们可能并不需要这种转换，我们希望的是这里只能将 B 类型数据作为传入参数。通过关键词 <strong>explicit</strong> 来定义 constructor 可以实现这个需求，修改 B 的 constructor：</p><pre><code>explicit B(A a) {}
</code></pre><p>再次执行程序，会发现以下几个指令会报错：</p><pre><code>B b = a;
fun(a);</code></pre><p>通过 关键词 <strong>explicit</strong> 定义 constructor 的 class 不能通过 assignment 赋值符来初始化 object，也不能对 function 的传入参数进行隐式转换。</p><h3>explicit conversion 显式转换</h3><p>c++ 是一种严格区分数据类型的语言，对于那些会影响数据本身的转换，需要进行 explicit conversion 显式转换也叫做 <strong>type-casting</strong>。</p><p>在过去的语法中有两种常规的 type-casting 方式：</p><pre><code>double e = 10.11;
int f = int(e);
int g = (int)e;</code></pre><p>第一种叫做 function 样式，第二种叫做 c-like C语言模式。</p><p>对于那些基础数据类型的数据，这种转换模式没有什么问题，但这种语法对于 class 和 pointer 类型数据也会不加判断的进行转换，从而导致运行时的 runtime error。</p><p>为了控制这些在 class 间进行转换的过程，新版 c++ 提供了 4 种 <strong>casting operators</strong> 传播符来供不同场景下使用：</p><ul><li>dynamic_cast &lt;new_type&gt; (expression)</li><li>reinterpret_cast &lt;new_type&gt; (expression)</li><li>static_cast &lt;new_type&gt; (expression)</li><li>const_cast &lt;new_type&gt; (expression)</li></ul><h4>dynamic_cast</h4><p><strong>dynamic_cast</strong> 只能用于某个 class 或(void*) 的指针。他的作用是确保转换后的目标类型指针指向的是一个完整有效的 object，而不是空 object。例如，从 derived class 指针转换为 base class 指针。但是对于多态化的 polymorphic class(包含 virtual 元素的 class)，当且仅当指向的 object 是一个完整有效的目标 object 类型，使用 <strong>dynamic_cast</strong> 就可以从 base class 指针转换为 derived class 指针，请看如下示例：</p><pre><code>class Base { virtual void dummy() {} };
class Derived: public Base {int a;};

int main()
{
    try {
        Base *b1 = new Base;
        Base *b2 = new Derived;
        Derived *d;

        d = dynamic_cast&lt;Derived*&gt;(b1);
        if (d == 0)
            cout &lt;&lt; &quot;null pointer on first type cast&quot; &lt;&lt; endl;

        d = dynamic_cast&lt;Derived*&gt;(b2);
        if (d == 0)
            cout &lt;&lt; &quot;null pointer on second type cast&quot; &lt;&lt; endl;
    } catch(exception e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}

//output:
//null pointer on first type cast</code></pre><p>以上示例中，我们建立了 <strong>Base</strong> class 和 <strong>Derived</strong> class，其中 <strong>Base</strong> 含有一个 <strong>virtual</strong> function。然后我们创建两个 <strong>Base</strong> 类型指针，两个指针分别预分配类型为 <strong>Base</strong> 和 <strong>Derived</strong>。在之前的 c++ 教程中提到过可以新建 <strong>base</strong> 类型的变量然后使用 <strong>derived</strong> 类型数据，需要了解的可以查看：<a href="https://blog.niekun.net/archives/1927.html">https://blog.niekun.net/archives/1927.html</a>。然后我们创建一个 <strong>Derived</strong> 类型指针，使用 <strong>dynamic_cast</strong> 分别将上面建立的两个 <strong>Base</strong> 类型指针转换为 <strong>Derived</strong> 类型。</p><p>由于 <strong>b2</strong> 虽然是 <strong>Base</strong> 类型指针，但是我们预分配内存类型为 <strong>Derived</strong> 类型，所以它其实包含了 <strong>Derived</strong> object 所有属性。这样转换后的类型为完整的 <strong>Derived</strong> 类型指针。所以 <strong>d</strong> 指针不为空。而 <strong>b1</strong> 完全是 <strong>Base</strong> 类型指针，所以转换后的类型是不完整的 <strong>Derived</strong> 类型指针，所以赋值后结果为空。</p><p><strong>dynamic_cast</strong> 可以将任意指针转换为 <strong>void</strong>* 类型指针。</p><h4>static_cast</h4><p><strong>static_cast</strong> 可以转换任意相关联 class 类型的指针。不仅仅从 derived 到 base，也可以从 base 到 derived。不会判断是否转换到目标指针是完整的数据类型，所以完全由编程人员判断转换操作是否是安全的。相比于 <strong>dynamic_cast</strong> 有更大适用范围。</p><p>以下示例语法不会报错：</p><pre><code>class Base {};
class Derived: public Base {};

Base * a = new Base;
Derived * b = static_cast&lt;Derived*&gt;(a);</code></pre><p>b 指针会得到一个不完整的 Derived 类型数据，运行时可能报错。因此，使用 <strong>static_cast</strong> 不仅可以转换那些直接支持隐式转换的 class 指针，也可以在那些不支持转换的 class 间进行转换。</p><p>我们测试在其他数据将进行转换：</p><pre><code>double a = 12.23;
int b = static_cast&lt;int&gt;(a);
cout &lt;&lt; b &lt;&lt; endl;

//OUTPUT:
//12</code></pre><p>以上，我们将 double 类型的数据转换为 int 类型，这种转换可以直接通过隐式转换完成，但是使用显式转换语法实现更加明确清晰。但前提是原类型和目标类型必须是 related 有关联的 object 类型。</p><h4>reinterpret_cast</h4><p><strong>reinterpret_cast</strong> 可以将任意类型指针转换为其他任意类型指针，甚至是完全没有关联的两个类型。转换的过程就是将源数据的二进制数据复制到新指针地址。相比于 <strong>static_cast</strong> 有更大适用范围。</p><p>以下代码可以正常执行：</p><pre><code>class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast&lt;B*&gt;(a);</code></pre><p>此时 b 指针指向的是一个和 B 类型完全不相干的数据，此时访问 b 指向的数据是不安全的。</p><h3>const_cast</h3><p><strong>const_cast</strong> 可以操作 const 类型的指针数据，例如当一个 function 需要非 const 类型传入数据时，可以通过 <strong>const_cast</strong> 进行转换。</p><p>请看下面示例：</p><pre><code>void test(int a) {
    cout &lt;&lt; a &lt;&lt; endl;
}

const int a = 10;
test(a);</code></pre><p>以上示例中，调用 test function 会报错，因为传入参数需要是非 const 类型的数据。</p><p>修改以上代码：</p><pre><code>const int a = 10;
int *b = const_cast&lt;int*&gt;(&amp;a);
test(*b);

//output:
//10</code></pre><p>通过 <strong>const_cast</strong> 将 <strong>const int</strong> 转换为 <strong>int</strong>，这样就可以在 function 中使用了。</p><h3>参考链接</h3><p><a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Type conversions</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2066.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2066.html</wfw:commentRss>
</item>
<item>
<title>VMware 虚拟机 NAT 网络下配置端口转发到主机</title>
<link>https://blog.niekun.net/archives/2061.html</link>
<guid>https://blog.niekun.net/archives/2061.html</guid>
<pubDate>Tue, 12 Jan 2021 11:06:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天安装了 Ubuntu 虚拟机用来做 node.js 开发，在选择网络模式时我选择了 NAT 模式，因为这样可以在主机处于不同网络环境下使虚拟机都有着同一个 IP 地址，方便管理。但是在此时中...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天安装了 Ubuntu 虚拟机用来做 node.js 开发，在选择网络模式时我选择了 NAT 模式，因为这样可以在主机处于不同网络环境下使虚拟机都有着同一个 IP 地址，方便管理。</p><p>但是在此时中发现，虚拟机可以正常访问主机及外网，但是主机无法通过分配的 NAT 地址来 ssh 访问虚拟机。查询后发现这是正常现象。可以通过设置端口转发来将虚拟机端口映射到主机端口来实现对虚拟机的访问。</p><!--more--><p>首先给虚拟机设置一个静态 ip 地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1335854183.jpg" alt="1.jpg" title="1.jpg"></p><p>然后打开<strong>虚拟网络编辑器</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/2454627578.jpg" alt="2.jpg" title="2.jpg"></p><p>选中 NAT 对应的网卡，这里是 vnet 8，点击 <strong>NAT 设置</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/2210698665.jpg" alt="3.jpg" title="3.jpg"></p><p>在端口转发栏点击<strong>添加</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/725240944.jpg" alt="4.jpg" title="4.jpg"></p><p>设置要转发到的主机端口及对应虚拟机 IP 和端口等信息，这里我需要转发 ssh 的 22 端口到主机的 2222 端口：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/406942165.jpg" alt="5.jpg" title="5.jpg"></p><p>点击确定保存设置即可。</p><p>设置好后就可以通过访问主机本地 2222 端口实现 ssh 访问虚拟机了。可以根据需要设置多个端口转发。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2061.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2061.html</wfw:commentRss>
</item>
<item>
<title>vs code 通过 ssh 远程连接服务器调试</title>
<link>https://blog.niekun.net/archives/2053.html</link>
<guid>https://blog.niekun.net/archives/2053.html</guid>
<pubDate>Tue, 12 Jan 2021 09:01:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[安装扩展插件： Remote - SSH可以实现远程文件访问终端调试远程端口转发到本地https://code.visualstudio.com/docs/remote/ssh-tutorial]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>安装扩展插件： Remote - SSH<br>可以实现远程文件访问<br>终端调试<br>远程端口转发到本地</p><p><a href="https://code.visualstudio.com/docs/remote/ssh-tutorial">https://code.visualstudio.com/docs/remote/ssh-tutorial</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2053.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2053.html</wfw:commentRss>
</item>
</channel>
</rss>