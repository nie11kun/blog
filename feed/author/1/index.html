<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - admin</title>
<link>https://blog.niekun.net/author/1/</link>
<atom:link href="https://blog.niekun.net/feed/author/1/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description>admin</description>
<lastBuildDate>Mon, 29 Mar 2021 14:51:42 +0800</lastBuildDate>
<pubDate>Mon, 29 Mar 2021 14:51:42 +0800</pubDate>
<item>
<title>ESXi 的安装与使用</title>
<link>https://blog.niekun.net/archives/2213.html</link>
<guid>https://blog.niekun.net/archives/2213.html</guid>
<pubDate>Mon, 29 Mar 2021 14:51:42 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[什么是 VMware vSphereVMware vSphere 是 VMware 的虚拟化平台，可将数据中心转换为包括 CPU、存储和网络资源的聚合计算基础架构。vSphere 将这些基础架构...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>什么是 VMware vSphere</h3><p>VMware vSphere 是 VMware 的虚拟化平台，可将数据中心转换为包括 CPU、存储和网络资源的聚合计算基础架构。vSphere 将这些基础架构作为一个统一的运行环境进行管理，并为您提供工具来管理加入该环境的数据中心。</p><p><img src="https://blog.niekun.net/usr/uploads/2021/03/2575390332.png" alt="2021-03-29T03:22:48.png" title="2021-03-29T03:22:48.png"></p><!--more--><p>vSphere 的两个核心组件是 <strong>ESXi</strong>  和 <strong>vCenter Server</strong>。ESXi 是用于创建并运行虚拟机和虚拟设备的虚拟化平台。vCenter Server 是一项服务，用于管理网络中连接的多个主机，并将主机资源池化。</p><p><strong>vSphere Hypervisor</strong> <strong>虚拟领域管理程序</strong>是一种可将服务器虚拟化的裸机管理程序，依托 <strong>VMware vSphere ESXi</strong> 体系架构构建。</p><p><strong>ESXi</strong> 是安装在物理机上的管理器。vSphere Client 安装在一个笔记本或者桌面PC上，用于访问 ESXi 服务器进行虚拟机的创建和管理。vCenter server 像一个虚拟机一样安装在 ESXi 上面。在拥有多个 ESXi 服务器和数十个虚拟机时，vCenter server的应用就比较频繁了。在小环境下的管理通常都会使用 vSphere client 来直连 ESXi 服务器。</p><p>简单来说 <strong>ESXi</strong> 是直接安装在物理机器上用来管理硬件设备，相当于一个操作系统，然后在 <strong>ESXi</strong> 中安装虚拟机。它可以方便的给不同的虚拟机分配硬件资源，以及管理。</p><p>类似 VMware workstation 等产品是需要安装在某个操作系统内部运行的。</p><h3>下载镜像</h3><p>我们需要下载 vSphere Hypervisor 的 iso 镜像。</p><p>进入官网：<a href="https://www.vmware.com/products/vsphere-hypervisor.html">https://www.vmware.com/products/vsphere-hypervisor.html</a></p><p>在右侧点击 download 会提示登录账号，然后需要注册下产品，点击 register：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/801019411.png" alt="2021-03-29T03:38:15.png" title="2021-03-29T03:38:15.png"></p><p>然后找到 esxi ISO 镜像下载地址，点击下载：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4066834994.png" alt="2021-03-29T03:39:38.png" title="2021-03-29T03:39:38.png"></p><p>当前最新版为 VMware vSphere 7.0 Update 2。</p><h3>安装</h3><p>然后我们需要将制作一个启动盘来安装 esxi，推荐使用 ventoy 来加载镜像，非常方便：<a href="https://www.ventoy.net/en/index.html">https://www.ventoy.net/en/index.html</a></p><p>开机进入 boot 设置，将对应的启动盘设置为第一项启动，然后就可以进入 ventoy 引导画面了。</p><p>选择 esxi 镜像文件 enter 进入，下面我们就进入 esxi 安装程序了。</p><p><strong>这里有第一个需要注意的地方</strong>，esxi 在第一次全新安装中会默认划分 120G 的虚拟闪存，类似于 Windows 的虚拟内存，提供更大的交换空间，为虚拟机提供读缓存，提升虚拟机的存储性能。</p><p>但是对于家用设备来说，120G 的空间白白占用有点浪费，所以我们需要自定义设置这个虚拟闪存的大小。</p><p>在引导进入安装界面后，立刻按下 shift + o 键，会停留在如下画面：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4151124259.png" alt="2021-03-29T03:51:01.png" title="2021-03-29T03:51:01.png"></p><p>在下方可以输入命令行的地方，我们在已有命令后添加一句：<strong>autoPartitionOSDataSize=4096</strong>:<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2886267543.png" alt="2021-03-29T03:52:40.png" title="2021-03-29T03:52:40.png"></p><p>表示设置虚拟闪存大小为 4 GB，可以按照需要调整，数字就是 1024 乘以需要的 GB 大小。</p><p>回车确认后继续引导安装程序，期间会自动识别设备硬件。根据提示点击 enter 继续：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1535191890.png" alt="2021-03-29T03:57:37.png" title="2021-03-29T03:57:37.png"></p><p>点击 F11 继续：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4282492030.png" alt="2021-03-29T03:58:05.png" title="2021-03-29T03:58:05.png"></p><p>选择安装到那个硬盘，enter 确认继续：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/749667252.png" alt="2021-03-29T03:58:48.png" title="2021-03-29T03:58:48.png"></p><p>选择键盘布局，默认即可：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2896348534.png" alt="2021-03-29T03:59:09.png" title="2021-03-29T03:59:09.png"></p><p>设置 root 密码：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/476951246.png" alt="2021-03-29T03:59:39.png" title="2021-03-29T03:59:39.png"></p><p>最后点击 F11 开始安装：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3121539912.png" alt="2021-03-29T03:59:59.png" title="2021-03-29T03:59:59.png"></p><p>安装完成后提示可以移除引导盘并重启了：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1588907724.png" alt="2021-03-29T04:02:19.png" title="2021-03-29T04:02:19.png"></p><h3>连接管理</h3><p>系统重启后，会自动识别第一个网口的网络地址，我们可以在同一局域网下通过 ESXi 的地址访问管理页面：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3325959303.png" alt="2021-03-29T04:05:07.png" title="2021-03-29T04:05:07.png"></p><p>我们也可以通过网线将其他设备连接到第一个网口的方式进入管理页面，需要首先设置 esxi 的网络地址。点击 F2 进入配置界面，需要输入 root 密码：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3445057029.png" alt="2021-03-29T04:06:19.png" title="2021-03-29T04:06:19.png"></p><p>进入 config management network：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1507410719.png" alt="2021-03-29T04:06:52.png" title="2021-03-29T04:06:52.png"></p><p>默认选中的管理网络为第一个网口，可以自行修改：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2292204358.png" alt="2021-03-29T04:07:31.png" title="2021-03-29T04:07:31.png"></p><p>我们需要配置 IPv4 configuration：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2414244109.png" alt="2021-03-29T04:08:09.png" title="2021-03-29T04:08:09.png"></p><p>空格键选中 set static ipv4 address，并配置合适的 ip 地址，稍后需要将连接的设备也设置为同一网段才可以连接：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/193729119.png" alt="2021-03-29T04:10:26.png" title="2021-03-29T04:10:26.png"></p><p>完成后点击 esc 退出配置，会弹出是否重启网络提示框，点击 Y 确认。</p><p>然后我们需要在通过网线连接的设备端配置网络到上面设置的同一网段内。这样就可以通过设置的静态地址来访问 esxi 管理页面了。</p><p>以上两种方式都可以进入 esxi 管理界面，这里我是通过局域网设备来实现的。</p><h3>进入 esxi 管理</h3><p>访问 esxi 的管理地址，这里我的 esxi 地址为 27.168.1.181。在局域网下其他设备浏览器打开这个地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2979117796.png" alt="2021-03-29T05:07:46.png" title="2021-03-29T05:07:46.png"></p><p>登录 root 账户：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1796962619.png" alt="2021-03-29T05:08:39.png" title="2021-03-29T05:08:39.png"></p><p>可以看到 esxi 7 自身占用了 1.3GB 内存和 2.5GB 硬盘空间。</p><p>hardware 栏里的 virtual flash 就是我们安装时候自定义的 4GB 虚拟闪存空间：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/262708481.png" alt="2021-03-29T05:11:58.png" title="2021-03-29T05:11:58.png"></p><p>我们安装的是 esxi 评估版可以免费使用 60 天，如果想要一直使用则需要输入有效的序列号。可以通过 manage - licensing - actions - assign license 输入序列号：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2860080469.png" alt="2021-03-29T05:14:49.png" title="2021-03-29T05:14:49.png"></p><h3>配置磁盘</h3><p>安装 esxi 的时候会格式化系统对应的磁盘，如果安装了多个磁盘并且需要在 esxi 中作为存储设备，就需要单独配置它们了。</p><p>点击左侧导航栏的 storage，然后选择 devices：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3020367051.png" alt="2021-03-29T05:29:12.png" title="2021-03-29T05:29:12.png"></p><p>可以看到我有两块硬盘和一个 cdrom。其中最下面的 10G 的硬盘是 esxi 安装盘，点击进入可以查看详细信息：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2817559226.png" alt="2021-03-29T05:30:52.png" title="2021-03-29T05:30:52.png"></p><p>其中 VMFSL 就是虚拟闪存空间，剩下的 VMFS 分区就是可用的数据分区。</p><p>点击进入第二个硬盘查看：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2158895126.png" alt="2021-03-29T05:32:35.png" title="2021-03-29T05:32:35.png"></p><p>我们看到这里什么都没有，这是因为这块硬盘没有分配 datastore。我们点击 new datastore，首先给这个数据区取一个名字：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/707394890.png" alt="2021-03-29T05:37:13.png" title="2021-03-29T05:37:13.png"></p><p>在下面的页面，我们首先选择 use full disk，这样会见整块硬盘都作为这个 datastore，然后点击 next：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/37552592.png" alt="2021-03-29T05:38:45.png" title="2021-03-29T05:38:45.png"></p><p>点击 finish 后，datastroe 就建立完成了，这时候可以看到这块磁盘的信息：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2769919541.png" alt="2021-03-29T05:39:59.png" title="2021-03-29T05:39:59.png"></p><p>返回 datastore 选项卡可以看到新建立的 datastore2 在列表中：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/393116508.png" alt="2021-03-29T05:41:08.png" title="2021-03-29T05:41:08.png"></p><p>在后续的虚拟机安装中，我们可以选择将虚拟机安装到哪一个 datastore 中。</p><p>点击 datastore browser 可以查看其中的数据文件：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2214393644.png" alt="2021-03-29T05:42:37.png" title="2021-03-29T05:42:37.png"></p><p><img src="https://blog.niekun.net/usr/uploads/2021/03/3379758427.png" alt="2021-03-29T05:43:38.png" title="2021-03-29T05:43:38.png"></p><p>可以看到左上角有一个 upload 选项，我们可以远程将文件复制到 datasotre 中：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/604823768.png" alt="2021-03-29T05:44:47.png" title="2021-03-29T05:44:47.png"></p><p>后续安装虚拟机时，我会通过这种方法将系统镜像文件复制到 datastore 中。</p><h3>配置网卡</h3><p>下面我们来配置网卡，这也是 esxi 的核心之一。我们可以将主机上的物理网卡定义为虚拟交换机，然后分配给虚拟机使用。</p><p>这里的配置非常自由，需要根据实际需求来设置，我们可以将每个网卡单独配置一个虚拟交换机，也可以将多个网卡设置为一个虚拟交换机。</p><p>选择左侧导航栏的 networking，然后点击 physical NICs，就是主机上的所有物理网卡，这里有三个：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2409538492.png" alt="2021-03-29T05:49:50.png" title="2021-03-29T05:49:50.png"></p><p>然后我们切换到 virtual switches，这里就是定义虚拟交换机，默认有一个 vSwitch0，我们点击进去看看它的配置：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1241696609.png" alt="2021-03-29T05:52:17.png" title="2021-03-29T05:52:17.png"></p><p>可以看到它绑定了我们的第一个网卡。我们点击 edit settings 进入配置：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4128853737.png" alt="2021-03-29T05:53:18.png" title="2021-03-29T05:53:18.png"></p><p>uplink 定义了绑定到那个物理网卡。<strong>注意我们将 security 里的三个选项都设置为 accept 来使网络功能完整支持。</strong>点击 save 保存配置。</p><p>如果需要将另一个网卡也绑定到这个虚拟交换机，可以点击左上角的 add uplink：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/570019677.png" alt="2021-03-29T05:55:58.png" title="2021-03-29T05:55:58.png"></p><p>这里我们将每个网卡都配置单独的虚拟交换机。</p><p>返回 virtual switches 栏，点击 add standard virtual switch 添加新的交换机：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1530204776.png" alt="2021-03-29T05:58:59.png" title="2021-03-29T05:58:59.png"></p><p>将第二个网卡配置给 vSwitch1，同样的设置 security 为 accept。然后通过相同的方法配置第三个网卡，最终我们配置好了所有的交换机：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3189820924.png" alt="2021-03-29T06:00:49.png" title="2021-03-29T06:00:49.png"></p><p>最后我们配置 port group 端口组，可以定义一个虚拟交换机的集合。我们安装虚拟机为其分配网卡时就是分配给其某个 port group。同一个虚拟交换机可以定义到多个集合中。</p><p>默认有两个集合，可以看到它们都是对应 vSwtich0：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1808085278.png" alt="2021-03-29T06:06:42.png" title="2021-03-29T06:06:42.png"></p><p>注意不要修改第二个 Management Network 的配置，否则可能无法访问 esxi 管理页面。</p><p>我们将另外两个刚才建立的虚拟交换机定义到 port group 中，以便虚拟机可以调用。点击 add port group：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3495385610.png" alt="2021-03-29T06:09:25.png" title="2021-03-29T06:09:25.png"></p><p><strong>这里注意 group 名称如果最后一个是数字，则不要再前面加空格，否则虚拟机无法识别到它。</strong></p><p>将所有的虚拟交换机都配置对应的 port group：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2104661130.png" alt="2021-03-29T06:11:09.png" title="2021-03-29T06:11:09.png"></p><p>这样我们就配置好了所有的网卡部分。</p><p>这里有个进阶教程，可以将某个网卡或其他物理设备设置为直通模式，可以供虚拟机直接调用。可以提高性能。这样就不需要配置虚拟交换机了。</p><p>通过 manage - hardware - PCI devices 查看所有的硬件：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2966573054.png" alt="2021-03-29T06:14:47.png" title="2021-03-29T06:14:47.png"></p><p>如果又可以直通的硬件，前面的复选框就可为可选状态，然后点击 左上角的 toggle passthrough 就可以切换直通模式了，这里我由于是虚拟机中安装的 esxi 所有网卡不可以设置为直通模式。</p><h3>创建虚拟机</h3><p>下面我们就可以创建虚拟机了。</p><p>首先配置虚拟机，左侧导航栏选择 virtual machines，然后点击 create/register vm 进入引导页面：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1923027329.png" alt="2021-03-29T06:20:45.png" title="2021-03-29T06:20:45.png"></p><p>如果时创建新虚拟机则选择第一项，如果是添加已有的虚拟机则选择第三项，这里我们创建新虚拟机，点击 next。</p><p>设置虚拟机名称和系统类型，这里我安装一个 openwrt 系统：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1716246100.png" alt="2021-03-29T06:22:47.png" title="2021-03-29T06:22:47.png"></p><p>然后选择虚拟机安装位置，也就是选择一个 datastore：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/688792816.png" alt="2021-03-29T06:23:31.png" title="2021-03-29T06:23:31.png"></p><p>然后是定义虚拟机硬件配置，可以根据需要设置，这里我通过顶部的菜单添加一个新的 network adapter：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3386313093.png" alt="2021-03-29T06:25:46.png" title="2021-03-29T06:25:46.png"></p><p>然后我们配置网络适配器对应的 port group，点击后面的下拉菜单可以看到我们在 port group 中定义的所有集合：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3112212601.png" alt="2021-03-29T06:27:30.png" title="2021-03-29T06:27:30.png"></p><p>我给两个网络适配器分别分配不同的集合，也就是对应不同的虚拟交换机：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2568647135.png" alt="2021-03-29T06:29:15.png" title="2021-03-29T06:29:15.png"></p><p>如果需要通过系统镜像的方式安装虚拟机，则需要配置 cdrom 为 datastore ISO file，然后选择提前上传到 datastore 的镜像文件：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4018267828.png" alt="2021-03-29T06:32:02.png" title="2021-03-29T06:32:02.png"></p><p>这里我是通过提前准备好的 vmdk 虚拟磁盘文件来直接启动虚拟机，所以我需要将虚拟磁盘添加进来。</p><p>首先将默认的 disk 删除，然后选择 add hard disk - existing hard disk：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1574139812.png" alt="2021-03-29T06:37:21.png" title="2021-03-29T06:37:21.png"></p><p>然后选中对应的磁盘文件，这里我们直接将磁盘文件放在 openwrt 目录内，方便后期管理：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2568476479.png" alt="2021-03-29T06:39:40.png" title="2021-03-29T06:39:40.png"></p><p>然后点击 finish 完成虚拟机的硬件配置：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/353707365.png" alt="2021-03-29T06:40:30.png" title="2021-03-29T06:40:30.png"></p><p>现在可以看到我们刚添加的 openwrt：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3640121135.png" alt="2021-03-29T06:41:15.png" title="2021-03-29T06:41:15.png"></p><p>点击 openwrt 进入监控界面：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2812354515.png" alt="2021-03-29T06:42:43.png" title="2021-03-29T06:42:43.png"></p><p>然后点击 power on 就可以启动虚拟机了。</p><h3>开机自启</h3><p>可以通过设置，让 esxi 启动后自动启动某个虚拟机，点击 manage - system - autostart，然后选中需要自动启动的虚拟机，点击 enable 即可：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/3894487917.png" alt="2021-03-29T06:50:13.png" title="2021-03-29T06:50:13.png"></p><p>如果有多个虚拟机需要自动启动，还可以设置它们的启动顺序。</p><p>以上就是 esxi 的简单安装和使用教程。</p><h3>参考链接</h3><p><a href="https://docs.vmware.com/cn/VMware-vSphere/index.html">VMware vSphere 文档</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2213.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2213.html</wfw:commentRss>
</item>
<item>
<title>QT 中通过 QCustomPlot widget 绘制可视化曲线表</title>
<link>https://blog.niekun.net/archives/2208.html</link>
<guid>https://blog.niekun.net/archives/2208.html</guid>
<pubDate>Fri, 19 Mar 2021 17:24:46 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天在项目中需要添加一个柱状图，但由于我们的项目是 QT 4.8 的所以不支持 QtCharts。查询了下发现有 QCustomPlot 可以完美的实现需求，使用方法也很简单。官网：https:...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天在项目中需要添加一个柱状图，但由于我们的项目是 QT 4.8 的所以不支持 <strong>QtCharts</strong>。查询了下发现有 <strong>QCustomPlot</strong> 可以完美的实现需求，使用方法也很简单。</p><p>官网：<a href="https://www.qcustomplot.com/">https://www.qcustomplot.com/</a><br>下载：<a href="https://www.qcustomplot.com/index.php/download">https://www.qcustomplot.com/index.php/download</a></p><!--more--><p><strong>QCustomPlot</strong> 只有两个文件 <code>qcustomplot.cpp</code> 和 <code>qcustomplot.h</code>，将其复制到项目目录中并添加到项目中。然后引用头文件即可：</p><pre><code>#include &quot;qcustomplot.h&quot;
</code></pre><p>我们需要在 ui 中添加一个 widget 然后右键点击控件，选择提升：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/1732184362.png" alt="2021-03-19T09:15:23.png" title="2021-03-19T09:15:23.png"></p><p>提升的 class 名称修改为 QCustomPlot：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2440250486.png" alt="2021-03-19T09:16:47.png" title="2021-03-19T09:16:47.png"></p><p>点击 <strong>add</strong> 然后点击 <strong>promote</strong> 即可。</p><p>编译后可以看到图表样式：</p><p>在使用中如果需要根据数据变化刷新渲染的图形，记得在修改数据后调用</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2208.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2208.html</wfw:commentRss>
</item>
<item>
<title>使用 instaloader 下载 Instagram 图片-视频</title>
<link>https://blog.niekun.net/archives/2205.html</link>
<guid>https://blog.niekun.net/archives/2205.html</guid>
<pubDate>Tue, 16 Mar 2021 11:55:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[一直在使用 telegram bot 来下载 YouTube 或 twitter 视频，很方便快捷。关于配置自己的 bot 参考之前的文章：https://blog.niekun.net/arc...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>一直在使用 telegram bot 来下载 YouTube 或 twitter 视频，很方便快捷。</p><p>关于配置自己的 bot 参考之前的文章：<a href="https://blog.niekun.net/archives/428.html">https://blog.niekun.net/archives/428.html</a></p><p>我的应用于 telegram bot 的 YouTube 下载器源码地址：<a href="https://github.com/nie11kun/telegram-bot-youtube-downloader">https://github.com/nie11kun/telegram-bot-youtube-downloader</a></p><p>最近想给我的 telegram bot 添加 Instagram 图片的下载功能，但是 youtube-dl 并不支持 Instagram。查询了下发现了 instaloader 这个开源软件可以完美实现我想要的功能。</p><p>instaloader 官网：<a href="https://instaloader.github.io/">https://instaloader.github.io/</a></p><p>GitHub：<a href="https://github.com/instaloader/instaloader">https://github.com/instaloader/instaloader</a></p><!--more--><h3>安装</h3><p>instaloader 需要 python 3.5 以上。推荐直接安装最新版 python。</p><p>使用 pip3 安装：</p><pre><code>pip3 install instaloader --upgrade
</code></pre><p><strong>注意必须通过 pip3 而不是 pip 安装，否则使用中会报错。</strong></p><h3>使用</h3><p>安装完成后就可以使用 <strong>instaloader</strong> 命令来下载了。注意如果 python 安装到了自定义目录，如 <code>/opt</code> 则需要手动链接 instaloader 可执行程序到 <code>/usr/local/bin</code> 目录。</p><h4>下载 post</h4><p>如果要下载一个 post 中的图片，提取链接中的 <strong>shortcode</strong> 来下载，如下是一个 Instagram post 的链接：<a href="https://www.instagram.com/p/CMcMZycLpbS/?utm_source=ig_web_copy_link">https://www.instagram.com/p/CMcMZycLpbS/?utm_source=ig_web_copy_link</a>，其中的 <code>CMcMZycLpbS</code> 就是 <strong>shortcode</strong> 代码。</p><p>需要通过 <code>-shortcode</code> 参数来下载对应的图片，且需要通过 <code>--</code> 告诉 instaloader 不要将 <code>-shortcode</code> 作为 option 对待，如：</p><pre><code>instaloader -- -CMcMZycLpbS
</code></pre><p>关于命令中的特殊字符处理参考：<a href="https://blog.niekun.net/archives/2204.html">https://blog.niekun.net/archives/2204.html</a></p><p>默认会下载到当前目录下，并新建文件夹 <code>-shortcode</code>，媒体文件及相关文本文件就在其中，注意到文件夹是以特殊字符 <code>-</code> 开头的，所以访问目录需要加上 <code>--</code>，如：</p><pre><code>cd -- -CMcMZycLpbS
</code></pre><h4>自定义下载目录</h4><p>通过 <code>--dirname-pattern</code> 参数可以指定下载目录，如：</p><pre><code>instaloader --dirname-pattern=/tmp/test -- -CMcMZycLpbS
</code></pre><p>就会将对应 post 的媒体下载到 <code>/tmp/test</code> 目录内。</p><p><strong>instaloader</strong> 的功能很强大，可以下载一个用户的所有发布内容，可以下载一个 <code>#hashtag</code> 标签的所有内容等。具体可以参考官方文档：<a href="https://instaloader.github.io/basic-usage.html#download-pictures-from-instagram">https://instaloader.github.io/basic-usage.html#download-pictures-from-instagram</a></p><p>我将 instaloader 加入了 telegram bot 中，可以很方便的下载一个 post 的媒体内容，有兴趣的可以查看：<a href="https://github.com/nie11kun/telegram-bot-youtube-downloader">https://github.com/nie11kun/telegram-bot-youtube-downloader</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2205.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2205.html</wfw:commentRss>
</item>
<item>
<title>cd 到以 '-' dash 开头的目录的方法</title>
<link>https://blog.niekun.net/archives/2204.html</link>
<guid>https://blog.niekun.net/archives/2204.html</guid>
<pubDate>Tue, 16 Mar 2021 10:33:44 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Linux 下，当文件或文件夹包含空格或其他特殊符号如 $，在引用时需要将其放在单引号 '' 或 &quot;&quot; 中，如：cd '$abc'cd &quot;abc de f&quot...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Linux 下，当文件或文件夹包含空格或其他特殊符号如 <code>$</code>，在引用时需要将其放在单引号 <code>''</code> 或 <code>&quot;&quot;</code> 中，如：</p><pre><code>cd '$abc'
cd &quot;abc de f&quot;
</code></pre><p>当文件以 <code>-</code> dash 开头时，命令会将其作为 option 处理，如：</p><pre><code>ls -lh
</code></pre><p>此时如果需要让命令将其识别为文件名称而不是 option 需要加入 <code>--</code> 作为参数：</p><pre><code>cd -- '-abc'
</code></pre><p>这样命令就会将 <code>-</code> 开头的字符作为文件名称处理了。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2204.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2204.html</wfw:commentRss>
</item>
<item>
<title>React 入门教程之七 -- List 和 Form</title>
<link>https://blog.niekun.net/archives/2201.html</link>
<guid>https://blog.niekun.net/archives/2201.html</guid>
<pubDate>Fri, 05 Mar 2021 16:13:20 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[list 列表和 key在 JavaScript 中我们通常使用 map method 来对一个 list 的每个元素进行操作：const numbers = [1, 2, 3, 4, 5];c...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>list 列表和 key</h3><p>在 JavaScript 中我们通常使用 <strong>map</strong> method 来对一个 list 的每个元素进行操作：</p><pre><code>const numbers = [1, 2, 3, 4, 5];
const double = numbers.map((number) =&gt; { return number * 2});
console.log(double)

//output:
//[ 2, 4, 6, 8, 10 ]</code></pre><p>在 React 中对一个 list 的元素进行操作方法类似。</p><!--more--><p>我们可以在 <strong>JSX</strong> 中通过大括号<code>{}</code> 来建立一个 elements 的集合，下面示例中我们将 <strong>map</strong> 的返回定义为 <code>&lt;li&gt;</code> 元素并赋值给 listItems：</p><pre><code>const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)

ReactDOM.render(
    &lt;ul&gt;{listItems}&lt;/ul&gt;,
    document.getElementById('root')
);</code></pre><p>注意在 <strong>render</strong> 中我们将 <strong>listItems</strong> 放在 <code>&lt;ul&gt;</code> 元素中。</p><p>通常情况下我们将 lists 放在一个 component 中：</p><pre><code>const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    )
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers}/&gt;,
    document.getElementById('root')
);</code></pre><p>当运行以上代码时，在浏览器终端会有一个 warning 警告信息：<strong>Each child in a list should have a unique "key" prop.</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2200488786.png" alt="2021-03-05T06:50:19.png" title="2021-03-05T06:50:19.png"></p><p><strong>Key</strong> 是一个特殊的 string 字符串属性需要给创建的 <strong>list</strong> element 添加的。它可以用来定位 list 中的每个元素。</p><p>下面我们给 list item 添加 <strong>Key</strong> 字符串属性：</p><pre><code>const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;li key={number.toString()}&gt;
            {number}
        &lt;/li&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}</code></pre><p>添加后报警就会消除。</p><h4>Keys</h4><p><strong>Key</strong> 可以帮助 React 识别哪个 item 修改过，被删除，被添加。以上示例中，我们在 map 中创建 item 时给其 key 属性，这样每个 item 可以有确切的属性值。</p><p>每个 list item 最好设置一个特殊的标识 <strong>key string</strong> 来区别于其他 items。最常用的就是使用数据中的 ID 作为 key：</p><pre><code>const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo) =&gt; 
        &lt;li key={todo.id}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}
const todos = [
    {id: 1, text: '123'},
    {id: 2, text: '456'}
];
ReactDOM.render(
    &lt;TodoItems todos={todos} /&gt;,
    document.getElementById('root')
);</code></pre><p>当没有特定的 ID 来作为标识时，作为最后的选择，可以使用 item 的 index 作为 key：</p><pre><code>const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo, index) =&gt; 
        &lt;li key={index}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}</code></pre><p>如果 items 的顺序可能会发生变化的话，不推荐使用 index 作为 key 使用，因为可能对性能产生影响并且对 component 的 state 造成问题。<strong>如果没有定义确切的 key 给 items，React 默认会使用 index 作为 keys。</strong></p><h4>拆解 component 时 key 的处理</h4><p>keys 是对应与一个数组的内容而言的，它并不能单独存在。例如我们要拆解上面的 NumberList，提取出 <strong>ListItem</strong>，则需要将 key 定义在 <code>&lt;ListItem /&gt;</code> 元素中而不是 <strong>ListItem</strong> component 内部的 <code>&lt;li&gt;</code> 中：</p><pre><code>const ListItem = (props) =&gt; {
    return (
        &lt;li&gt;{props.value}&lt;/li&gt;
    );
}

const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers} /&gt;,
    document.getElementById('root')
);</code></pre><p>如果写成下面模式就是<strong>错误</strong>的：</p><pre><code>function ListItem(props) {
  const value = props.value;
  return (
    &lt;li key={value.toString()}&gt;
      {value}
    &lt;/li&gt;
  );
}</code></pre><h4>每个 item 的 key 必须是特定的</h4><p>数组中每个 items 使用的 <strong>key</strong> 必须是互相独立且不相同的，<strong>但并不需要在全局下互相独立</strong>。在两个单独的数组中可以，其元素可以使用相同的 key：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
            )}
        &lt;/ul&gt;
    );
    const content = props.posts.map((post) =&gt;
        &lt;div key={post.id}&gt;
            &lt;h3&gt;{post.title}&lt;/h3&gt;
            &lt;p&gt;{post.content}&lt;/p&gt;
        &lt;/div&gt;
    );
    return (
        &lt;div&gt;
            {sideBar}
            &lt;hr/&gt;
            {content}
        &lt;/div&gt;
    );
}

const posts = [
    {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
    {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];

ReactDOM.render(
    &lt;Blog posts={posts} /&gt;,
    document.getElementById('root')
);</code></pre><p>上面示例中，我们在 <strong>Blog</strong> component 中定义了两个 JSX，都创建了 list elements，每个元素的 key 使用了对应的 id 属性。在每个 list 内部 key 是互相独立的。可以看到不只是 <code>&lt;li&gt;</code> 元素可以加 key，只要通过 map 定义了一个 array 数组，就可以给每个元素加上 key 属性来互相独立识别。</p><p><strong>key</strong> 是为了给 <strong>React</strong> 识别用的。它本身并不作为一个普通 <strong>prop</strong> 传给 components，<strong>也就是在 component 内部并不能使用这个 key 数据</strong>，如果想要在 component 中使用这个数据则需要单独定义一个其他 prop 来传入 key 数据：</p><pre><code>const Post = (props) =&gt; {
    return (
        &lt;li&gt;
            {props.id}: {props.title}
        &lt;/li&gt;
    )
}
const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;Post key={post.id} id={post.id} title={post.title} /&gt;
            )}
        &lt;/ul&gt;
    );
...
...
...
}</code></pre><p>上面示例中，<strong>Post</strong> component 无法直接访问 <strong>key</strong> 的数据，所以我们在调用 <strong>Post</strong> 时单独定义一个 <strong>id</strong> 属性并赋值为 key 相同的数据，这样就间接的可以在 <strong>Post</strong> component 中通过 id 来读取 key 的数据。</p><p>在之前的 ListItem 示例中，我们声明了一个单独的 listItems 变量并在后续返回中将其放在 <code>&lt;ul&gt;</code> 中：</p><pre><code>const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}</code></pre><p>JSX 支持嵌入任何的 JavaScript 表达式，只需要使用大括号包围即可，所以上面的代码可以修改为以下模式：</p><pre><code>    return (
        &lt;ul&gt;
            {numbers.map((number) =&gt;
                &lt;ListItem key={number.toString()} value={number} /&gt;);}
        &lt;/ul&gt;
    );</code></pre><p>使用哪种方式来定义 JSX 取决于对应的使用场景，总的原则是要方便与代码阅读，逻辑清晰。需要注意的是如果 <code>map()</code> method 中层级太复杂，可以考虑将其拆分为多个 components。</p><h3>Forms 表格</h3>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2201.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2201.html</wfw:commentRss>
</item>
<item>
<title>升级 command line tool 后 QT 编译 boost 库报错问题</title>
<link>https://blog.niekun.net/archives/2198.html</link>
<guid>https://blog.niekun.net/archives/2198.html</guid>
<pubDate>Wed, 03 Mar 2021 21:03:37 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天打开一个 QT 项目后进行编译发现报错了，查看了下什么都没有修改就比较奇怪了。根据日志是 boost 库出了问题，报错为：Undefined symbols for architecture...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天打开一个 QT 项目后进行编译发现报错了，查看了下什么都没有修改就比较奇怪了。根据日志是 boost 库出了问题，报错为：<strong>Undefined symbols for architecture x86_64</strong>，但是 boost 库是以前编译好的从来没动过。回想起来前几天重新安装了下 command line tool 会不会有关系。</p><!--more--><p>看了下 QT kit 配置里面发现 clang 的设置居然有叹号。重新识别了下系统编译器：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2815337861.png" alt="2021-03-03T12:54:53.png" title="2021-03-03T12:54:53.png"></p><p>然后重建下项目配置：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4082452549.png" alt="2021-03-03T13:01:04.png" title="2021-03-03T13:01:04.png"></p><p>重新编译项目依然有报错。</p><p>最后就是 boost 库的确有问题了。于是我重新编译了一次。居然问题就解决了。</p><p>原来真的是由于系统的 Clang 更新后原来编译的 boost 库不兼容了，在此使用当前系统的 Clang 编译一次就行了。</p><p>boost 库编译方法参考：<a href="https://blog.niekun.net/archives/1174.html">https://blog.niekun.net/archives/1174.html</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2198.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2198.html</wfw:commentRss>
</item>
<item>
<title>React 入门教程之六 -- Conditional Rendering</title>
<link>https://blog.niekun.net/archives/2195.html</link>
<guid>https://blog.niekun.net/archives/2195.html</guid>
<pubDate>Tue, 02 Mar 2021 23:10:22 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[在 React 中，我们可以创建独立的 component 来封装特定的功能。因此，可以根据不同的程序的 state 选择性的做部分渲染。和 JavaScript 的相同，React 中也可以使...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在 <strong>React</strong> 中，我们可以创建独立的 component 来封装特定的功能。因此，可以根据不同的程序的 state 选择性的做部分渲染。</p><p>和 JavaScript 的相同，React 中也可以使用 conditions 语法来选择性的渲染内容。如使用 if 或 conditional operator 来根据不同 state 状态创建不同 elements 然后让 React 更新 UI 来匹配 DOM。</p><!--more--><p>考虑下面两个 components：</p><pre><code>const UserGreeting = (props) =&gt; {
    return &lt;h1&gt;welcome back&lt;/h1&gt;
}

const GuestGreeting = (props) =&gt; {
    return &lt;h1&gt;please sign up&lt;/h1&gt;
}</code></pre><p>然后我们创建一个 <strong>Greeting</strong> component 来根据是否有用户登陆来显示以上两个中的一个：</p><pre><code>const Greeting = (props) =&gt; {
    let isLoggedIn = props.isLoggedIn;
    if (isLoggedIn)
        return &lt;UserGreeting /&gt;;
    else
        return &lt;GuestGreeting /&gt;;
}

ReactDOM.render(
    &lt;Greeting isLoggedIn={true} /&gt;,
    document.getElementById('root')
);</code></pre><p>以上示例会根据 isLoggedIn 属性的值来渲染不同的内容。</p><h3>elements 变量</h3><p>可以使用变量存储 elements，这样可以方便的根据情况 render 部分的 component 而不需要改变输出的指令内容。</p><p>考虑下面两个 component 表示 login 和 logout：</p><pre><code>const LoginButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            login
        &lt;/button&gt;
    );
}

const LogoutButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            logout
        &lt;/button&gt;
    );
}</code></pre><p>然后我们创建 <strong>LoginControl</strong> component，它将根据当前情况渲染 login 或 logout button 以及之前创建的 Greeting element：</p><pre><code>class LoginControl extends React.Component {
    constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
    }

    handleLoginClick() {
        this.setState({isLoggedIn: true});
    }

    handleLogoutClick() {
        this.setState({isLoggedIn: false});
    }

    render() {
        let isLoggedIn = this.state.isLoggedIn;
        let button;
        if (isLoggedIn)
            button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
        else
            button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;

        return (
            &lt;div&gt;
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );
    }

}

ReactDOM.render(
    &lt;LoginControl /&gt;,
    document.getElementById('root')
);</code></pre><h3>inline condition 单语句判断</h3><p>使用 element 变量以及使用 if 语句根据条件渲染 component 是一种很好的方法。但是有时候可以使用简化语法。下面接收几种 inline condition 语法。</p><h4>inline if with && operator</h4><p>在 JSX 可以通过使用大括号<code>{}</code>来嵌入 JavaScript 表达式，包括逻辑符号：<code>&amp;&amp;</code>，在根据条件判断是否包含一个 element 时很有用。</p><p>请看下面示例：</p><pre><code>const InlineCom = (props) =&gt; {
    return(
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            {props.count &gt; 10 &amp;&amp;
                &lt;h2&gt;count is: {props.count}&lt;/h2&gt;
            }
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;InlineCom count={20} /&gt;,
    document.getElementById('root')
);</code></pre><p>如果 <code>props.count &gt; 10</code> 满足条件则后面的 element 就会成为 component 一部分。</p><p>在 JavaScript 中，<code>true &amp;&amp; expression</code> 将会评估为 <strong>expression</strong>，而 <code>false &amp;&amp; expression</code> 将会评估为 <strong>false</strong>。因此当 condition 为 true 时，<code>&amp;&amp;</code> 后的 element 将会输出，否则 React 将会忽略它。</p><h4>inline condition operator</h4><p>另一种根据情况通过 inline 单行判断来渲染 element 就是使用 JavaScript conditional operator：<code>condition ? true : false</code>。</p><p>给 LoginControl 的返回添加如下：</p><pre><code>        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );</code></pre><p>通过 inline conditional operator 来输出不同的信息。</p><p>也可以在较长的表达式中使用，例如可以将示例中 button 部分在 render 中这样处理：</p><pre><code>        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
                {isLoggedIn 
                    ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
                    : &lt;LoginButton onClick={this.handleLoginClick} /&gt;
                }
            &lt;/div&gt;
        );</code></pre><p>使用中根据实际情况选择最合适的方式处理 condition，最终目的是为了使结构更加清晰，代码易读。注意如果判断过复杂就需要考虑拆解 component 为多个个体了。</p><h3>阻止 component 渲染</h3><p>某些情况下我们可能需要将一个 component 隐藏起来，即使它在别的 component 中已经渲染了。可以通过 return <strong>null</strong> 来代替它的输出。</p><p>下面示例中 <strong>WarningBanner</strong> 会根据 <strong>warn</strong> 属性的值来选择性渲染：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

const WarningBanner = (props) =&gt; {
    if (!props.warn) {
        return null;
    }
    return (
        &lt;div className='warning'&gt;
            warning!
        &lt;/div&gt;
    );
}

class Page extends React.Component {
    constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handelToggleClick = this.handelToggleClick.bind(this);
    }
    handelToggleClick() {
        this.setState({showWarning: !this.state.showWarning});
    }

    render() {
        return (
            &lt;div&gt;
                &lt;WarningBanner warn={this.state.showWarning} /&gt;
                &lt;button onClick={this.handelToggleClick}&gt;
                    {this.state.showWarning ? 'hide' : 'show'}
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Page /&gt;,
    document.getElementById('root')
);</code></pre><p>在 <strong>render</strong> method 中 return <strong>null</strong> 不会影响到 component 的 lifecycle method。例如每次更新 <strong>componentDidUpdate</strong> 依然会被自动调用。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2195.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2195.html</wfw:commentRss>
</item>
<item>
<title>修复 vs code 下保存文件会自动 format 代码的问题</title>
<link>https://blog.niekun.net/archives/2191.html</link>
<guid>https://blog.niekun.net/archives/2191.html</guid>
<pubDate>Thu, 25 Feb 2021 20:46:37 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天在开发 React 时发现每次保存 js 文件都会自动改变代码格式导致一大堆报错：]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天在开发 React 时发现每次保存 js 文件都会自动改变代码格式导致一大堆报错：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/175565695.png" alt="2021-02-25T12:40:56.png" title="2021-02-25T12:40:56.png"></p><!--more--><p>经过查询发现时由于安装的 <strong>JS-CSS-HTML Formatter</strong> 插件默认会在保存文件时对文件格式进行处理。但是堆 React 代码的自动处理有问题导致无法正常进行开发。</p><p>只需要修改其配置文件将保存文件时自动处理关掉即可。</p><p>快捷键 <strong>cmd + shift + p</strong> 打开控制器，输入 formatter：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/1966900753.png" alt="2021-02-25T12:44:41.png" title="2021-02-25T12:44:41.png"></p><p>点击 formatter config 修改配置文件，将第一句 <strong>"onSave": true</strong> 改为 <strong>false</strong> 保存即可。</p><p>需要重启 vscode 才能生效。</p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/2191.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2191.html</wfw:commentRss>
</item>
<item>
<title>React 入门教程之五 -- Event</title>
<link>https://blog.niekun.net/archives/2189.html</link>
<guid>https://blog.niekun.net/archives/2189.html</guid>
<pubDate>Thu, 25 Feb 2021 17:23:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[events 处理处理 React elements events 和处理 DOM elements 很相似，但有一些语法区别：React events 命名使用 camelCase 规则，而不...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>events 处理</h3><p>处理 React elements events 和处理 DOM elements 很相似，但有一些语法区别：</p><ul><li>React events 命名使用 camelCase 规则，而不是 lowercase</li><li>使用 JSX 传入 function 作为 events handler，而不是 string 字符串</li></ul><p>HMTL 中处理 events 示例如下：</p><pre><code>&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;</code></pre><p>React 中示例如下：</p><pre><code>&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;</code></pre><p>注意它们的区别之处一个是 event 名称，一个是 handler 定义方式。</p><!--more--><p>另一个区别是在 React 中不能通过 <strong>return false</strong> 的方式防止 events 的默认行为，需要明确的调用 <strong>preventDefault</strong> method 来实现。</p><p>例如在一个 html 页面中定义一个 <strong>a</strong> tag 并取消其默认打开新页面的行为，实现如下：</p><pre><code>&lt;a href=&quot;#&quot; onclick=&quot;console.log('The link was clicked.'); return false&quot;&gt;
  Click me
&lt;/a&gt;</code></pre><p>React 中实现同样功能代码如下：</p><pre><code>class Link extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick(e) {
        e.preventDefault();
        console.log('clicked me');
    }
    render() {
        return (
            &lt;a href='#' onClick={this.handleClick}&gt;click me&lt;/a&gt;
        )
    }
}</code></pre><p><strong>e</strong> 表示 synthetic 综合的 event，当前哪个 event 触发了 <strong>e</strong> 就表示哪一个。使用 bind 绑定 的 method 在调用时会自动将 <strong>e</strong> 传入 method。下面会对 <strong>bind</strong> 是什么作出解释。</p><p>React events 同原生的 events 不完全相同，查看所有可用的 events 查看官方介绍：<a href="https://reactjs.org/docs/events.html">https://reactjs.org/docs/events.html</a></p><p>在 React 中一般情况下不需要通过调用 addEventListener 来给 element 添加 event listener。直接在 element 初始化时为其设置 event listener 即可。</p><p>当通过 class 来定义 component 时 event handler 一般是一个 class method，例如上面示例的 <strong>handleClick</strong>。</p><p>下面的示例我们构建一个 <strong>Toggle</strong> component 可以让用户通过一个 button 来切换 ON/OFF 状态：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

class Toggle extends React.Component {
    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }
}

ReactDOM.render(&lt;
    Toggle /&gt;,
    document.getElementById('root')
);</code></pre><p>在 <strong>JSX callback</strong> 中使用 <strong>this</strong> 需要特别注意，JavaScript class 的 methods 默认是相互隔离的，如果没有主动 <strong>bind</strong> 捆绑 method 到 <strong>this</strong>，在另一个 method 中使用 <strong>this.method</strong> 会报错 <strong>undefined</strong>。</p><p>如果调用 method 时不写括号<code>()</code> 例如：<code>onClick={this.handleClick}</code> 则需要提前 <strong>bind</strong> 这个 method 到 this 中，如上面的示例，<strong>bind</strong> 语法如下：</p><pre><code>this.handleClick = this.handleClick.bind(this);
</code></pre><p>一般将其放在 constructor 中，这样初始化中就会自动执行，当然也可以在调用时直接定义：</p><pre><code>&lt;button onClick={this.handleClick.bind(this)}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;
</code></pre><p><strong>如果不想使用 bind 语法来处理，那么还有两种方式来处理 class 中 methods 互相隔离这个问题。</strong></p><p><strong>第一种</strong>叫做 <strong>class fields syntax</strong> 语法，通过使用 <strong>arrow function</strong> 的模式定义 method，这样就可以通过通过 this.method 的方法调用 method：</p><pre><code>    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
    }
    handleClick = () =&gt; {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>这样就不需要在 constructor 中定义 <strong>bind</strong> 同时可以在 callback 中直接调用 this.handleClick。</p><p>但是需要注意目前这只是 React 实验性的语法，不一定保证以后会一直可用。</p><p><strong>第二种</strong>是在 callback 中通过 <strong>arrow function</strong> 的模式调用 method：</p><pre><code>    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={() =&gt; this.handleClick()} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>注意这种方法需要在 method 名称后加括号<code>()</code>。</p><p>这种方法的缺点是当每次重新 render 渲染时都会创建新的 callback。当这个 callback 包含传给其 child component 的 props 时，可能会导致 child 重新被渲染。通常情况下推荐使用 constructor 定义 <strong>bind</strong> 或者使用 <strong>class fields syntax</strong> 语法来避免这些性能问题。</p><h4>给 event handler 传入数据</h4><p>有时候需要给 event handler 传入附加的参数，如下面示例 button 点击时输出一个输入数据到终端：</p><pre><code>    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={this.handleClick.bind(this, 'aaa')} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>上面的示例将字符串 <strong>aaa</strong> 作为 handleClick 的传入参数，并将 bind 绑定过程直接放在 callback 中，这样就不需要在 constructor 中进行 bind 定义了。</p><p>通过 bind 绑定后会自动将 <strong>e</strong>：synthetic 综合的 event 作为第二个参数传入 function，<strong>e._reactName</strong> 返回 event 名称。</p><p>上面的示例也可以通过 <strong>arrow function</strong> 在 callback 中定义实现：</p><pre><code>    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={(e) =&gt; this.handleClick('aaa', e)} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>上面的示例中 e 依然表示 synthetic event。两种方法都会将 e 作为第二个参数传入。在 arrow function 中我们可以清晰地看到数据的位置，但是通过 <strong>bind</strong> 的方式会将有些参数自动转发过去。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2189.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2189.html</wfw:commentRss>
</item>
<item>
<title>React 入门教程之四 -- rendering, components 和 state</title>
<link>https://blog.niekun.net/archives/2184.html</link>
<guid>https://blog.niekun.net/archives/2184.html</guid>
<pubDate>Wed, 24 Feb 2021 17:17:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[rendering elements 渲染元素一个 element 表示我们想要显示在屏幕上的内容：const element = &lt;h1&gt;Hello, world&lt;/h1&g...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>rendering elements 渲染元素</h3><p>一个 element 表示我们想要显示在屏幕上的内容：</p><pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>不同于浏览器 DOM 中的 elements，React elements 是简单的 objects 且可以很方便的创建，React DOM 会严格的刷新 DOM 并匹配对应的 React elements。</p><p>容易混淆的概念是 component 和 element，区别是 component 是用来创建 element 的。在后续章节会介绍。</p><!--more--><h4>在 DOM 中渲染元素</h4><p>我们的 html 页面中定义了一个 div 容器：</p><pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>我们将其称作 <strong>root</strong> DOM 节点，因为它所有的内容都是被 React DOM 管理的。</p><p>通常情况下使用 React 创建的程序只有一个 <strong>root</strong> DOM 节点。如果你是将 React 整合到现有网站中，你可以有任意个独立的 <strong>root</strong> DOM 节点。</p><p>将 React elements 渲染到 <strong>root</strong> DOM 节点，需要通过调用 <code>ReactDOM.render()</code>，并将 React element 和 <strong>root</strong> DOM 节点作为传入参数：</p><pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;

ReactDOM.render(
    element,
    document.getElementById('root')
);</code></pre><p>此时页面会显示 hello world。</p><h4>刷新渲染的元素</h4><p>React element 是 immutable 不可改变的，当创建了一个 element 后不可以修改其 children 或 attributes，一个 element 就好像一个视频的一帧，它表示了某一时间点的 UI。</p><p>从我们目前学到的知识，唯一刷新 UI 的方法就是重新创建新的 elements 然后调用 <code>ReactDOM.render()</code>，通过设置 setInterval 来定时刷新：</p><pre><code>const tick = () =&gt; {
    const element = &lt;h1&gt;{new Date().toLocaleTimeString()}&lt;/h1&gt;;

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>这样就会每秒钟创建一个新的 element 并通过 <code>ReactDOM.render()</code> 渲染到界面。</p><p>通常情况下大多数 React app 只会调用 <code>ReactDOM.render()</code> 一次。下一章节会介绍如何将封装到 component 中。</p><h3>React 只会更新必要的内容</h3><p>React DOM 会比较其当前和上一个状态的，然后只对有了变化的部分进行更新来达到最终期望的状态。</p><p>我们打开上面示例的运行页面，通过chrome 的开发工具查看 elements 情况，可以看到只有时间元素每秒在刷新：<br>![2021-02-24T07:44:17.png][<br>即使我们每秒钟都新建并渲染 element，但是只有时间文本 node 是一直通过 React DOM 在刷新的。通过以上的实验，思考我们的 UI 在某个时间点应该是什么样的，而不是只想这着去修改它。</p><h3>components 和 props</h3><p><strong>components</strong> 将 UI 元素分割为独立的，可复用的片段，每个片段都是单独存在的。这一章节介绍 component 的概念，更多细节参考：<a href="https://reactjs.org/docs/react-component.html">React.Component</a></p><p><strong>components</strong> 类似于 JavaScript 的 functions，它可以接受抽象的输入数据(<strong>props</strong>)，然后返回 React elements 用来在界面上显示。</p><h4>Function 和 Class Components</h4><p>最简单的定义 component 方式就是定义一个 JavaScript function：</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;
}</code></pre><p>上面的 function 是一个有效的 React component，因为它接受一个单参数 <strong>props</strong> object 作为传入数据并返回一个 React element。我们称这种 component 为 function component。</p><p>也可以使用 ES6 的 class 定义 component：</p><pre><code>class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;hello, {this.props.name}&lt;/h1&gt;
    }
}</code></pre><p>以上两种定义方式是一致的。</p><p>需要注意的是 <strong>components</strong> 名称<strong>必须是以大写字母开头</strong>，因为 React 会见以小写字母开头的 components 作为 DOM tags 标签，如：<code>&lt;div /&gt;</code> 表示一个 html div 标签。</p><h4>rendering a component</h4><p>上面的介绍中，我们只遇到了 DOM tags 标签类型的 React elements，例如：</p><pre><code>const element = &lt;div /&gt;;
</code></pre><p>elements 也可以表示用户自定义的 components：</p><pre><code>const element = &lt;Welcome name='marco' /&gt;
</code></pre><p>当 React 检测到使用了用户自定义的 components 它会将此 JSX 内的 attributes 或 children 作为一个 object 传入 component，这个 object 叫做 <strong>props</strong>。</p><p>下面的示例会输出 <strong>hello, marco</strong>:</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name='marco' /&gt;;
ReactDOM.render(
    element,
    document.getElementById('root')
);</code></pre><p>以上示例过程如下：</p><ul><li>首先调用 <code>ReactDOM.render()</code> 渲染 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 元素.</li><li>React 调用 <strong>Welcome</strong> component 使用 {name: 'Sara'} 作为 <strong>props</strong>.</li><li><strong>Welcome</strong> component 返回一个 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 元素.</li><li><strong>React</strong> DOM 高效的更新 DOM 来匹配 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 结果.</li></ul><h3>构建 component</h3><p>component 可以在其输出中引入关联其他 components。这可以让我们在一个 component 内抽象出一个多层的结构。一个 button，一个 form，一个 dialog 或者一个 screen，在 React app 中他们都统称为 components。</p><p>例如我们可以创建一个 App component 来渲染多个 Welcome component：</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;Welcome name='marco' /&gt;
            &lt;Welcome name='tim' /&gt;
            &lt;Welcome name='jone' /&gt;
        &lt;/div&gt;
    )
}
ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);</code></pre><p>以上示例中，没有定义 App 的 props，因为不需要给其传入数据，也是可以的。</p><p>一般情况下，新建的 React app 只有一个顶层的 <strong>App</strong> component。</p><h4>拆解 component</h4><p>不要害怕将一个 component 拆解为多个小 components。例如下面这个 <strong>Comment</strong> component：</p><pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre><p>它的 props 包含一个 <strong>author</strong> object，一个 <strong>text</strong>，一个 <strong>data</strong>，描述了一个社交网站上一个 commit 的内容。</p><p>修改这个 component 有点困难，因为它有很多的嵌套，同时也难以复用它的内部组件。下面我们尝试拆解这个 component。</p><p>首先我们拆解出 <strong>Avatar</strong>：</p><pre><code>const Avatar = (props) =&gt; {
    return (
        &lt;img className=&quot;Avatar&quot;
            src={props.user.avatarUrl}
            alt={props.user.name}
        /&gt;
    );
}</code></pre><p><strong>Avatar</strong> 并不需要知道它被用于 <strong>commit</strong> 中，因此我们修改其 <strong>prop</strong> 名称为一个更加通用的：<strong>user</strong>。推荐从 component 本身为出发点命名 props，而不是考虑什么地方使用它。</p><p>现在我们可以简化 Commit component：</p><pre><code>function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;div className=&quot;UserInfo&quot;&gt;
                &lt;Avatar user={props.author} /&gt;
                &lt;div className=&quot;UserInfo-name&quot;&gt;
                    {props.author.name}
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>我们将 <strong>props.author</strong> 作为 <strong>user</strong> 数据传入 <strong>Avatar</strong> component 中。</p><p>下面我们拆解 <strong>UserInfo</strong>，其中包含一个 <strong>Avatar</strong> component：</p><pre><code>const UserInfo = (props) =&gt; {
    return (
        &lt;div className=&quot;UserInfo&quot;&gt;
            &lt;Avatar user={props.user} /&gt;
            &lt;div className=&quot;UserInfo-name&quot;&gt;
                {props.user.name}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>然后进一步简化 Commit：</p><pre><code>function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;UserInfo user={props.user} /&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>拆解 component 在开始看起来使工作量变大了，但是在稍微复杂写的 app 中我们就能够利用这些可复用的 components。一条基本准则是：如果 UI 中的某一部分被多次使用，如 button，panel，Avatar等，或者其自身结构比较复杂，如：App, FeedStory, Comment 等，将他们拆解为独立 components 是一个好的选项。</p><h4>props 是只读的</h4><p>当把一个 component 定义为 function 或 class 时，需要注意的是不可以修改 <strong>props</strong> 的值。</p><p>考虑下面的 function：</p><pre><code>function sum(a, b) {
  return a + b;
}</code></pre><p>以上的 function 被称作 pure 纯粹的，以为它没有尝试修改输入数据。</p><p>作为对比，下面的就是 impure 不纯粹的 function，因为会尝试修改它的输入数据：</p><pre><code>function sum(a, b) {
  a = b;
}</code></pre><p><strong>React</strong> 程序有一条限制条件：<strong>所有的 React components 都需要是 pure function 来对待 props 数据</strong>。</p><p>当然应用程序的 UI 是随时间动态变化的。下一节我们会介绍 state 的概念。通过 state 可以使 React components 在运行期间修改它们的输出 elements 来响应用户动作，网络响应等。同时不违反上面的那条规则。</p><h3>state 和 lifecycle</h3><p>这一节介绍 React components 中 state 和 lifecycle 的概念。</p><p>在前一章的示例中，我们通过一个 <strong>tick</strong> function 在指定时间间隔通过创建新 element 并渲染的方式刷新 UI：</p><pre><code>const tick = () =&gt; {
    const element = (
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            &lt;h2&gt;{new Date().toLocaleTimeString()}&lt;/h2&gt;
        &lt;/div&gt;
    );

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>下面我们介绍通过创建一个封装好的 <strong>Clock</strong> component，设置定时器并更新其自身。</p><p>首先我们根据上面的示例创建 <strong>Clock</strong> component：</p><pre><code>const Clock = (props) =&gt; {
    &lt;div&gt;
        &lt;h1&gt;hello world&lt;/h1&gt;
        &lt;h2&gt;{props.date.toLocaleTimeString()}&lt;/h2&gt;
    &lt;/div&gt;
}

const tick = () =&gt; {
    ReactDOM.render(
        &lt;Clock date={new Date()} /&gt;,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>在 <strong>tick</strong> 调用 <strong>Clock</strong> component 并定义 <strong>date</strong> prop 的数据供 Clock 使用。但是上面的实现缺乏一个基本需求，那就是 Clock 应该在其自身中定义定时器并每秒刷新数据的。</p><p>我们想要在渲染时达到如下效果调用 Clock：</p><pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);</code></pre><p>为了实现上述功能，需要为 <strong>Clock</strong> 添加 <strong>state</strong>。<strong>state</strong> 类似于 <strong>props</strong> 但是它是由 component 私有且完全控制的。</p><p>首先我们需要将 component 转换为 class 模式，转换过程如下：</p><ul><li>首先创建一个 ES6 class，且继承自 <strong>React.Component</strong>。</li><li>添加一个 <code>render()</code> function，将原 component function 的返回元素放入其返回值中</li><li>在 <code>render()</code> 中用 <strong>this.props</strong> 代替 <strong>props</strong></li></ul><pre><code>class Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.props.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>当 update 更新发生时会自动调用 <strong>render</strong> function。但当我们将 <code>&lt;Clock /&gt;</code> 放入 DOM 后，将只会有一个 <strong>Clock</strong> object 实例被使用，这就让我们可以使用 <strong>state</strong> 或 <strong>lifecycle</strong> 等功能。</p><h4>添加 state</h4><p>下面我们将 <strong>date</strong> 数据直接放入 <strong>CLock</strong> component 中。</p><p>首先将 render 中的 <strong>this.props.date</strong> 修改为 <strong>this.state.date</strong>：</p><pre><code>class Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>然后添加 class constructor 构造器给 <strong>this.state</strong> 赋初值：</p><pre><code>class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>注意 class component 总是应该使用 constructor 且初始化参数为 props。child class 有 constructor 时需要调用 super 来初始化 parent class，具体语法参考我的 JavaScript 教程：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>然后删除渲染到 DOM 中 <strong>Clock</strong> 的 <strong>date</strong> prop，以及我们设置的 <strong>setInterval</strong> 定时器：</p><pre><code>ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>修改完成后的完整代码如下：</p><pre><code>class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>下面我们实现 Clock 设置自己的定时器并每秒更新。</p><h4>添加 lifecycle method</h4><p>对于包含很多 components 的程序，但某个 component 不再需要是需要及时释放其占用的资源。</p><p>我们需要 <strong>Clock</strong> 第一次在 DOM 中渲染时设置一个 timer 定时器，在 React 中叫做 <strong>mounting</strong> 载入。同时我们需要当 <strong>Clock</strong> 在 DOM 中被删除时清除这个定时器，在 React 中叫做 <strong>unmounting</strong> 卸载。</p><p>我们可以在 components 载入或载出时通过定义特殊的 method 来运行特定指令：</p><pre><code>  componentDidMount() {
  }

  componentWillUnmount() {
  }</code></pre><p>这些 methods 叫做 <strong>lifecycle methods</strong>。</p><p><strong>componentDidMount</strong> method 会在 component 第一次输出到 DOM 后被自动调用，我们可以将定时器定义在这里：</p><pre><code>    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }</code></pre><p>这样当 Clock 渲染到 UI 后会自动启动这个定时器。注意使用 this 定义的参数可以在 class 中任意地方被调用。</p><p>注意 <strong>setInterval</strong> 中定义的响应动作需要写在 callback 内 <code>() =&gt; {}</code> 中，不要直接写：<code>setInterval(this.tick, 1000)</code>。因为如果要在 callback 调用 method 需要在 constructor 中做如下定义：</p><pre><code>this.tick = this.tick.bind(this);
</code></pre><p><strong>componentWillUnmount</strong> method 会在 component 将要被删除时自动调用，我们将定时器在这里取消：</p><pre><code>    componentWillUnmount() {
        clearInterval(this.timerID);
    }</code></pre><p>接下来我们定义每秒都会自动运行的 <strong>tick</strong> method，通过 <code>this.setState()</code> 来更新本地 state 中的设置：</p><pre><code>    tick() {
        this.setState({ date: new Date() });
    }</code></pre><p>最终的完整代码如下：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = { date: new Date() }
    }

    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }

    componentWillUnmount() {
        clearInterval(this.timerID);
    }

    tick() {
        this.setState({ date: new Date() });
    }

    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>现在整个处理流程如下：</p><ul><li>当 <code>ReactDOM.render()</code> 传入 <code>&lt;Clock /&gt;</code> 后，React 调用 Clock 构造器初始化 state 为一个包含 date 的 object</li><li>然后 React 调用 Clock 的 <code>render()</code> 查询到需要显示的 UI 元素，然后更新 DOM 以匹配 Clock 的输出</li><li>当 Clock 的输出嵌入到 DOM 后会调用 <strong>componentDidMount</strong>，Clock 告诉浏览器设置一个定时器每秒调用 <code>tick()</code></li><li>每秒钟调用一次 <code>tick()</code>，这里面 Clock component 通过 <code>setState()</code> 配置了其 UI 更新任务，通过 <code>setState()</code> React 就知道了 state 发生了变化并再次调用 <code>render()</code> 监测需要显示的内容，此时的 <code>this.state.date</code> 和上一次的发生了变化，React 就会更新 DOM 到最新的状态。</li><li>当 Clock 从 DOM 中删除后，React 会调用 <strong>componentWillUnmount</strong> 并结束定时器</li></ul><h4>正确使用 state</h4><p>关于 state 的使用需要如下的几点要求。</p><p>第一点，<strong>不要直接修改 state</strong>。</p><p>下面的语法不会触发重新 render 渲染 component：</p><pre><code>this.state.comment = 'Hello';
</code></pre><p>正确的语法为使用 <strong>setState()</strong>：</p><pre><code>this.setState({comment: 'Hello'});
</code></pre><p>唯一可以对 state 赋值的是在 constructor 构造器中。</p><p>第二点，<strong>state 更新是异步的</strong>。</p><p>React 为了性能可能会在一次 component update 更新中捆绑多个 <strong>setState()</strong> 调用，由于 <strong>this.props</strong> 和 <strong>this.state</strong> 可能会被异步更新，所以不要依赖他们的数据来计算后续的 <strong>state</strong>。</p><p>如下示例可能会错误的更新 counter：</p><pre><code>this.setState({
  counter: this.state.counter + this.props.increment,
});</code></pre><p>为了实现是这个需求，使用 setState 的另一种格式：传入一个 function，第一个参数为当前 state，第二个参数为 props 然后内部计算 state 更新：</p><pre><code>this.setState(function (state, props) {
    return {
        counter: state.counter + props.increment
    };
});</code></pre><p>第三点，<strong>state 更新会合并</strong>。</p><p>当调用 <code>setState()</code> 后，会合并设置的 object 到当前 state 中。</p><p>如下示例，<strong>state</strong> 可能包含多个独立的变量：</p><pre><code>    constructor(props) {
        super(props);
        this.state = {
            posts: [],
            comments: []
        };
    }</code></pre><p>然后我们可以单独调用 <strong>setState()</strong> 来分别更新它们：</p><pre><code>    componentDidMount() {
        fetchPosts().then(response =&gt; {
            this.setState({
                posts: response.posts
            });
        });

        fetchComments().then(response =&gt; {
            this.setState({
                comments: response.comments
            });
        });
    }</code></pre><p>合并过程是自动完成的，所以通过 <strong>setState</strong> 修改 comments 只会更新 comments 而不会改变 posts。</p><h4>数据向下传递</h4><p>一个 component 的 child 或 parent 都不会知道当前 component 是包含 state 还是不包含，且不关心是通过 function 还是 class 方式构建的 component。所以 state 被认为是封装的不能够被外界所访问。</p><p>component 的 state 可以作为 props 向它的 child component 传递：</p><pre><code>&lt;FormattedDate date={this.state.date} /&gt;
</code></pre><p>如上所示 FormattedDate 可以接受 date prop，它并不知道数据来自 parent 的 state 还是 props：</p><pre><code>function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}</code></pre><p>通常这叫做 <strong>top-down</strong> 或 <strong>unidirectional</strong> 数据流。任何 state 都被某个特定 component 所有，state 的数据只能在其 component 的 child 中传递出去。</p><p>我们通过建立 <strong>App</strong> component 并构建三个 <strong>Clock</strong> component 来展示 component 之间是互相独立的：</p><pre><code>function App() {
    return (
        &lt;div&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);</code></pre><p>每个 Clock 都有个各自的定时器并独立更新。</p><p>在 React 中，components 定义为 stateful 还是 stateless 的取决于其在运行中可能的变化，可以在 stateful 的 component 中使用 stateless 的 component，反过来亦可。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2184.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2184.html</wfw:commentRss>
</item>
</channel>
</rss>