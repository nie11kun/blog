<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/">
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1977.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1973.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1968.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1966.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1958.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1956.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1953.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1946.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1940.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1927.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1977.html">
<title>brew 安装路径</title>
<link>https://blog.niekun.net/archives/1977.html</link>
<dc:date>2020-12-16T22:04:00+08:00</dc:date>
<description>brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。brew 默认安装路径为：/usr/local/Cellar，然后会在 /usr/local/opt/ 建立所安装的包的软连接。包安装好后如果不能正常执行，可以建立包的可执行程序的软连接到：/usr/local/bin/ 目录。比如安装 openssl：brew install openssl
安装后包的路径为：/usr/local/Cellar/openssl@1.1/1.1.1h。同时包的软连接在：/usr/local/Cellar/openssl。这时候执行命令：openssl version
返回的并不是刚才安装的版本，而是系统自带的老版本的。这时候可以建立可执行程序的软连接到对应路径：ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
这时候执行命令就可以得到正确的返回：openssl version
//OpenSSL 1.1.1h  22 Sep 2020
其他包的模式和此类似。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1973.html">
<title>QT 网络应用</title>
<link>https://blog.niekun.net/archives/1973.html</link>
<dc:date>2020-12-16T16:59:00+08:00</dc:date>
<description>最近研究了下 QT 如何访问网络，做一些简单总结。首先在 pro 文件内定义网络属性：QT  += network
如果需要连接 https 需要安装 openssl 工具，使用 QT 的 MaintenanceTool 工具找到 openssl toolkit 并安装。否则执行程序时 ssl 会报错。安装后需要将 openssl 路径加入系统 PATH，默认安装路径为：Qt/Tools/OpenSSL。根据需要将对应系统版本的 bin 路径加入 PATH 如：C:\Qt\Tools\OpenSSL\Win_x86\bin，里面包含相关 lib 库文件。添加方法参考：https://blog.niekun.net/archives/413.html。需要用到的 QT class：QNetworkAccessManagerQNetworkRequestQSslConfigurationQNetworkReply我们做一个示例，新建项目，在头文件添加相关引用：#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;public 栏添加触发网络访问的 function：public:
    void doRequest();private 栏定义指针：private:
    QNetworkAccessManager *manager;添加 private slots 用来处理服务器的回应：private slots:
    void replyFinished(QNetworkReply *reply);传入参数 reply 用来接收网络访问响应内容，对应于 signal: void QNetworkAccessManager::finished(QNetworkReply *reply)，signal 触发后的数据通过 connect 会自动传入 slot 中，下面在源文件中做详细定义。下面修改源文件，先在构造器中调用触发网络 function: doRequest()：MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    doRequest();
}下面实现 doRequest() 的内容：void MainWindow::doRequest() {
    manager = new QNetworkAccessManager(this);

    QSslConfiguration sSlConfig;
    sSlConfig.setDefaultConfiguration(QSslConfiguration::defaultConfiguration());
    sSlConfig.setProtocol(QSsl::TlsV1_2);

    QNetworkRequest request;
    request.setSslConfiguration(sSlConfig);
    request.setUrl(QUrl(&quot;https://info.niekun.net&quot;));
    request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);

    manager-&gt;get(request);

    connect(manager, &amp;QNetworkAccessManager::finished, this, &amp;MainWindow::replyFinished);
    connect(manager, &amp;QNetworkAccessManager::finished, manager, &amp;QNetworkAccessManager::deleteLater);
}首先实例化一个 QNetworkAccessManager 用来访问网络。然后构造我们的 request 和 ssl 的初始化内容，request 中设置了访问的网络地址，定义了一个 request 的 header。QNetworkAccessManager  的 object 使用 get function 来启动网络请求。然后我们使用 connect 根据网络请求发出后的响应来触发相关 slot function。signal 触发后的数据会传入 slot function 中。所以 signal：void QNetworkAccessManager::finished(QNetworkReply *reply) 触发后返回的数据 reply 自动作为传入数据给 replyFinished。第二个 connect 的作用是网络请求结束后释放相关内存，避免造成内存溢出。注意这里我使用了新版的 QT connect 语法，详细参考官方文档：https://wiki.qt.io/New_Signal_Slot_Syntax下面实现 replyFinished：void MainWindow::replyFinished(QNetworkReply *reply) {
    if(reply-&gt;error())
    {
        qDebug() &lt;&lt; &quot;ERROR!&quot;;
        qDebug() &lt;&lt; reply-&gt;errorString();
    }
    else
    {
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentTypeHeader).toString();
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::LastModifiedHeader).toDateTime().toString();;
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentLengthHeader).toULongLong();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
        qDebug() &lt;&lt; &quot;-----------------------&quot;;
        qDebug().noquote() &lt;&lt; reply-&gt;readAll();
    }
}reply 指向 &amp;QNetworkAccessManager::finished 的 QNetworkReply 数据。在此 function 中，我们输出 reply 中的部分信息来检测网络是否通畅。其他的可用类型可以查询：https://doc.qt.io/qt-5/qnetworkrequest.html#public-types注意使用 qDebug().noquote() 来自动将字符串中的 \n 作为换行处理。正常输出信息如下：&quot;text/plain&quot;
&quot;&quot;
0
200
&quot;OK&quot;
-----------------------
request info:
request: GET / HTTP/1.1
scheme: https
host: info.niekun.net
http_host: info.niekun.net
uri: /
request_uri: /
connection: 202130
remote_addr: 172.68.189.53
client_real_ip: 1.81.217.183
server_port: 443

other variates:
http_x_forwarded_for: 1.81.217.183
proxy_add_x_forwarded_for: 1.81.217.183, 172.68.189.53以上就是 QT 访问网络的简单教程。参考链接：https://www.bogotobogo.com/Qt/Qt5_Downloading_Files_QNetworkAccessManager_QNetworkRequest.php</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1968.html">
<title>c++ 字符串数组指针的研究</title>
<link>https://blog.niekun.net/archives/1968.html</link>
<dc:date>2020-12-08T21:37:00+08:00</dc:date>
<description>在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。一个简单的测试：    const char* test1 = &quot;abc&quot;;
    const string test2 = &quot;abc&quot;;

    cout &lt;&lt; test1 &lt;&lt; endl;
    cout &lt;&lt; *test1 &lt;&lt; endl;
    cout &lt;&lt; test2 &lt;&lt; endl;
    cout &lt;&lt; sizeof (test1) &lt;&lt; endl;
    cout &lt;&lt; sizeof (test2) &lt;&lt; endl;输出如下：abc
a
abc
8
24以前我的教程里提到过，字符串就相当于一个字符数组。指针会指向它的首个字符地址。test1 指针理论上存储着字符串的首地址。但我们可以看到直接输出 test1 会得到实际字符串内容，而不是首个字符地址。输出 *test 会得到正常的首字符内容。字符串指针使用 sizeof 得到这个指针所占用内存大小，而不是字符串内容的大小。同时我们可以发现，一个字符指针可以直接指向一个字符串，而不需要先定义一个字符串变量然后建立指针指向这个变量。这是因为一个字符串可以看做一个字符数组，同时它也是一个整体，字符指针可以直接定义指向它。下面测试 int 型数组：    const int test3[] = {1, 3 ,5};
    const int* test4 = test3;

    cout &lt;&lt; test3 &lt;&lt; endl;
    cout &lt;&lt; test4 &lt;&lt; endl;
    cout &lt;&lt; test4[0] &lt;&lt; endl;
    cout &lt;&lt; *test4 &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4) &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4[0]) &lt;&lt; endl;输出结果：0x7ffee8cbaa58
0x7ffee8cbaa58
1
1
8
4可以看到直接输出数组名称或指针名称得到的是数组所在地址。*test 和 test[0] 会得到数组第一位内容。test4 是一个指针，所以 sizeof 得到的是这个指针做占用的内存空间而不是数组本身占用空间。无法通过 sizeof 计算出数组个数。以上实验，我们先建立了一个 int 型数组变量，然后建立 int 型指针指向这个变量，如果直接在一行中建立一个指针指向一个数组会报错，这就和上面测试的字符指针不一样了。因为其他类型的数组不同于字符串，它的每个元素是独立的个体，所以无法使用一个指针直接指向他们全部。下面做最后一个测试：const char* test5[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

const string test6[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

int x = sizeof (test5)/sizeof(test5[0]);
cout &lt;&lt; test5 &lt;&lt; endl;
cout &lt;&lt; *test5 &lt;&lt; endl;
cout &lt;&lt; test5[0] &lt;&lt; endl;
cout &lt;&lt; *test5[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test5) &lt;&lt; endl;
cout &lt;&lt; sizeof(test5[0]) &lt;&lt; endl;

cout &lt;&lt; &quot;*************\n&quot;;

x = sizeof (test6)/sizeof(test6[0]);
cout &lt;&lt; test6 &lt;&lt; endl;
cout &lt;&lt; *test6 &lt;&lt; endl;
cout &lt;&lt; test6[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test6) &lt;&lt; endl;
cout &lt;&lt; sizeof(test6[0]) &lt;&lt; endl;输出结果如下：0x7ffee596ea40
abc
abc
a
4
32
8
*************
0x7ffee596e9e0
abc
abc
4
96
24由于字符串本身就是一个字符数组，所以一个字符串数组相当于一个二维的数组。定义字符串数组的指针，就是数组中每个字符串对应的指针的集合。所以这个数组指针本身不是字符串类型的，而它的每个指针元素都是字符串指针类型的。可以看到类似于第一组测试，非字符串的指针直接输出指针名称，所以 test5 得到字符串数组的地址。*test5 和 test5[0] 都表示指针数组第一个元素，也就是字符串类型的指针，根据第一组实验可以知道使用字符串指针名称输出本身字符串而不是地址，所以输出此指针可以直接得到字符串内容。*test5[0] 就是字符串指针的首字符地址内容，也就是得到第一个字符串第一个字符的内容。test5 指针数组使用 sizeof 得到的是这个指针数组总共占用的内存大小，也就是每个指针大小的总和。除以单个指针大小就可以得到这个数组指针的个数，也就是对应指向的数组的元素个数。test6 字符串数组使用 sizeof 得到的是这个字符串数组所有元素的占用内存大小，除以单个字符串大小就可以得到这个数组的元素个数。我们可以看到 test5 和 test6 使用 sizeof 都可以得到数组的元素个数，但他们的原理是完全不同的，一个是使用指针的内存大小，一个是使用数组本身的内存大小。总结：字符串的指针名称可以直接输出字符串内容而不是地址。其他指针类型指向的数据，如字符，数字，字符串数组，number 型数组等，指针名输出的都是数据地址。指针使用 sizeof 得到的是指针所占用的内存大小。可以使用 sizeof(*Pointer) 得到数据本身大小。字符串数组的指针使用 sizeof 得到指针数组的总大小，可以用来间接计算数组元素个数。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1966.html">
<title>macOS 下使用 QT 部署工具 macdeployqt</title>
<link>https://blog.niekun.net/archives/1966.html</link>
<dc:date>2020-12-05T23:53:15+08:00</dc:date>
<description>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。工具路径在 QT 安装目录的对应编译器 bin 目录下，如：/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：打开 ~/.zshrc 添加如下内容，可以使用 vim 来操作：export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin编辑完成后关闭文件，刷新源：source ~/.zshrc
现在就可以直接使用命令了：macdeployqt -h

部署的方法是直接在 macdeployqt 后提供 app 路径：macdeployqt path/to/test.app
执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 app/Contents/Frameworks 文件夹内。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1958.html">
<title>QT 添加第三方库</title>
<link>https://blog.niekun.net/archives/1958.html</link>
<dc:date>2020-12-02T11:52:00+08:00</dc:date>
<description>如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。GUI 添加使用 GUI 添加的好处是比较直观，使用鼠标点击即可。右键项目名称，点击 add library：选中 external library 点击 next：选择头文件所在目录路径：如果有 lib 库文件的话需要链接进来，没有的话可以不设置：其他保持默认然后点击 next 完成添加。我们打开 pro 文件可以看到在文件最后添加了相关内容：win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dlld
else:unix: LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll

INCLUDEPATH += $$PWD/../../../Library/boost_1_72_0
DEPENDPATH += $$PWD/../../../Library/boost_1_72_0pro 文件添加根据添加一个第三方库所增加的语句，我们可以手动直接编辑 pro 文件完成添加：LIBS 指定 lib 库文件路径，没有的话不需要定义INCLUDEPATH 指头文件所在目录DEPENDPATH 定义和头文件相同目录即可例如我们添加一个 boost filesystem 库到项目：LIBS += -L&quot;/path/to/boost_1_72_0/stage/lib/&quot; \
        -llibboost_filesystem-mgw81-mt-x32-1_72 \
        -llibboost_regex-mgw81-mt-x32-1_72

INCLUDEPATH += &quot;/path/to/boost_1_72_0&quot;
DEPENDPATH += &quot;/path/to/boost_1_72_0&quot;LIBS 中，使用 -L 添加 lib 库目录，使用 -l 添加具体某个库文件，可以不写文件后缀。以上就是 QT 中添加第三方库的方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1956.html">
<title>Macros 聚集 in c++</title>
<link>https://blog.niekun.net/archives/1956.html</link>
<dc:date>2020-12-01T11:37:00+08:00</dc:date>
<description>在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符作为 macro 名称，甚至是 c 关键词。object 形式object 形式的 macro 就是简单的使用一个 identifier 代替代码片段。使用 #define 定义一个 macro：#define TESTINT 1024

void main() {
    int a = TESTINT;
    cout &lt;&lt; a &lt;&lt; endl;
}

//output:
//1024也可以定义一个片段：#define NUMBERS 1, 2, 3

void main() {
    int x[] = { NUMBERS };
    //int x[] = { 1, 2, 3 };这两句效果相同
}也可以多层定义：#define NUMBER1 1
#define NUMBER2 NUMBER1以上示例中 NUMBER2 等于 NUMBER1。function 形式可以定义 function 形式的 macro，需要在定义中 macro 名称后加上圆括号()。例如：#define lang_init()  c_init()定义后就可以使用 lang_init() 来调用 c_init() 了，类似于 alias。object 类型的 macro 可以和 function 类型的 macro 同名，区别就是有没有圆括号：#define test 100
#define test() func()

void main() {
    int a = test;
    test();
}以上就是对 macro 的简单介绍。参考链接：https://gcc.gnu.org/onlinedocs/cpp/Macros.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1953.html">
<title>c++ 中 string 字符串的含义</title>
<link>https://blog.niekun.net/archives/1953.html</link>
<dc:date>2020-11-25T11:52:00+08:00</dc:date>
<description>有如下代码：int main()
{
    char *s;
    s = &quot;hello&quot;;

    cout &lt;&lt; *s &lt;&lt; endl;
    cout &lt;&lt; s &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//h
//hello首先定义了一个指针，然后给指针赋值为一个字符串。看起来以上写法有错误，s 指针是一个地址，为什么给它赋值一个字符串？因为在 c++ 中字符串类似于我们提到的数组，使用数组名就表示第一个数组元素的地址。例如：int main()
{
    int arr[] = {1, 3};
    int *p = arr;

    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *(p+1) &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//1
//3同样在字符串中，s = &quot;hello&quot; 表示将首字母 h 的地址赋给指针。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1946.html">
<title>c++ 中数组类型数据作为 function 参数时的注意事项</title>
<link>https://blog.niekun.net/archives/1946.html</link>
<dc:date>2020-11-25T11:16:00+08:00</dc:date>
<description>关于 function 的基础教程参考：C++ 入门教程之四 -- Functions当 function 的传入参数为数组时，如果我们想要得到数组元素个数可能会这样写：void testFunc(int arr[]) {
    int count = sizeof(arr)/sizeof(arr[0]);
}

int main()
{
    int arr[] = {1, 3, 6, 8};
    cout &lt;&lt; testFunc(arr) &lt;&lt; endl;

    return 0;
}sizeof function 可以返回数据占用内存空间的大小。所以用整个 arr 大小除以第一个元素大小可以得到数组元素个数。但是测试会发现以上得到的 count 值并不是 arr 数组元素个数 4 而是 2。这是因为当 function 传入数组数据时，会自动将其转换为 pointer 指针类型。这时候使用 sizeof() 得到的不是 arr 数据所在地址的内存大小，而是这个指向 arr 数组的指针所占用内存大小。我们做个实验：int main()
{
    int *arrP = new int[4];
    cout &lt;&lt; sizeof(arrP) &lt;&lt; endl;
    cout &lt;&lt; sizeof(arrP[0]) &lt;&lt; endl;
    return 0;
}

//output:
//8
//4以上建立了一个指针指向 4 个元素的数组，然后分别查看其整个指针和某个元素指针的内存大小，得到的结果是 8 和 4。所以他们两个相除结果为 2。因为指针指向的是数组第一个元素，如果我们要通过指针给数组元素赋值，可以使用 *(pointer + n) 的方式完成，例如：int *arrP = new int[4];
*arrP = 1;
*(arrP+1) = 2;*(arrP+1) 就是第 2 个数组元素。可以用指针查询数组中某个元素的内存大小，数组名 arr 表示数组所在地址(不需要加地址转换符&amp;)：int main()
{
    int arr[] = {1, 3, 6, 8};
    int *arrP = arr;

    cout &lt;&lt; sizeof(*arrP) &lt;&lt; endl;
    cout &lt;&lt; sizeof(*(arrP+1)) &lt;&lt; endl;

    return 0;
}

//output:
//4
//4由于 arr 数组名表示此数组第一个元素所在地址的指针，所以我们可以直接使用此名称来用指针的方式地区元素数据：int main()
{
    int arr[] = {1, 3, 6, 8};
    cout &lt;&lt; *arr &lt;&lt; endl;
    cout &lt;&lt; *(arr+1) &lt;&lt; endl;

    return 0;
}

//output:
//1
//3那么如何在 function 使用数组作为传入数据时如何能够直接使用它的数据而不是指针类型呢？可以使用以下方法：template &lt;size_t N&gt;
int testFunc(int (&amp;arr)[N]) {
    int count = sizeof(arr) / sizeof(arr[0]);
    return count;
}

int main()
{
    int arr[] = {1, 3, 6, 8};
    int count = testFunc(arr);

    cout &lt;&lt; count &lt;&lt; endl;
    return 0;
}

//OUTPUT:
//4创建一个 function template，size_t 类型表示任意数据类型的元素占用内存大小，此处将其作为 generic data type 用来定义实际传入的数组所占用内存容量的 template，然后以传入数据的实际地址的模式将数组的元素都顺序都传入 function。这样传入数据就是实际数据地址而不是指针。关于 function 的传入数据实际地址是使用指针形式 * 还是 &amp; 形式，在前面我介绍过，形式如下：void test1(int *a) {
    *a = 3;
}

void test2(int &amp;a) {
    a = 2;
}

int main()
{
    int a = 1;
    int *p = &amp;a;

    test1(p);
    cout &lt;&lt; a &lt;&lt; endl;

    test2(a);
    cout &lt;&lt; a &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//3
//2function 中使用在指针类型的传入数据时需要传入一个指针，当定义为 &amp; 时可以直接传入数据名称。两种方法都是 by reference 会影响到对应内存地址的数据内容。可参考教程：C++ 入门教程之四 -- Functions参考链接：https://stackoverflow.com/questions/4839626/element-count-of-an-array-in-chttps://www.tutorialspoint.com/cplusplus/cpp_pointer_to_an_array.htm</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1940.html">
<title>C++ 入门教程之八 -- Templates - Exceptions - Files</title>
<link>https://blog.niekun.net/archives/1940.html</link>
<dc:date>2020-11-23T21:41:00+08:00</dc:date>
<description>function template使用 function 和 class 使我们编程更加简单及易操作。但是它们仍然受限于 c++ 编程规范，在定义它们的参数时必须指定参数的类型。例如：int sum(int a, int b) {
  return a+b;
}

int main () {
  int x=7, y=15;
  cout &lt;&lt; sum(x, y) &lt;&lt; endl;
}以上示例中，需要我们定义sum function 需要传入两个 int 型数据，返回其相加结果。在 main 中调用 sum function。sum() 可以正确的执行指令，但它的限制是必须传入 int 类型的数据。如果需要实现两个 double 类型数据相加，需要再次定义新 funtion：double sum(double a, double b) {
  return a+b;
}使用 function template 能够让我们只定义一个 sum() 来适用于所有类型的数据。使用关键词 template 来定义一个 function template，在尖括号&lt;&gt;内定义通用数据类型：template &lt;class T&gt; 
关键词 class 表示一个申明要定义 generic 通用数据类型，注意不要和我之前学习的 class 混淆。也可以使用关键词 typename：template &lt;typename T&gt; 
T 表示我们的 generic 通用数据类型名称，在后续中可以使用此名称代表数据类型，可以是任意自定义字符。修改我们的示例：#include &lt;iostream&gt;
using namespace std;

template &lt;class T&gt;
T sum(T a, T b)
{
    return a + b;
}

int main()
{
    int x=7, y=15;
    cout &lt;&lt; sum(x, y) &lt;&lt; endl;

    double a=7.15, b=15.54;
    cout &lt;&lt; sum(a, b) &lt;&lt; endl;

    return 0;
}我们在 function 中建立了一个 generic data type 通用数据类型 T，返回值和传入参数类型都为 T。在 mian 中调用时，会根据实际传入数据类型来动态确定 T 的实际类型。function template 可以节省编程中很多时间，因为只需要一次定义就可以兼容不同的数据类型。我们也可以同时定义多个 generic data type，使用逗号, 分隔多个定义类型：template &lt;class T, class U&gt;
T smaller(T a, U b) {
  return (a &lt; b ? a : b);
}

int main () {
  int x=72;
  double y=15.34;
  cout &lt;&lt; smaller(x, y) &lt;&lt; endl;
}以上示例定义了两个通用数据类型，返回值类型为第一种数据类型。(a &lt; b ? a : b) 表达式的意思是：判断 a 是否小于 b，如果结果为 true 则返回 a 的值，如果结果为 flase 返回 b 的值，两个参数可以是不同数据类型，如：int 和 double。在 mian 中调用 smaller function，返回结果为两个参数中较大的那个的值，由于返回值类型为第一个定义数据类型 T，而我们调用时传入的第一个参数类型为 int，所以返回结果也为 int 型。需要注意的是在一旦定义了 function template，在 function 中就一定要使用定义的那些通用数据类型，否则编译器会报错。class template同样也可以定义 class template，允许 class 的元素类型为 generic data type。语法如下：template &lt;class T&gt;
class MyClass {

};类似于 function template，多个 generic data type 使用逗号, 分隔：template &lt;class T,class U&gt;
下面举例说明使用方法：template &lt;class T&gt;
class Pair {
    public:
    Pair (T a, T b):
    first(a), second(b) {
    }
    
    private:
    T first, second;
};以上建立了一个 class template，类型为 T，通过构造器对 private 里的两个 T 类型的参数初始化数据。在 class template 外定义 function，如 class 大括号外或一个单独文件，需要在 class 后标记 class template 内定义过的 generic type。例如在以上示例的 class 外建立 bigger function：template &lt;class T&gt;
class Pair {
    public:
    Pair (T a, T b):
    first(a), second(b) {
    }
    T bigger();

    private:
    T first, second;
};

template &lt;class T&gt;
T Pair&lt;T&gt;::bigger() {
    return (first&gt;second ? first : second);
}上面示例中使用了 scope resolution operator - 范围解析符:: 来表示外部的 Pair() function 属于哪个 class，在头文件章节介绍过，具体参考：C++ 入门教程之六 -- Classes 实践。bigger function 返回 class 两个属性变量中较大的值。在 main 中实例化 Pair class 时需要使用尖括号定义当前实际要使用的数据类型，如 int 类型：void main() {
    Pair&lt;int&gt; obj(11, 22);
    cout &lt;&lt; obj.bigger() &lt;&lt; endl;
}也可以定义 double 类型：void main() {
    Pair&lt;double&gt; obj(11.23, 22.56);
    cout &lt;&lt; obj.bigger() &lt;&lt; endl;
}template 特例在前面介绍的 class template 中，实例化 object 时定义不同的数据类型会执行同样的 function 指令内容。template specialization 特例允许当我们定义某些特定数据类型作为 template type 时执行和通用指令不同的内容。下面举例说明，当定义数据类型为 char 时执行和其他数据类型不同的指令，先建立一个常规 class template：template &lt;class T&gt;
class MyClass {
public:
    MyClass(T x) {
        cout &lt;&lt; x &lt;&lt; &quot; - not a char&quot; &lt;&lt; endl;
    }
};以上 class 用来作为常规数据类型情况下的处理。为了处理当数据类型为 char 时的情况，我们建立一个 class specialization 特例：template &lt;&gt;
class MyClass&lt;char&gt; {
public:
    MyClass(char x) {
        cout &lt;&lt; x &lt;&lt; &quot; - is a char&quot; &lt;&lt; endl;
    }
};以上代码中，首先在 class 前声明了一个没有参数的 template &lt;&gt;，这是为了区别于通用数据类型情况，表明此 class specialization 里的数据类型是已知的和特定的。而由于这个 class 依然是属于 class template 类型的，只是一个特例情况的处理，所以这句声明不能省略。在 class template 名称后面的 &lt;char&gt; 定义了此 clas 属于对哪种 specialization 特例数据类型的处理。当我们实例化时，如果定义的数据类型是属于 template specialization 里定义的类型时，会将此 class 作为实例化对象。需要注意得是对常规数据类型的 class template 和特定类型数据的 class template 两者的 body 内容是完全独立互不影响的，specialization template 并不从 generic template 里继承任何元素，如果需要的话可以编写完全不同的功能。在 main 中使用不同数据类型进行实例化测试：int main() {
    MyClass&lt;int&gt; obj1(22);
    MyClass&lt;double&gt; obj2(11.34);
    MyClass&lt;char&gt; obj3('a');
    
    return 0;
}

//output:
//22 - not a char
//11.34 - not a char
//a - is a char可以看到 generic template 适用于数据类型：int 和 double，而 specialization template 适用于数据类型：char。exception 例外程序在执行中遇到问题叫做：exception 例外。在 c++ 中，exception 是对程序遇到反常情况的反应。如：0做除数时。c++ 的 exception handling 例外管理器是通过三个关键词：try，catch 和 throw 来建立的。throw 是用来当问题出现时调出某一个 exception 响应动作的。例如：int motherAge = 40;
int sonAge = 50;
if (sonAge &gt; motherAge) {
    throw 99;
}以上示例中，当 sonAge 大于 motherAge 时，程序首先会自动识别 throw 语句中元素的数据类型，然后根据这个数据类型去寻找处理这类数据类型的 exception 块。最后使用 throw 内的数据作为传入参数在 exception 中使用。throw 中的数据类型可以是任意的，如 123 为 int 型，a 为 char 型，11.24 为 double 型，一下示例写法都是正确的：int motherAge = 40;
int sonAge = 50;
if (sonAge &gt; motherAge) {
    throw ‘a’;
}

if (sonAge = motherAge) {
    throw 12.45;
}catching exception那么具体如何响应 exception 呢？需要使用 try/catch block 模块来构造完整的 throw 和 response 过程。一个 try block 块用来激活特殊情况的 exception 功能，在 try 后面需要跟一个或多个 catch block 块来执行某种特定 throw 类型的 exception 动作。在 catch 后需要定义特定的数据类型对应于 throw 的某种数据类型。下面举例说明：try {
    int motherAge = 40;
    int sonAge = 50;
    if (sonAge &gt; motherAge) {
        throw 99;
    }
} catch (int x) {
    cout &lt;&lt; &quot;wrong age value - Error&quot; &lt;&lt; x &lt;&lt; endl;
} catch (char x) {
    cout &lt;&lt; &quot;example for other catch&quot; &lt;&lt; x &lt;&lt; endl;
}

//output: wrong age value - Error99以上例子中，try 块 throw 了一个 exception，throw 的数据 99 是 int 类型，所以匹配到 catch 中定义类型也为 int 型的 exception 块。然后将 99 作为传入数据在 exception 中使用。当只有一种 exception 情况是，只需要定义一个 throw 和一个 catch 块即可。下面的示例是提示用户输入两个数字，然后将它们相除，exception 的情况是当第二个数为 0：try {
    int num1;
    cout &lt;&lt; &quot;enter the first number:&quot;;
    cin &gt;&gt; num1;
    
    int num2;
    cout &lt;&lt; &quot;enter the second number:&quot;;
    cin &gt;&gt; num2;
    
    if (num2 == 0) {
        throw 0;
    }
    cout &lt;&lt; &quot;result: &quot; &lt;&lt; num1 / num2 &lt;&lt; endl;
} catch (int x) {
    cout &lt;&lt; &quot;division by zero!&quot; &lt;&lt; endl;
}cin 是 istream class 类型的 object 用来输入数据流，数据输入后会存在后面的变量中。当输入的第二个数字非零时不会触发 exception 响应，当为零时 throw 类型为 int，然后匹配到 exception 中类型也为 int 的块，然后执行其中指令。如果以上程序中不考虑输入数据是否为 0，则当除数为 0 时程序会崩溃。catch 块也可以管理在 try 块中任何类型的 throw exception，不同于catch 后定义某一种数据类型，使用省略号(...) 来表示响应任何类型的 throw，例如：try {
//...
} catch (...) {
    cout &lt;&lt; &quot;division by zero!&quot; &lt;&lt; endl;
}这样当 try 块 throw 一个 exception 时，无论 throw 类型为什么都会匹配到此通用 catch 块。Files 文件处理c++ 另一个常用的功能就是对文件的读写操作，需要用到 c++ 标准库：`'在 fstream 中定义了三种数据类型：ofstream：输出文件流，用来创建或写入文件ifstream：输入文件流，用来读取文件信息fstream：通用文件流，包含 ofsteam 和 ifstream 的内容，支持创建，读入，写入文件。在 c++ 中对文件操作需要 include iostream 和 fstream:#include &lt;iostream&gt;
#include &lt;fstream&gt;对文件操作的一些 class 直接或间接继承自 istream 和 ostream，例如在上一节用到的 cin 就是 istream class 的一个 object，cout 是 ostream class 的一个 object。打开文件及写入在对文件进读写前，需要首先打开它。ofstream 和 fstream 的 object 都可以用来打开文件然后进行写操作，我们打开一个 test.txt 文件然后写入内容最后关闭文件：#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main() {
    ofstream MyFile;
    MyFile.open(&quot;test.txt&quot;);
    MyFile &lt;&lt; &quot;some text.\n&quot;;
    MyFile.close();

    return 0;
}以上代码创建一个 ofstream 类型的 object，使用 open function 打开一个文件，然后给这个文件写入内容，最后关闭文件。如果此文件不存在则 open function 会自动创建。可以看到使用了和之前操作 iostream 同样的 stream 流操作符 &lt;&lt;。open function 打开的文件可以是一个路径，如果只有文件名则默认在程序根目录。也可以使用 ofstream 的构造器直接给 object 初始化定义文件路径：int main(int argc, const char * argv[]) {

    ofstream MyFile(&quot;test.txt&quot;);
    MyFile &lt;&lt; &quot;some text.\n&quot;;
    MyFile.close();
    
    return 0;
}使用 open function 的区别是可以定义一个文件的绝对路径，可以和程序不在一个目录。在特定情况下，使用 open function 打开文件会无效，如：没有权限打开文件。这时候可以使用 is_open function 来确认文件是否已经被正确打开且可以被访问：int main(int argc, const char * argv[]) {

    ofstream MyFile(&quot;test.txt&quot;);
    if (MyFile.is_open()) {
        MyFile &lt;&lt; &quot;some text.\n&quot;;
    } else {
        cout &lt;&lt; &quot;somethin went wrong&quot; &lt;&lt; endl;
    }
    MyFile.close();
    
    return 0;
}is_open function 检查文件是否被正常打开，返回值为：true 或 false。open function 的第二参数可以用来定义文件打开模式，一下是支持的模式列表：以上的 flag 标记可以结合起来使用，用或操作符| 来分隔。例如使用 write 模式同时 truncate 文件，使用一下语句：ofstream outfile;
outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );读取文件类似于写文件，读取文件需要一个 ifstream 或 fstream 的 object。示例如下：string line;
ifstream ReadFile(&quot;test.txt&quot;);
if (ReadFile.is_open()) {
    while (getline(ReadFile, line)) {
        cout &lt;&lt; line &lt;&lt; endl;
    }
} else {
    cout &lt;&lt; &quot;fail to open file&quot; &lt;&lt; endl;
}首先创建一个 ifstream class 的实例 ReadFile并初始化文件地址。如果文件打开正常则使用 getline function 来一行行的读取文件内容到字符串 line，然后打印到输出。getline function 属于 istream class，会逐行读取来自 istream 输入流的内容到一个字符串变量，每次执行都会自动换行定位到下一行输入流 istream 的内容直到结尾会跳出 while 循环。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1927.html">
<title>C++ 入门教程之七 -- 继承和多态</title>
<link>https://blog.niekun.net/archives/1927.html</link>
<dc:date>2020-11-21T22:31:00+08:00</dc:date>
<description>inheritance 继承inheritance 继承是面向对象编程最重要的概念之一。继承允许我们基于已有的 class 创建新的 class。这能够极大的方便我们创建应用程序。一个 class 的属性被其他 class 继承，我们称这个 class 叫做 base class。一个从 base class 继承属性的 class 我们称其为 derived class。一个 derived class 获得所有 base class 的功能，且可以有自己独有的功能：继承的概念是 is a 属于是什么 的关系，例如：猫 is a 动物，狗 is a 动物。两者都继承了动物的属性。我们来建立两个 class：Mother 和 Daughter：class Mother
{
 public:
 Mother() {};
 void sayHi() {
   cout &lt;&lt; &quot;Hi&quot;;
 } 
};

class Daughter 
{
 public: 
 Daughter() {};
};Mother 有一个 sayHi() function。下面我们让 Daughter 继承 Mother 的属性，Daughter class 名称修改如下：class Daughter : public Mother
{
 public: 
 Daughter() {};
};使用一个冒号: 标记 base class。access specifier 访问标记符 public 表示所有 base class 里 public 段下的内容继承给 derived class 里的 public 段下。以上示例中 Daughter 继承了所有 Mother 的 public 下的元素，所以我们可以实例化一个 Daughter 的 object 然后调用 sayHi() function 了：#include &lt;iostream&gt;

using  namespace std;

class Mother
{
 public:
 Mother() {};
 void sayHi() {
   cout &lt;&lt; &quot;Hi&quot; &lt;&lt; endl;
 }
};

class Daughter: public Mother
{
 public:
 Daughter() {};
};

int main(int argc, const char * argv[]) {
    Daughter d;
    d.sayHi();
    return 0;
}关于 access 访问标记符的使用，在下面会详细介绍使用方法。一个 derived class 可以继承所有 base class 的 function 出过一下几种特殊情况类型：constructor and destructor 构造器和销毁器复用操作符 functionfriend function一个 class 可以同时继承多个 base class，使用逗号, 分隔 base class，如：class Daughter: public Mother, public Father。protected 元素对于 class 中的元素的 access 访问表示符，我们前面使用了 public 和 private。public 里的元素可以被外界访问或修改，private 里的元素只能被 class 内部使用，或者通过 friend function 来读取。除了以上两种识别符外，还有一种类型：protected。在 protected 内的元素和 private 段内的很类似。唯一的区别是，protected 内的元素可以被 derived class 访问。例如我们给 Mother 添加一个 protected 元素：class Mother {
 public:
 void sayHi() {
   cout &lt;&lt; var;
 }

 private:
 int var=0;

 protected:
 int someVar;
};someVar 变量可以被 Daughter 访问。继承的类型access 访问标记符能够用来定义继承类型。在上面的示例中我们使用 public 作为访问标记符：class Daughter: public Mother。private 和 protected 同样可以被使用。三者的区别：Public Inheritance: base class 里 public 段内的元素继承到 derived class 里的 public 段内，base class 里 protected 段内的元素继承到 derived class 里 protected 段内，base class 里 private 段内的元素永远不能能够被 derived class 直接访问，但可以通过 public 或 protected 内的 function 来间接获取数据。Protected Inheritance: base class 里 public 和 protected 段内的元素继承到 derived class 里的 protected 段内。Private Inheritance: base class 里 public 和 protected 段内的元素继承到 derived class 里的 private 段内。public 继承类型在继承中是最常用的。如果在程序中没有指定某个继承类型，则默认为 private。构造器和销毁器上面提到了 derived class 不会继承 base class 的构造器和销毁器。但是 derived class 的实例 object 在被建立和销毁时，base class 的构造器和销毁器会被自动调用。我们建立 Mother class：class Mother
{
 public:
 Mother() {
   cout &lt;&lt; &quot;mother's constructor&quot; &lt;&lt; endl;
 }
 ~Mother() {
   cout &lt;&lt; &quot;mother's destructor&quot; &lt;&lt; endl;
 }
};

int main(int argc, const char * argv[]) {
    Mother m;
    return 0;
}实例化 Mother 后，输出如下：mother's constructor
mother's destructor然后我们建立 Daughter class：class Daughter: public Mother
{
 public:
 Daughter() {
    cout &lt;&lt; &quot;daughter's constructor&quot; &lt;&lt; endl;
 }
 ~Daughter() {
   cout &lt;&lt; &quot;daugther's destructor&quot; &lt;&lt; endl;
 }
};

int main(int argc, const char * argv[]) {
    Daughter d;
    return 0;
}实例化 Daughter 后，输出如下：mother's constructor
daughter's constructor
daugther's destructor
mother's destructor可以看到当 Daughter 的 object 创建时，首先 base class 的构造器被调用，然后调用 derived class 的构造器。当 object 销毁时，首先 derived class 的销毁器被调用，然后 base class 的销毁器被调用。你可以理解为 derived class 依赖于 base class 才能工作，所以 base class 需要首先被执行。多态性polymorphism 多态化意思是：拥有多种样式。通常多态化出现在那些有着继承关系的 class 中。在 c++ 中多态性意思是在调用同一个 function 时随着 object 类型的不同而有着不同的执行效果。下面举例说明：我们创建一个游戏，有两种人物：monster 怪物和 ninja 忍者。他们都有一个共同的 function：attack，但是两者攻击的模式是不同的。在这个场景下，多态性能够实现不同的 objects 调用同样的 attack function 而有不同的实现效果。首先创建一个 Enemy class：class Enemy {
 protected: 
 int attackPower;

 public:
 void setAttackPower(int a){
  attackPower = a;
 }
};Enemy class 有一个public function：setAttackPower 来设置 protected 里的参数：attackPower。然后我们建立两个 derived class 以 Enemy 为 base class，各自有独立的 attack function：class Ninja: public Enemy {
 public:
 void attack() {
   cout &lt;&lt; &quot;Ninja! - &quot;&lt;&lt;attackPower&lt;&lt;endl;
 }
};

class Monster: public Enemy {
 public:
 void attack() {
   cout &lt;&lt; &quot;Monster! - &quot;&lt;&lt;attackPower&lt;&lt;endl;
 }
};在 main 中实例化：int main() {   
 Ninja n;
 Monster m;  
}由于 Monster 和 Ninja 都继承自 Enemy，所以他们的实例 object 也都是 Enemy 类型的 object。我们可以如下定义：Enemy *e1 = &amp;n;
Enemy *e2 = &amp;m;我们定义两个 Enemy 类型的指针指向两个 object。在 main 中调用对应的 function：int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    
    n.attack();
    m.attack();
    return 0;
}两个指针都是 Enemy 类型的，所以可以用来使用 Enemy 中的 function 设置参数，然后分别调用 derived class 的 object 的 attack function。注意这里没法用这两个指针直接调用 attack()，因为 Enemy 中并没有定义这个 function。虚拟 function上面的示例中，我们使用 Enemy 类型的指针指向了 derived class 的 object。但是我们无法使用这个指针调用 attack function，因为在 base class 中不包含这个 function。为了实现这个功能，需要在 base class 中定义一个 attack 的 virtual function。virtual function 的意义就是在 base class 里定义一个 function，在 derived class 内 override 重写这个 function，这样就可以实现多态化，使用 base class 类型的指针调用同一个 function 根据 derived class 的不同而实现不同的功能。使用关键词 virtual 定义 virtual function：class Enemy {
    protected:
    int attackPower;
    
    public:
    virtual void attack() {}
    void setAttackPower(int a){
        attackPower = a;
    }
};在 Enemy class 中我们定义一个 attack 的 virtual function，然后在两个 derived class 中重写这个 function 使其有着不同的内容。现在我们就可以使用 Enemy 类型的指针调用 attack function了：int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    
    e1-&gt;attack();
    e2-&gt;attack();
    return 0;
}virtual function 类似于一个模版，告诉 derived class 可以定义属于自己的这个 function 功能。指针在调用时会根据 object 属于哪个 derived class 而去具体完成指令。一个包含有 virtual function 的 class 称之为多态化的 class。当然在 base class 内的 virtual function 也可以给其具体的指令，我们给 Enemy class 里的 virtual attack function 定义内容：class Enemy {
    protected:
    int attackPower;
    
    public:
    virtual void attack() {
        cout &lt;&lt; &quot;Enemy! - &quot; &lt;&lt;attackPower &lt;&lt; endl;
    }
    void setAttackPower(int a){
        attackPower = a;
    }
};然后创建一个 Enemy 的 object 及其指针，尝试调用其 attack function：int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy e;
    
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    Enemy *e3 = &amp;e;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    e3-&gt;setAttackPower(30);
    
    e1-&gt;attack();
    e2-&gt;attack();
    e3-&gt;attack();
    return 0;
}输出如下：Ninja! - 20
Monster! - 80
Enemy! - 30这就是多态化 class 的优势，不同的 derive class 使用同一名称的 function 在不同的场景下执行不同的指令。abstract class当我们在 base class 中定义 virtual function 时，在 base class 中并没有此 function 具体要实现的内容，只有在 derived class 中才需要做定义。这种情况下，可以将 base class 中的 virtual class 定义为 pure virtual functions 纯粹的虚拟 function 而不需要定义它的任何内容。使用 =0 来进行表示：class Enemy {
 public:
  virtual void attack() = 0;
}; 如果 base class 中定义了 pure virtual functions，那么在 derived class 中必须重写此 function，否则在实例化 derived class 时编译器会报错。这种包含有 pure virtual functions 的 class 叫做 abstract class 抽象化的 class，这种 class 不能直接实例化 object，会产生报错。必须实例化其 derived class 且重写了 virtual function。现在实例化 Enemy 的 object 会报错：Enemy e; // Error
这种 pure virtual functions 的好处是，我们可以直接定义 base class 类型的指针指向不同的 derived class object，然后使用同样的 function 名称来执行不同的指令。</description>
</item>
</rdf:RDF>