<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/">
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1997.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1996.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1992.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1990.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1985.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1979.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1977.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1973.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1968.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1966.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1997.html">
<title>JavaScript 入门教程之六 -- 核心 Objects</title>
<link>https://blog.niekun.net/archives/1997.html</link>
<dc:date>2020-12-18T18:53:00+08:00</dc:date>
<description>下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。JavaScript Arrays 数组当你需要定义三个课程名称时，需要分别定义：var course1 =&quot;HTML&quot;; 
var course2 =&quot;CSS&quot;; 
var course3 =&quot;JS&quot;; 当你有 100 个课程名称呢？这时候可以使用 Array：var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);以上定义了一个数组 courses，存储了 3 个元素。可以使用 index 索引号内访问数组元素，索引号 0 表示第一个元素：var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);
var course = courses[0];
courses[1] = &quot;c++&quot;;以上示例表示：给变量 course 赋值数组第一个元素，给第二个元素赋值 c++。如果尝试访问超出数组元素的索引，会返回 undefined。在定义数组时也可以只申明数组元素个数，后续再给元素赋值：var courses = new Array(3);
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;array 数组是一种特殊的 object，它使用 index number 来访问元素，而标准 object 使用 property name 来访问元素。JavaScript array 是动态的，也就是你可以在创建时不传入任何参数给构造器：var courses = new Array();
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;
courses[3] = &quot;C++&quot;;你可以添加任意多个元素给数组。为了定义更加方便，可以使用 array literal 语法来创建数组：var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];以上语法和使用 new 关键词创建的数组是一样的。推荐使用这种语法。JavaScript array 内建了很多实用的 properties 和 method。array 的 length property 返回数组的元素个数：var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
document.write(courses.length);length 的返回值比最后一个元素的索引号大 1，如果数组为空，则返回值为 0。使用 concat() method 可以叠加两个数组并返回为一个新的数组：var c1 = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
var c2 = [&quot;C++&quot;];
var newC = c1.concat(c2);newC 数组拥有四个元素："HTML", "CSS", "JS", "C++"。注意使用 concat() method 并不会影响 c1 和 c2。Associative Arrays 关联型数组很多编程语言支持给数组添加命名化的 index 索引，也就是给每个元素定义一个名称，但是 JavaScript 不支持这种操作。但是我们依然可以定义命名化的 index 索引数组，JavaScript 会将其作为一个 object 处理：var a = [];
a[&quot;name&quot;] = &quot;marco&quot;;
a[&quot;age&quot;] = 20;
document.write(a[&quot;age&quot;]);JavaScript 会将 a 作为 object 处理，这样 name 和 age 就是其 properties。可以使用以上写法来读取 property 数据。由于 a 数组被作为 object 处理，所以标准 array 的一些 method 和 properties 将无法正确执行，例如：a.length 返回值将是 0 而不是 2。JavaScript 原生并不支持命名化的元素索引，所以推荐当你想要使用 number 数字型 index 时使用 array，当你想要使用命名化的索引时使用 object。the Math Object 数学对象the Math Object 可以用来处理数学运算任务，它包含多个 properties：Math 没有 constructor 构造器，所以使用时并不需要单独创建 object。例如：document.write(Math.PI);
以上将输出：3.141592653589793Math object 包含多个 method 用来计算：下面示例计算 4 的平方根：var a = Math.sqrt(4);如果想要得到一个 0- 10 的随机数，可以使用下面方法：Math.ceil(Math.random() * 10);
下面编写一个小程序，让用户输入一个数字然后将这个数字的平方根放在弹窗通知中：var n = prompt(&quot;please input a number: &quot;, &quot;&quot;);
var m = Math.sqrt(n);
alert(m);The Date Object 时间对象setInterval() method 用来在指定的间隔时间(毫秒)下调用 function 或评估一个表达式。它将会持续调用直到执行  clearInterval() 或关闭窗口。下面的示例将会每三秒钟弹出窗口：function myAlert() {
    alert(&quot;hello&quot;);
}
setInterval(myAlert, 3000);注意传递 function 时只需要写 function 名称即可，不需要小括号()。Data object 可以让我们使用时间元素，一个 Date object 由：a year, a month, a day, an hour, a minute, a second, and milliseconds 构成。使用 new 关键词来创建一个 Date obect，包含有当前的日期和时间：var d = new Date();
//d stores the current date and time也可以使用指定的日期和时间来创建 Date object：new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)JavaScript 日期计算使用毫秒为单位，起始日期为：01 January, 1970 00:00:00 (UTC)。一天包含 86,400,000 毫秒。以下示例使用不同方式定义指定日期：//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000); 

//Fri Jan 02 2015 10:42:00
var d2 = new Date(&quot;January 2, 2015 10:42:00&quot;);

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);JavaScript 的月份从 0 到 11，1 月就是 0，12 月就是 11。Date object 是 static 类型的，创建后就不会改变。Date object 有如下 method 可供使用：例如读取当前小时数值：var d = new Date();
document.write(d.getHours());下面示例在窗口显示当前时间，且每秒刷新一次：function printTime() {
    var d = new Date();
    var hour = d.getHours();
    var min = d.getMinutes();
    var sec = d.getSeconds();
    document.body.innerHTML = hour + &quot;:&quot; + min + &quot;:&quot; + sec;
}

setInterval(printTime, 1000);innerHTML property 可以设置或返回一个 HTML 元素的内容，这里我们将 document 的 body 块的内容赋值为我们定义的时间数据，并且每秒覆盖更新一次。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1996.html">
<title>JavaScript 入门教程之五 -- Objects</title>
<link>https://blog.niekun.net/archives/1996.html</link>
<dc:date>2020-12-18T15:25:00+08:00</dc:date>
<description>JavaScript 的 variables 变量是用来包含数据的容器。object 同样是变量，但是包含了多个数据。一个 object 是一组使用 name:value 模式定义的数据集合，大括号{} 内部定义数据，数据间使用逗号, 分隔，注意大括号结尾的分号;：var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 170
};这些数据叫做 properties：  propertyproperty valuenamemarcoage20likebasketballheight170object 初始化语法可以写在一行，也可以写在多行。以下两种写法都是一样的：var John = {name: &quot;John&quot;, age: 25};

var John = {
  name: &quot;John&quot;,
  age: 25
};JavaScript 的 object 就是一组有命名的数据的容器。有两种方法访问 object 的 properties：objectName.propertyName
//or
objectName['propertyName']使用上面的示例访问 properties，以下两种结果是一样的：var x = person.age;
var y = person['age'];使用 JavaScript 内建的 length property 可以得到 property 或 string 包含的字符个数:var a = person.name.length;methodobject method 就是一个定义了 function 的 property，使用 object method 的语法为：objectName.methodName()
我们前面多次使用 document.write() 来输出内容到网页，实际上 write() function 就是 document object 的一个 method。定义一个 method 的语法如下：methodName = function() { code lines }
在上面的示例中给 object 加入一个 method：var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 62,
    test: function() {
        alert(&quot;method&quot;);
    }
};

person.test();使用 method 的方法和 properties 一样，需要加上小括号()。The Object Constructor 构造器上一节我们学习了如何建立 object，例如：var person = {
name: &quot;John&quot;, age: 42, favColor: &quot;green&quot;
};以上的写法一次只能创建一个 object，那么如何设置一种 object type 用来创建多个统一类型的 objects 呢？标准的方法是使用 constructor function 构造器来定义一个 object type：function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}以上就是一个 constructor function，接收传入数据来赋值给 object properties。关键词 this 表示当前 object 本身。当我们定义了一个 object constructor，就可以使用关键词 new 来新建一个 object：var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
document.write(p1.name);

//output:
//marcop1 就是 person 类型的 object，它的 properties 就是对应传入的数据。同样的方法，可以在 object constructor 中定义 method：    function person(name, age, color) {
        this.name = name;
        this.age = age;
        this.favColor = color;
        this.changeName = function(name) {
            this.name = name;
        }
    }

    var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
    p1.changeName(&quot;john&quot;);
    document.write(p1.name);以上示例中，我们定义了一个 changeName method，它有一个参数 name 用来赋值给 object 的 propertiy name。也可以在 object constructor function 外部定义 method：function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = bornyear;
}

function bornyear() {
    return 2020 - this.age;
}

var p1 = new person(&quot;marco&quot;, 25);
document.write(p1.yearOfBirth());以上示例中，我们给 property yearOfBirth 赋值为 bornyear。bornyear function 在外部定义，this 关键词可以来访问 person 的 properties，因为 bornyear 复制给了 person 的一个 property。注意当将一个 function 赋值给 object 时不需要写小括号()。通过 object property name 来调用构造器定义的 method，注意不是外部 function 的名称。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1992.html">
<title>JavaScript 入门教程之四 -- Functions</title>
<link>https://blog.niekun.net/archives/1992.html</link>
<dc:date>2020-12-18T13:58:50+08:00</dc:date>
<description>JavaScript function 就是一个执行特定任务的代码块。使用 function 的优点是：代码复用通过传入不同参数得到不同结果function 需要被调用才能执行。定义使用关键词 function 来定义一个 function，需要指定名称，使用大括号{} 来定义代码块：function name() { 
  //code to be executed
}function name 可以包含字符、数字，下划线和 &amp; 符号。下面定义一个简单的 function：function myFunction() {
    alert(&quot;call the function&quot;);
}

myFunction();一个 function 可以被调用任意次数，当需要调用 function 时，直接使用 function name 名称及小括号() 即可。注意结尾要写分号;。还有一种调用写法：myFunction.call()。当使用这种方法时，会自动将关键词 this 传入此 function，后续会详细介绍。function 参数function 可以接收参数，在定义时需要列出来：functionName(param1, param2, param3) {
   // some code
}多个参数使用逗号, 隔开。当定义了参数后，就可以在 function 代码块内使用：function myFunction(name) {
    alert(&quot;hi &quot; + name);
}

myFunction(&quot;marco&quot;);以上第一了一个 function 有一个 name 参数，当调用此 function 时需要给 name 赋值。function 内部就会将赋值数据分配个 name 参数。调用 function 时，通过不同的参数值来得到不同的结果：myFunction(&quot;marco&quot;);
myFunction(&quot;john&quot;);
myFunction(&quot;tom&quot;);使用逗号分隔多个参数：function myFunction(name, age) {
    alert(&quot;my name is &quot; + name + &quot;, age is &quot; + age);
}

myFunction(&quot;marco&quot;, 20);JavaScript 不会检查调用 function 时的传入参数个数和定义的参数个数是否一致，如果调用时缺少传递参数，则缺失的参数会被赋值为 undefined，表示没有被分配数据。function 可以有一个可选的 return 命令，用来从 function 返回一个数据。当 JavaScript 执行到 return 时，会停止执行后续指令。下面的示例中，我们计算两个参数的和并返回结果：function myFunction(a, b) {
    return a + b;
}

var x = myFunction(1, 2);变量 x 的值就是 3。如果 function 中没有 return 则默认会返回  undefined。Alert, Prompt, ConfirmJavaScript 提供三种弹出窗口：Alert, Prompt, Confirm。alert Box 用来给用户显示一个提示信息，需要点击 OK 来取消弹窗。有一个参数：alert(&quot;this is a alert&quot;);信息中需要换行的话可以加入 \n：alert(&quot;this is\n a alert&quot;);
效果如下：Prompt Box 用来弹出一个用户可以输入数据的提示窗口。用户需要点击 OK 或 cancel 来退出窗口，如果点击 OK 则会 return 输入的数据，如果点击 cancel 则会返回 null。prompt() 有两个参数，第一个是窗口显示的提示信息字符串，第二个是输入框的默认字符(可选项)：var a = prompt(&quot;please input value&quot;, &quot;test&quot;);
document.write(a);效果如下：选择 OK 后变量 a 会赋值为输入的数据。confirm box 可以用来作为确认对话框。用户必须点击 OK 或 cancel 来退出窗口，当点击 OK 后 box 会返回 true，当点击 cancel 后 box 会返回 false：var result = confirm(&quot;if confirm&quot;);

if (result) {
    alert(&quot;confirmed&quot;);
}
else {
    alert(&quot;not confirmd&quot;);
}弹出窗口不要过多的使用，因为弹出窗口会导致页面不可用。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1990.html">
<title>JavaScript 入门教程之三 -- Conditionals and Loops</title>
<link>https://blog.niekun.net/archives/1990.html</link>
<dc:date>2020-12-18T11:10:00+08:00</dc:date>
<description>The if Statement在编程中，如果想要根据不同的情况执行不同的代码，可以使用 if conditional statements 状况指令来处理，语法如下：if (condition) {
   statements
}使用 if 语法来根据 condition 是否为 true 来确定是否执行 statements。下面举例说明，修改 html 文件 script 部分：var a = 1;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}效果如下：如果修改 condition 不为 true 则不会执行内部指令：var a = 2;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}以上示例不会执行 alert function。注意如果 statement 指令只有一句时，可以省略大括号，如下写法也是正确的：var a = 1;
if (a == 1)
    alert(&quot;a is 1&quot;);使用 else 申明来 condition 为 false 时执行的指令：if (expression) {
   // executed if condition is true
}
else {
   // executed if condition is false
}下面举例说明：var a = 1;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else
    alert(&quot;a is bigger than b&quot;);以上示例实现的动作也可以使用我们上一章提到的状况判断符来实现：a &lt; b ? alert(&quot;a smaller than b&quot;) : alert(&quot;a is bigger than b&quot;);
如果 condition 不止有两种情况要处理，可以使用 else if 申明多个情况下的指令，修改上面的示例：var a = 2;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else if (a == b)
    alert(&quot;a equal to b&quot;);
else
    alert(&quot;a is bigger than b&quot;);则会执行 alert(&quot;a equal to b&quot;); 指令。注意 else 在整个块中必须作为最后一个申明写在 if 和 else if 之后，如果所有 condition 的条件都不满足则会执行 else 中的申明指令。可以根据情况使用任意多个 else if 申明。switch当 condition 有多个情况需要处理时，使用 else if 就会很麻烦。这时候可以使用 switch statement 来处理，语法如下：switch (expression) {
  case n1: 
     statements
     break;
  case n2: 
     statements
     break;
  default: 
     statements
}switch expression 会被评估一次，然后在 case 中寻找匹配的结果并执行对应块的指令。以下是一个简单示例：var day = 2;
switch (day) {
    case 1:
        document.write(&quot;today is monday&quot;);
        break;
    case 2:
        document.write(&quot;today is tuesday&quot;);
        break;
    default:
        document.write(&quot;today is another day&quot;);
        break;
}当 day 的值为 2，则会匹配到 case 2 并执行其内的指令。当 JavaScript 执行到 break 后会跳出 switch 块，如果不写 break 则会顺序执行下面的指令，即使不满足其他的 case 条件。通常情况下每个 case 块结尾都应该有 break。default 关键词用来处理没有匹配到任何 case 情况，如果没有匹配到则执行 default 中的指令。如果不需要处理没有指定的 case 匹配到的情况时 default 可以被省略。for 循环使用 loop 循环可以多次执行一段代码，通过一些条件来控制循环次数及参数值。JavaScript 提供三种类型的循环：for, while, 和 do while。for 循环语法如下：for (statement 1; statement 2; statement 3) {
   code block to be executed
}Statement 1 在循环前被执行Statement 2 定义执行循环的状态Statement 3 在每次循环后被执行下面的示例将输出 0 - 4：for (var i=0; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}过程为：首先给变量 i 赋值为 1，执行循环的条件是 i&lt;5，每次循环后给 i 加 1。当 i==4 时，执行完本次循环后 i 加 1 后值为 5，不满足第二项条件就会跳出循环。statement 1 是可选项可以不写，如：var i = 0;
for (; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}和第一个示例效果是一样的。statement 1 也可以同时定义多个参数，使用逗号, 来隔离，如：for (var i=0, j=2; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}如果 statement 2 返回 true 则会执行循环块内容，如果返回 false 则会结束循环。同样的 statement 2 也是可选项，也可以不定义，但是必须在循环块内定义 break 不然就会无线循环下去：for (var i=0; ; i++) {
    if (i &gt;= 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}statement 3 用来修改初始变量的值，同样也是可选项，可以在循环块内部直接修改初值：for (var i=0; i&lt;5 ;) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}while 循环while 循环也是用来实现当某个 condition 为 true 时循环一个代码块。语法如下：while (condition) {    
   code block
}下面的示例将输出 0 - 10 的数字：var i = 0;
while (i&lt;=10) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}当 condition 一直为 true 时，循环就会继续下去。我们应该避免无限循环情况出现。do while 循环do while 循环是 while 循环的一种变形，它会首先执行一次循环块然后判断 condition 条件。语法如下：do {
   code block
}
while (condition);注意 while 结尾的分号; 不能省略。下面的示例会输出 0 - 4：var i = 0;
do {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
} while (i&lt;5);循环块至少会执行一次，即使 condition 为 false。breakbreak 指令用来跳出循环继续执行后续程序。下面示例中，将只会输出 0 - 4 的数字：for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}在 function 中可以使用 return 来跳出当前代码块，下一章节将会介绍。continuecontinue 指令用来仅跳出当次循环，然后继续进行下一次循环。下面示例将会输出 0- 10，但不包括 5：for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        continue;
    document.write(i + &quot;&lt;br&gt;&quot;);
}当 i 等于 5 时会跳出本次循环所以不会输出 5，但是会继续进行下面的循环。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1985.html">
<title>JavaScript 入门教程之二 -- 基本概念</title>
<link>https://blog.niekun.net/archives/1985.html</link>
<dc:date>2020-12-17T16:33:00+08:00</dc:date>
<description>数学运算符有以下运算符可以使用：加减运算使用方法很简单：var b = 10 + 2;
var c = b - 3;
document.write(c);可以使用 eval() 来将计算结果转换为字符串形式：var d = eval(&quot;10 + 2 + 1&quot;)
document.write(d);d 的结果就是 &quot;13&quot;。乘法使用星号* 来表示，以下三种写法都是正确的：var e = 2 * 3;
var f = 2 * '3';
var g = '2' * '3';
document.write(g);注意如果尝试对一个字符串进行乘法计算会返回：NaN (Not a Number)：var h = 'hello' * 2;
document.write(h);

//output：
//NaN除法使用斜线/ 表示：var i = 1 / 2;注意被除数不能为 0。取模运算使用% 表示：var j = 10 % 3;
document.write(j);

//output:
//1可以对整数和浮点型数字进行取模运算。递增和递减：使用++ 表示给对应变量进行加 1 运算，操作符写在变量前则返回加 1 后的值。写在后边返回加 1 前的值。使用-- 表示给对应变量进行减 1 运算，操作符写在变量前则返回减 1 后的值。写在后边返回减 1 前的值var k = 10;
var l = k++;
var m = ++l;
document.write(m);

//output:
//11分配符 Assignment Operators可用的分配符有：除了常规用法外，也可以在一行命令中使用多个分配符，例如：var n = 4;
var o = 5;
o += n += 3;
document.write(o);

//output:
//12比较符 Comparison Operators在逻辑判断中使用比较符来比较数据是否有区别。结果为 true 或 false。例如可以使用 equal to (==) operator 来比较两个数据是否一样：var p = 2;
document.write(p == 1);

//output:
//false所有的数据类型都可以进行比较，返回值只有 true 和 false。但需要注意比较的两个数据需要是同一类型的。以下是可用的比较符：逻辑判断符 Logical Operators逻辑判断符用来评估一个表达式，返回结果为 true 和 false。可用的逻辑判断符为：AND, OR, NOT：&amp;&amp; - AND 如果判断块都为 true，则返回 true|| - OR  如果任何一个判断块为 true，则返回 true! - NOT  如果判断块为 false，则返回 true下面的示例是对两个判断块进行 与AND 操作：(4 &gt; 2) &amp;&amp; (1 &lt; 3);以上两个判断块都为 true 则整个逻辑判断结果为 true。状况判断符 Conditional (Ternary) Operator状况判断符用来根据一些实际状态给某个变量赋值。语法如下：variable = (condition) ? value1: value2 
下面举例说明：var age = 20;
var isAdult = (age &lt; 18) ? &quot;too young&quot; : &quot;old enough&quot;;
document.write(isAdult);

//OUTPUT:
//old enough以上示例中，如果 age 小于 18 则 isAdult 赋值为 "too young"，如果 age 大于等于 18 则 isAdult 赋值为 "old enough"。字符串操作符 String Operators我们可以使用级联符+ 来将多个字符串组合成一个新的字符串。例如：var str1 = &quot;this is a &quot;;
var str2 = &quot;test string&quot;;
document.write(str1 + str2);

//output:
// this is a test string注意一个数字使用引号括起来后就成了一个字符串，如：&quot;42&quot; 表示一个字符串。。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1979.html">
<title>JavaScript 入门教程之一 -- 总览</title>
<link>https://blog.niekun.net/archives/1979.html</link>
<dc:date>2020-12-17T10:31:00+08:00</dc:date>
<description>JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。最初命名为 Mocha，1995年9月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年12月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上 Java 这个编程语言“热词”，因此将其临时改名为 JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。不同于服务器端脚本语言，例如 PHP 与 ASP，JavaScript 主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于 JavaScript 以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器变得强大，现在的程序员更喜欢运行于服务端的脚本以保证安全，但 JavaScript 仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖 JavaScript 在客户端进行支持。随着引擎如 V8 和框架如 Node.js 的发展，及其事件驱动及异步 IO 等特性，JavaScript 逐渐被用来编写服务器端程序。且在近几年中，Node.js 的出世，让 JavaScript 也具有了一定的服务器功能。我们的第一个 JavaScript我们首先来了解一些基本概念，给 web 网页加上 JavaScript。在 web 上，JavaScript 位于 HTML document 内，可以在任意位置。js 内容使用 &lt;script&gt; 和 &lt;/script&gt; 包围起来：&lt;script&gt;
   ...
&lt;/script&gt;让我们使用 JavaScript 在网页上打印出一个 Hello World，新建一个 html 文件，内容如下：&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        
    &lt;/body&gt;
    &lt;script&gt;
        document.write(&quot;hello world&quot;);
    &lt;/script&gt;
&lt;/html&gt;使用 document.write() function 用来给 html document 写入内容。注意此 function 只用来测试，实际使用中会覆盖 document 中已有的内容。JavaScript 每条指令结尾使用分号; 来标记。文件保存后可以使用浏览器打开查看效果。js 中还支持标准 html markup 标记语法，我们给 hello world 设置属性：    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
    &lt;/script&gt;这时候文字会以标题模式显示。也可以在浏览器终端 console 中输出信息，使用 console.log() function 实现：    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
    &lt;/script&gt;打开浏览器的调试窗口即可看到输出信息，chrome 浏览器使用快捷键 ctrl+shift+I 或设置中打开调试：点击 console 栏查看：注释对于不需要被执行的语句可以使用符号来忽略，使用双斜杠 // 注释单行内容，使用 /* 和 */ 注释一个块。修改我们上面的 html 文件的 js 块：    &lt;script&gt;
        // this is a commit
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
        /* this code create
            a alert box
        */
        alert(&quot;this is a alert box&quot;);
    &lt;/script&gt;alert() function 用来弹出一个提示窗口。变量variables 变量是存储数据的容器。变量的值可以再程序中被修改。使用关键词 var 申明一个变量：var x = 10;
以上指令给变量 x 分配数据 10。注意我们在此使用 assign 分配来描述这个过程，因为在 JavaScript 中等于号= 会调用 assignment operator 操作符，而不是 equal to operator 操作符。变量名是大小写敏感的，也就是说 name 和 Name 是两个变量。让我们输出一个变量值到浏览器：var x = 10;
document.write(x);变量定义的基本原则：首字符必须是这三者之一：字母，下划线_，$ 符。后续字符可以是字母、数字，下划线或者 &amp;名称不能包含数学运算符或操作符不能包含空格不能使用特殊字符，如：# & % 等不能使用连字符-，这是减法保留符数据类型JavaScript 支持多种类型的数据：numbers, strings, arrays 等。numbernumber 可以是整数或小数：var a = 10;
var b = 1.1;变量分配的数据类型可以任意修改，例如重新分配 a 的数据为 string 字符串：a = &quot;this is a strings&quot;;
string使用 string 可以来存储及操作文本信息。使用引号来包裹内容，单引号' 或双引号&quot; 都可以：var a = 'marco';
var b = &quot;john&quot;;如果要在 string 内部使用也引号，可以通过内外使用不同的单双引号来实现，js 会自动区分：var a = &quot;this is a 'test'&quot;;
如果内外想要使用同一个引号形式可以在内部使用转义符 \ 来实现：a = &quot;this \&quot;is\&quot; a \&quot;other\&quot; test&quot;;
转义符可以将特殊字符作为普通字符使用，也可以实现特殊功能，一些列表是常用的转码：注意字符串的包裹分号需要前后统一，起始用了单引号结尾也必须使用单引号，否则会报错。BooleanBoolean 只有两种结果：true 和 false。如果你需要一种只有两种可能的结果的数据类型，就可以使用 Boolean：var isActive = true;注意 Boolean 类型的值如果是：0 (zero), null, undefined, empty string 则都是 false，其他如果有一个真实数据的都为 true。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1977.html">
<title>brew 安装路径</title>
<link>https://blog.niekun.net/archives/1977.html</link>
<dc:date>2020-12-16T22:04:00+08:00</dc:date>
<description>brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。brew 默认安装路径为：/usr/local/Cellar，然后会在 /usr/local/opt/ 建立所安装的包的软连接。包安装好后如果不能正常执行，可以建立包的可执行程序的软连接到：/usr/local/bin/ 目录。比如安装 openssl：brew install openssl
安装后包的路径为：/usr/local/Cellar/openssl@1.1/1.1.1h。同时包的软连接在：/usr/local/Cellar/openssl。这时候执行命令：openssl version
返回的并不是刚才安装的版本，而是系统自带的老版本的。这时候可以建立可执行程序的软连接到对应路径：ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
这时候执行命令就可以得到正确的返回：openssl version
//OpenSSL 1.1.1h  22 Sep 2020
其他包的模式和此类似。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1973.html">
<title>QT 网络应用</title>
<link>https://blog.niekun.net/archives/1973.html</link>
<dc:date>2020-12-16T16:59:00+08:00</dc:date>
<description>最近研究了下 QT 如何访问网络，做一些简单总结。首先在 pro 文件内定义网络属性：QT  += network
如果需要连接 https 需要安装 openssl 工具，使用 QT 的 MaintenanceTool 工具找到 openssl toolkit 并安装。否则执行程序时 ssl 会报错。安装后需要将 openssl 路径加入系统 PATH，默认安装路径为：Qt/Tools/OpenSSL。根据需要将对应系统版本的 bin 路径加入 PATH 如：C:\Qt\Tools\OpenSSL\Win_x86\bin，里面包含相关 lib 库文件。添加方法参考：https://blog.niekun.net/archives/413.html。需要用到的 QT class：QNetworkAccessManagerQNetworkRequestQSslConfigurationQNetworkReply我们做一个示例，新建项目，在头文件添加相关引用：#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;public 栏添加触发网络访问的 function：public:
    void doRequest();private 栏定义指针：private:
    QNetworkAccessManager *manager;添加 private slots 用来处理服务器的回应：private slots:
    void replyFinished(QNetworkReply *reply);传入参数 reply 用来接收网络访问响应内容，对应于 signal: void QNetworkAccessManager::finished(QNetworkReply *reply)，signal 触发后的数据通过 connect 会自动传入 slot 中，下面在源文件中做详细定义。下面修改源文件，先在构造器中调用触发网络 function: doRequest()：MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    doRequest();
}下面实现 doRequest() 的内容：void MainWindow::doRequest() {
    manager = new QNetworkAccessManager(this);

    QSslConfiguration sSlConfig;
    sSlConfig.setDefaultConfiguration(QSslConfiguration::defaultConfiguration());
    sSlConfig.setProtocol(QSsl::TlsV1_2);

    QNetworkRequest request;
    request.setSslConfiguration(sSlConfig);
    request.setUrl(QUrl(&quot;https://info.niekun.net&quot;));
    request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);

    manager-&gt;get(request);

    connect(manager, &amp;QNetworkAccessManager::finished, this, &amp;MainWindow::replyFinished);
    connect(manager, &amp;QNetworkAccessManager::finished, manager, &amp;QNetworkAccessManager::deleteLater);
}首先实例化一个 QNetworkAccessManager 用来访问网络。然后构造我们的 request 和 ssl 的初始化内容，request 中设置了访问的网络地址，定义了一个 request 的 header。QNetworkAccessManager  的 object 使用 get function 来启动网络请求。然后我们使用 connect 根据网络请求发出后的响应来触发相关 slot function。signal 触发后的数据会传入 slot function 中。所以 signal：void QNetworkAccessManager::finished(QNetworkReply *reply) 触发后返回的数据 reply 自动作为传入数据给 replyFinished。第二个 connect 的作用是网络请求结束后释放相关内存，避免造成内存溢出。注意这里我使用了新版的 QT connect 语法，详细参考官方文档：https://wiki.qt.io/New_Signal_Slot_Syntax下面实现 replyFinished：void MainWindow::replyFinished(QNetworkReply *reply) {
    if(reply-&gt;error())
    {
        qDebug() &lt;&lt; &quot;ERROR!&quot;;
        qDebug() &lt;&lt; reply-&gt;errorString();
    }
    else
    {
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentTypeHeader).toString();
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::LastModifiedHeader).toDateTime().toString();;
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentLengthHeader).toULongLong();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
        qDebug() &lt;&lt; &quot;-----------------------&quot;;
        qDebug().noquote() &lt;&lt; reply-&gt;readAll();
    }
}reply 指向 &amp;QNetworkAccessManager::finished 的 QNetworkReply 数据。在此 function 中，我们输出 reply 中的部分信息来检测网络是否通畅。其他的可用类型可以查询：https://doc.qt.io/qt-5/qnetworkrequest.html#public-types注意使用 qDebug().noquote() 来自动将字符串中的 \n 作为换行处理。正常输出信息如下：&quot;text/plain&quot;
&quot;&quot;
0
200
&quot;OK&quot;
-----------------------
request info:
request: GET / HTTP/1.1
scheme: https
host: info.niekun.net
http_host: info.niekun.net
uri: /
request_uri: /
connection: 202130
remote_addr: 172.68.189.53
client_real_ip: 1.81.217.183
server_port: 443

other variates:
http_x_forwarded_for: 1.81.217.183
proxy_add_x_forwarded_for: 1.81.217.183, 172.68.189.53以上就是 QT 访问网络的简单教程。参考链接：https://www.bogotobogo.com/Qt/Qt5_Downloading_Files_QNetworkAccessManager_QNetworkRequest.php</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1968.html">
<title>c++ 字符串数组指针的研究</title>
<link>https://blog.niekun.net/archives/1968.html</link>
<dc:date>2020-12-08T21:37:00+08:00</dc:date>
<description>在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。一个简单的测试：    const char* test1 = &quot;abc&quot;;
    const string test2 = &quot;abc&quot;;

    cout &lt;&lt; test1 &lt;&lt; endl;
    cout &lt;&lt; *test1 &lt;&lt; endl;
    cout &lt;&lt; test2 &lt;&lt; endl;
    cout &lt;&lt; sizeof (test1) &lt;&lt; endl;
    cout &lt;&lt; sizeof (test2) &lt;&lt; endl;输出如下：abc
a
abc
8
24以前我的教程里提到过，字符串就相当于一个字符数组。指针会指向它的首个字符地址。test1 指针理论上存储着字符串的首地址。但我们可以看到直接输出 test1 会得到实际字符串内容，而不是首个字符地址。输出 *test 会得到正常的首字符内容。字符串指针使用 sizeof 得到这个指针所占用内存大小，而不是字符串内容的大小。同时我们可以发现，一个字符指针可以直接指向一个字符串，而不需要先定义一个字符串变量然后建立指针指向这个变量。这是因为一个字符串可以看做一个字符数组，同时它也是一个整体，字符指针可以直接定义指向它。下面测试 int 型数组：    const int test3[] = {1, 3 ,5};
    const int* test4 = test3;

    cout &lt;&lt; test3 &lt;&lt; endl;
    cout &lt;&lt; test4 &lt;&lt; endl;
    cout &lt;&lt; test4[0] &lt;&lt; endl;
    cout &lt;&lt; *test4 &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4) &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4[0]) &lt;&lt; endl;输出结果：0x7ffee8cbaa58
0x7ffee8cbaa58
1
1
8
4可以看到直接输出数组名称或指针名称得到的是数组所在地址。*test 和 test[0] 会得到数组第一位内容。test4 是一个指针，所以 sizeof 得到的是这个指针做占用的内存空间而不是数组本身占用空间。无法通过 sizeof 计算出数组个数。以上实验，我们先建立了一个 int 型数组变量，然后建立 int 型指针指向这个变量，如果直接在一行中建立一个指针指向一个数组会报错，这就和上面测试的字符指针不一样了。因为其他类型的数组不同于字符串，它的每个元素是独立的个体，所以无法使用一个指针直接指向他们全部。下面做最后一个测试：const char* test5[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

const string test6[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

int x = sizeof (test5)/sizeof(test5[0]);
cout &lt;&lt; test5 &lt;&lt; endl;
cout &lt;&lt; *test5 &lt;&lt; endl;
cout &lt;&lt; test5[0] &lt;&lt; endl;
cout &lt;&lt; *test5[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test5) &lt;&lt; endl;
cout &lt;&lt; sizeof(test5[0]) &lt;&lt; endl;

cout &lt;&lt; &quot;*************\n&quot;;

x = sizeof (test6)/sizeof(test6[0]);
cout &lt;&lt; test6 &lt;&lt; endl;
cout &lt;&lt; *test6 &lt;&lt; endl;
cout &lt;&lt; test6[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;
cout &lt;&lt; sizeof(test6) &lt;&lt; endl;
cout &lt;&lt; sizeof(test6[0]) &lt;&lt; endl;输出结果如下：0x7ffee596ea40
abc
abc
a
4
32
8
*************
0x7ffee596e9e0
abc
abc
4
96
24由于字符串本身就是一个字符数组，所以一个字符串数组相当于一个二维的数组。定义字符串数组的指针，就是数组中每个字符串对应的指针的集合。所以这个数组指针本身不是字符串类型的，而它的每个指针元素都是字符串指针类型的。可以看到类似于第一组测试，非字符串的指针直接输出指针名称，所以 test5 得到字符串数组的地址。*test5 和 test5[0] 都表示指针数组第一个元素，也就是字符串类型的指针，根据第一组实验可以知道使用字符串指针名称输出本身字符串而不是地址，所以输出此指针可以直接得到字符串内容。*test5[0] 就是字符串指针的首字符地址内容，也就是得到第一个字符串第一个字符的内容。test5 指针数组使用 sizeof 得到的是这个指针数组总共占用的内存大小，也就是每个指针大小的总和。除以单个指针大小就可以得到这个数组指针的个数，也就是对应指向的数组的元素个数。test6 字符串数组使用 sizeof 得到的是这个字符串数组所有元素的占用内存大小，除以单个字符串大小就可以得到这个数组的元素个数。我们可以看到 test5 和 test6 使用 sizeof 都可以得到数组的元素个数，但他们的原理是完全不同的，一个是使用指针的内存大小，一个是使用数组本身的内存大小。总结：字符串的指针名称可以直接输出字符串内容而不是地址。其他指针类型指向的数据，如字符，数字，字符串数组，number 型数组等，指针名输出的都是数据地址。指针使用 sizeof 得到的是指针所占用的内存大小。可以使用 sizeof(*Pointer) 得到数据本身大小。字符串数组的指针使用 sizeof 得到指针数组的总大小，可以用来间接计算数组元素个数。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1966.html">
<title>macOS 下使用 QT 部署工具 macdeployqt</title>
<link>https://blog.niekun.net/archives/1966.html</link>
<dc:date>2020-12-05T23:53:15+08:00</dc:date>
<description>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。工具路径在 QT 安装目录的对应编译器 bin 目录下，如：/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：打开 ~/.zshrc 添加如下内容，可以使用 vim 来操作：export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin编辑完成后关闭文件，刷新源：source ~/.zshrc
现在就可以直接使用命令了：macdeployqt -h

部署的方法是直接在 macdeployqt 后提供 app 路径：macdeployqt path/to/test.app
执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 app/Contents/Frameworks 文件夹内。</description>
</item>
</rdf:RDF>