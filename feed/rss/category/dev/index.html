<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/dev/">
<title>Marco Nie - Program</title>
<link>https://blog.niekun.net/category/dev/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1898.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1895.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1894.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1758.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1753.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1718.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1688.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1685.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1684.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1563.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1898.html">
<title>C++ 入门教程 -- 数据类型，数组及指针</title>
<link>https://blog.niekun.net/archives/1898.html</link>
<dc:date>2020-11-19T15:54:00+08:00</dc:date>
<description>介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression
非法的运算：55 + &quot;John&quot; // illegal

数字类型的有两种类型：整型，如：7，10。浮点型，如：3.14，5.67。字符串是一个数字、字符、符号的集合。使用双引号来标记，如：&quot;hello&quot;。字符使用单引号来标记，如：'A'。Boolean 类型只有两个可能的值：true 和 false。整型整型一般默认 4 个字节的存储空间。使用 int 来定义：int a = 42;
带符号型，可以定义正数和负数，一般不写默认 int 就是带符号型：signed int a;
无符号型，只能定义正数型：unsigned int a;
short 型，一般默认空间占用大小，就是 2 个字节：short int a;
long 型，2倍默认空间大小：long int a;
浮点型有三种浮点类型：float, double, 和 long double。浮点型都是 signed 带符号型的。一般情况下，float 型 4 个字节，double 型 8 个字节，long double 型 16 个字节。使用 float 来定义：float a = 3.14;
字符串string 字符串类型是一个字符、数字和符号的集合，使用双引号来标记。使用 string 定义变量，需要使用 &lt;string&gt; 库：#include &lt;string&gt;
using namespace std;

int main() {
    string test = &quot;hello&quot;;
    return 0;
}注意：&lt;string&gt; 库包含在 &lt;iostream&gt; 库中，所以如果已经引用来 &lt;iostream&gt; 就不需要再引用 &lt;string&gt; 了。char 类型char 类型包含了 1 个字节的整数，但是解释器会将这个整数解释为 ASCII 码对应字符。使用单引号来标记，如：char a = 'a';
变量定义规则所有变量的定义需要遵守以下规则：变量名首位必须是一个字母或下划线 _首字符之后的可以使用字母或数字，不能使用特殊字符或空格一般有两种常用的定义方法首字母及每个单词的首字符大写，如: BlankWord首字母小写后续的每个单词首字符大写，如：blankWord所有的变量名都是区分大小写的，如：helloword 和 HelloWord 是两个变量。数组数组是一个同一种数据类型变量的集合体，只需要一次就可以定义多个同一种变量类型的变量。如：int a[5] = {1, 2, 5, 7, 8};
变量名后方括号[]定义数组内变量个数，大括号{}内包含数组内元素实际值，使用逗号,分隔各个元素。注意大括号内的元素个数不能超过数组变量定义的个数。也可以在定义时不说明元素个数：int a[] = {1, 3, 7, 9};
会自动创建足够存储内部元素的数组。数组内每个元素都有一个 index 索引，从 0 开始，所以数组内第一个元素索引为 0，第二个为 1。使用索引号可以访问对应元素：int b[] = {11, 45, 62, 70, 88};

cout &lt;&lt; b[0] &lt;&lt; endl;
// Outputs 11

cout&lt;&lt; b[3] &lt;&lt; endl;
// Outputs 70如果需要逐个访问数组内元素，可以使用 loop 循环来实现：int myArr[5];

for(int x=0; x&lt;5; x++) {
  myArr[x] = 42;
}多维数组以上是单维数组的定义，也可以定义多维数组，如定义一个二位数组：int a[3][4];
想象这个数组为一个矩阵，有三行，每行 4 个元素：定义多维数组定义元素需要每行在一个大括号下单独定义：int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};也可以在一行内定义：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
使用行号和列号来定位一个元素：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
cout &lt;&lt; x[0][2] &lt;&lt; endl;

//Outputs 4指针每个变量都存储在内存单元内，每个内存空间都有地址。这个内存地址可以使用地址查询符&amp;来查询，如：int score = 5;
cout &lt;&lt; &amp;score &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;返回的地址就是存储变量 score 的值的地址空间。一个 pointer 指针就是一个存储某个变量所在内存地址的变量。指针类型可以使某些任务实现更加方便，某些任务，如动态内存分配则必须使用指针来实现。不同类型的指针变量的唯一区别就是其所在内存地址的数据类型的不同。和其他变量类型一样，定义指针变量需要申明类型。使用星号* 来表示是指针类型的变量。int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character星号* 可以放在数据类型旁边或者变量旁边或者单独写在中间。我们可以将一个地址赋给指针变量：int score = 5;
int *scorePtr;
scorePtr = &amp;score;

cout &lt;&lt; scorePtr &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;scorePtr 的值就是 score 变量的内存地址。有两种指针的运算器：地址查询符&amp;，返回操作数所在内存地址 referencing数据查询符*，返回操作数的内存地址下的数据 dereferencing例如：int var = 50;
int  *p;
p = &amp;var;

cout &lt;&lt; var &lt;&lt; endl;
// Outputs 50 (the value of var)

cout &lt;&lt; p &lt;&lt; endl;
// Outputs 0x29fee8 (var's memory location)

cout &lt;&lt; *p &lt;&lt; endl;
/* Outputs 50 (the value of the variable
 stored in the pointer p) */定义指针类型变量时候的星号* 只是用来表明此变量为指针类型变量，不要和内存查询符混淆。数据查询符* 指针指向的变量的 alias，例如：int x = 5;
int *p = &amp;x;

x = x + 4;
x = *p + 4;
*p = *p + 4;P 是 x 的指针，以上示例的三种运算结果都是一样的，都是将变量 x 的值进行计算。我们可以通过定义变量的指针来操作变量值。静态内存和动态内存理解动态内存的工作机制对于开发有很大帮助。再 c++ 中内存被分为两种类型：the stack 静态内存空间：所有的本地变量占用静态内存空间the heap 动态内存空间：再程序运行时动态进行分配的空间，默认不占用很多情况下，提前并不知道一个定义的变量需要多少空间来存储信息需要在运行时动态请求内存空间。可以使用 new 操作符来定义一个变量使用 heap 方式再运行时动态分配内存空间，并返回分配的地址，例如：new int;
以上定义一个使用 heap 方式分配一个足够存储 int 类型的内存空间，并返回这个地址。分配的地址可以存储在一个指针中，可以在后续中使用：int *p = new int;
*p = 5;以上请求了一个动态内存来存储一个 int 类型数据，然后在这个地址存储值为 5。注意指针 p 变量存储在 stack 静态内存中，且其值为 heap 动态内存分配的 int 型数据的地址，结果 5 是存储在 heap 动态内存中的。本地静态内存 stack 下的变量，内存管理是自动进行的不需要手动干预，使用 heap 方式动态分配的内存空间需要手动干预操作，当不再需要动态内存空间的数据时使用 delete 操作符来释放空间。示例：int *p = new int; // request memory
*p = 5; // store value

cout &lt;&lt; *p &lt;&lt; endl; // use value

delete p; // free up the memory忘记释放使用 new 请求的动态内存空间会导致内存泄漏问题，因为在程序关闭时才会释放空间。注意 delete 操作的是指针类型。并且释放的只是 heap 动态内存，指针本身是存储在 stack 中的。当内存释放后，指针不指向某个内存地址，次时这个指针叫做：dangling pointers 悬浮指针。可以重新让这个指针指向内存地址：int *p = new int; // request memory
*p = 5; // store value

delete p; // free up the memory
// now p is a dangling pointer

p = new int; // reuse for a new address也可以定义一个 NULL 的空指针：int *ptr = NULL;
也可以指向一个数组：int *p = NULL; // Pointer initialized with null
p = new int[20]; // Request memory
delete [] p; // Delete array pointed to by p注意释放内存时要加上方括号[]。动态内存分配很有用，如当程序需要读取一张图片时，你提前并不知道图片的大小，需要多大的内存空间来存储。这时候使用动态内存来定义就很方便了。数据大小虽然不同类型数据的内存占用大小和不同架构的设备有关或使用的编译器，但 c++ 有一个最小的数据大小定义：可以使用 sizeof 指令来获取特定数据类型当前占用内存空间，如：sizeof(int)
返回值为此类型数据的内存大小，单位为字节：cout &lt;&lt; &quot;char: &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; &quot;int: &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; &quot;float: &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
int var = 50;
cout &lt;&lt; &quot;var: &quot; &lt;&lt; sizeof(var) &lt;&lt; endl;

/* Outputs
char: 1
int: 4
float: 4
double: 8
var: 4
*/ 也可以获取数组的内存占用大小：double myArr[10];
cout &lt;&lt; sizeof(myArr) &lt;&lt; endl; 

//Outputs 80一个 double 占用 8 个字节，所以此数组共使用 80 个字节。可以使用 sizeof 分别读取整个数组和单个元素的内存空间来计算数组元素个数：int numbers[100];
cout &lt;&lt; sizeof(numbers) / sizeof(numbers[0]);

// Outputs 100以上就是 c++ 数据类型及指针的介绍。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1895.html">
<title>C++ 入门教程 -- 判断及循环</title>
<link>https://blog.niekun.net/archives/1895.html</link>
<dc:date>2020-11-07T15:53:00+08:00</dc:date>
<description>if 判断if 申明的使用场景：当一个判断条件达到是执行指令。语法结构：if (condition) {
    statements
}示例：if (7 &gt; 4) {
  cout &lt;&lt;  &quot;Yes&quot;; 
}

// Outputs &quot;Yes&quot;可以使用的相关性判断器：&lt;&gt;&gt;=&lt;===!=当条件不满足是，也可以执行命令：if (condition) {
  //statements
}
else {
 //statements
}if else 指令可以多次嵌套使用：int age = 18;
if (age &gt; 14) {
  if(age &gt;= 18) {
    cout &lt;&lt; &quot;Adult&quot;;
  }
  else {
    cout &lt;&lt; &quot;Teenager&quot;;
  }
}
else {
  if (age &gt; 0) {
    cout &lt;&lt; &quot;Child&quot;;
  }
  else {
    cout &lt;&lt; &quot;Something's wrong&quot;;
  }
}当命令只有一句时可以省略大括号：int a = 10;
if (a &gt; 4)
  cout &lt;&lt; &quot;Yes&quot;;
else
  cout &lt;&lt; &quot;No&quot;;while 循环一个 while 循环重复的执行设置的命令，直到设置的条件不满足为止。语法：while (condition) {
   statement(s);
}示例：int num = 1;
while (num &lt; 6) {
  cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl;
  num = num + 1;
}当 num 变量小于 6 满足时，循环执行大括号内的指令，直到 num 的值大于等于 6 则跳出循环继续执行下面的指令。以上示例中当 num 第五次自加后结果为 6，则下一次循环开始时判断条件就为 false 了，就会跳出循环。for 循环for 循环指令可以实现指定循环次数，语法结构如下：for ( init; condition; increment ) {
  statement(s);
}init 用来设置变量初值，且只设置一次condition 用来给定执行循环的条件，满足则执行循环内指令increment 设置循环条件的变量值如何变化示例：for (int x = 1; x &lt; 10; x++) {
 // some code
 }定义并设置 x 变量初值 1，循环条件是 x 小于 10，每次循环后 x 自加 1。变量变化量可以自定：for (int a = 0; a &lt; 50; a+=10) {
  cout &lt;&lt; a &lt;&lt; endl;
}
/* Outputs
0
10
20
30
40
*/do while 循环不同于 while 循环，do while 循环首先执行一次循环内的指令，再判断条件是否满足。语法：do {
   statement(s);
} while (condition);示例：int a = 0;
do {
  cout &lt;&lt; a &lt;&lt; endl;
  a++;
} while(a &lt; 5);

/* Outputs
0
1
2
3
4
*/do while 即使条件不满足也至少会执行一次循环内的命令。switch 指令当需要根据一个变量值为不同的结果时执行不同的指令时可以使用 switch 指令。语法：switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
    default:
    statement(s);
}当变量的值匹配到 switch 里定义的一个 value 值后，会执行此 case 下的指令。使用 break 来跳出 switch 指令，如果不写的话会顺序执行下面的case 指令，即使变量值并没有匹配到这个 case。default 用来定义当以上设置的 case 都没有匹配上时执行的指令。逻辑操作符有三个逻辑操作符：&& 与|| 或!  非与指令：当两个条件都满足时为 true：int age = 20;
if (age &gt; 16 &amp;&amp; age &lt; 60) {
  cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted&quot;或指令：当任意一个条件满足时为 true：int age = 16;
int score = 90;
if (age &gt; 20 || score &gt; 50) {
    cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted!&quot;非指令：当条件不满足时为 true：int age = 10;
if ( !(age &gt; 16) ) {
  cout &lt;&lt; &quot;Your age is less than 16&quot; &lt;&lt; endl;
}

// Outputs &quot;Your age is less than 16&quot;以上就是常用的判断及循环指令用法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1894.html">
<title>C++ 入门教程 -- 基础概念</title>
<link>https://blog.niekun.net/archives/1894.html</link>
<dc:date>2020-11-07T15:13:00+08:00</dc:date>
<description>C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。下面用几篇文章介绍 c++ 的基础用法。结构c++ 程序是一个集成很多命令和描述的集合，以下是一个模板程序：#include &lt;iostream&gt;
using namespace std;

// comment
int main()
{
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; &quot;WOW&quot; &lt;&lt; &quot;\n&quot;;
    return 0;
}
/*
comments
*/所有 c++ 程序的入口都是 main() function，使用大括号 {} 将 function 的内容包围起来，括号内的指令在 fuction 运行时执行。每句指令结尾使用分号; 结束。cout 是 iostream 的一个 object，功能是输出信息到标准的输出设备，一般是显示屏上。&lt;&lt; 是 insertion operator 用来将后面的字符串传入 cout 指令最后输出到显示屏。可以使用多个 &lt;&lt; 将信息连起来。iostream 是头文件，里面包含各种程序执行需要的功能模块，使用 #include 调用头文件。iostream 包含输入输出数据块的 stream object。每个 namespace 是一个申明区域，定义了程序调用 function 或 object 时的类型，using namespace std 告诉程序默认使用 std 类型的元素。在命令中可以直接写 std 中定义的元素：cout &lt;&lt; &quot;Hello world!&quot;;
std::cout &lt;&lt; &quot;Hello world!&quot;;以上两种写法效果是一样的，表示使用  std 类型的 cout 指令。也可以写自定义的申明如：namespace fs = boost::filesystem;
fs:path testpath;
以上申明意思是用 fs 表示 boost::filesystem 类型，然后定义一个 boost::filesystem::path 类型的变量。cout 执行后默认不添加行结束符号，添加一个 endl object 来实现换行操作。也可以添加字符串 \n 表示换行。反斜杠 \ 是转义符用来输入特殊意义的符号，如：\n 表示换行。// 双斜杠用来添加单行注释信息，斜杠所在的行不会被编译。/*....*/ 用来表示注释区域，这一段的内容都不被编译。变量定义一个变量会请求一个内存空间来存储变量值。编译器需要在定义变量时指定变量类型，类型可以是系统内置的也可以是自定义的。定义的个体可以是变量，function，class 等：int testVar = 10;
以上定义了一个 int 整数型的变量 testVar 并赋值为 10，注意变量名是区分大小写的，也就是 testVar 和 testvar 代表两个不同的变量。double testDouble1, testDouble2;
也可以同时定义两个变量。根据需求设置变量类型，可以优化内存占用空间。示例：#include &lt;iostream&gt;
using namespace std;

int main()
{
    int a = 30;
    int b = 12;
    int sum = a + b;
    cout &lt;&lt; sum;
    return 0;
}
//Outputs 42定义的变量可以在后续程序中赋值：int a;
int b = 1;

a = 2;
b = 3;输入参数使用 cin 来请求用户输入数据，用 extraction operator 来将输入数据提取到别处：int a;
cin &gt;&gt; a;以上程序定义一个 int 型变量，然后提示用户输入一个数据存储到变量 a 中。结合输入输出可以实现简单的交互操作：#include &lt;iostream&gt;
using namespace std;

int main() 
{
  int a, b;
  int sum;
  cout &lt;&lt; &quot;Enter a number \n&quot;;
  cin &gt;&gt; a;
  cout &lt;&lt; &quot;Enter another number \n&quot;;
  cin &gt;&gt; b;
  sum = a + b;
  cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; endl;

  return 0;
}运算符c++ 支持以下运算符：加减乘/ 除% 模(整除后的余数)int a = 1 + 1;
int b = 5 * 6;
int c = 5 % 2;
int d = 5 + 2 * 2;
int e = (5 + 2) * 2;

cout &lt;&lt; c &lt;&lt; endl;

//output: 1如果对变量本身的加减乘除操作可以简写：x *= 3; // equivalent to x = x * 3
x /= 2; // equivalent to x = x / 2
x %= 4; // equivalent to x = x % 4对本身自加或自减操作，有两种方式：后缀和前缀：x++; //后缀，相当于 x = x + 1
x--;
++x;
--x;
使用后缀方式是先执行表达式再自加，前缀方式是先自加再执行表达式：int a = 1;
int b = a++;
int c = ++a;

//b = 1
//c = 3以上是基础概念及指令。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1758.html">
<title>从源码编译安装 python</title>
<link>https://blog.niekun.net/archives/1758.html</link>
<dc:date>2020-09-21T16:35:00+08:00</dc:date>
<description>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最新版是 3.8.5，在这个页面找到地址：https://www.python.org/downloads/release/python-385/下载 tgz 压缩包到本地并解压：cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz环境安装编译需要安装一些依赖：apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
编译python 源码使用标准 GNU 编译系统，详细说明参考：https://blog.niekun.net/archives/883.html将 python 安装到 /opt 目录，先创建文件夹：mkdir /opt/python3.8.5
然后配置 configure：cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \没有错误提示的话就开始编译和安装：make
make install
安装完成后测试执行：/opt/python3.8.5/bin/python3 --version
返回版本信息则安装完成。下面将可执行文件加入系统路径，创建软连接：ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
测试运行：python --version
安装 pip源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。官网：https://pip.pypa.io/en/stable/installing/下载脚本到本地：curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py使用刚才安装的 python 执行脚本：/opt/python3.8.5/bin/python3 get-pip.py
pip 的安装路径是 /opt/python3.8.5/bin/，测试命令：/opt/python3.8.5/bin/pip3 --version
返回版本信息则安装完成。添加软连接到系统路径：ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
测试命令：pip --version
参考链接https://docs.rstudio.com/resources/install-python-source/</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1753.html">
<title>使用 subprocess.check_output 执行cmd命令并返回结果到字符串</title>
<link>https://blog.niekun.net/archives/1753.html</link>
<dc:date>2020-09-18T15:13:51+08:00</dc:date>
<description>语法：subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)
执行cmd命令并返回结果到字符串。用法：import subprocess

output = check_output([&quot;cat&quot;, &quot;/etc/hostname&quot;]).strip()
print(output)以上脚本会执行 cat /etc/hostname 命令然后将结果赋值给 output 变量。strip() 可以将 string 的前后空格去掉。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1718.html">
<title>argparse and struct in python</title>
<link>https://blog.niekun.net/archives/1718.html</link>
<dc:date>2020-08-14T11:20:39+08:00</dc:date>
<description>https://docs.python.org/3/library/argparse.htmlhttps://docs.python.org/3/library/struct.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1688.html">
<title>string &amp;lt;-&amp;gt; byte in python</title>
<link>https://blog.niekun.net/archives/1688.html</link>
<dc:date>2020-08-12T14:08:00+08:00</dc:date>
<description>To transform a unicode string to a byte string in Python do this:&gt;&gt;&gt; 'foo'.encode('utf_8')
b'foo'
To transform a byte string to a unicode string:&gt;&gt;&gt; b'foo'.decode('utf_8')
'foo'

To convert a string to bytes.data = &quot;&quot;               #string
data = &quot;&quot;.encode()      #bytes
data = b&quot;&quot;              #bytesTo convert bytes to a String.data = b&quot;&quot;              #bytes
data = b&quot;&quot;.decode()     #string
data = str(b&quot;&quot;)         #string</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1685.html">
<title>winreg 操作 Windows 注册表 in python</title>
<link>https://blog.niekun.net/archives/1685.html</link>
<dc:date>2020-08-12T13:56:00+08:00</dc:date>
<description>https://docs.python.org/3/library/winreg.html#https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registryimport winreg

REG_PATH = r&quot;Control Panel\Mouse&quot;

def set_reg(name, value):
    try:
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, 
                                       winreg.KEY_WRITE)
        winreg.SetValueEx(registry_key, name, 0, winreg.REG_SZ, value)
        winreg.CloseKey(registry_key)
        return True
    except WindowsError:
        return False

def get_reg(name):
    try:
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0,
                                       winreg.KEY_READ)
        value, regtype = winreg.QueryValueEx(registry_key, name)
        winreg.CloseKey(registry_key)
        return value
    except WindowsError:
        return None

#Example MouseSensitivity
#Read value 
print (get_reg('MouseSensitivity'))

#Set Value 1/20 (will just write the value to reg, the changed mouse val requires a win re-log to apply*)
set_reg('MouseSensitivity', str(10))

#*For instant apply of SystemParameters like the mouse speed on-write, you can use win32gui/SPI
#http://docs.activestate.com/activepython/3.4/pywin32/win32gui__SystemParametersInfo_meth.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1684.html">
<title>使用 opencv 处理图像</title>
<link>https://blog.niekun.net/archives/1684.html</link>
<dc:date>2020-08-07T11:37:51+08:00</dc:date>
<description>安装：https://pypi.org/project/opencv-python/使用：https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_table_of_contents_setup/py_table_of_contents_setup.html示例：https://www.askaswiss.com/2016/01/how-to-create-pencil-sketch-opencv-python.html打包 exe：https://pypi.org/project/auto-py-to-exe/</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1563.html">
<title>使用 EXECSTRING 指令执行字符串的内容</title>
<link>https://blog.niekun.net/archives/1563.html</link>
<dc:date>2020-05-07T15:57:00+08:00</dc:date>
<description>最近在编程中遇到一个问题：字符串内定义了一个已知的变量名，需要得到变量的值。例如：已知 real 类型全局变量：TEST定义一个字符串,并赋值：DEF STRING[10] STR1
STR1=&quot;TEST&quot;
想通过 STR1 来得到 TEST 变量的值。可以使用 EXECSTRING 来处理:EXECSTRING(&quot;R0=&quot;&lt;&lt;STR1)
以上指令可以将 TEST 变量的值读入 R0。</description>
</item>
</rdf:RDF>