<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/Linux/">
<title>Marco Nie - Linux</title>
<link>https://blog.niekun.net/category/Linux/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1747.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1666.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1547.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1378.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1376.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1375.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1334.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1316.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1296.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1280.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1747.html">
<title>Linux 系统时间设置问题</title>
<link>https://blog.niekun.net/archives/1747.html</link>
<dc:date>2020-09-17T10:47:00+08:00</dc:date>
<description>昨天重装了 vps 系统，在设置 crontab 定时任务时发现并没有在指定的时间执行脚本。于是就进行排查问题。测试在 /etc/crontab 添加一条测试任务:30  10    *  *  * root python -V &gt; /root/test.log
在 10：30 并没有看到 test.log 文件生成。通过 systemctl status cron 查看信息：Sep 17 10:21:01 niekun-bandwagon CRON[946]: pam_unix(cron:session): session clos
Sep 17 10:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)在 10：29 crontab 脚本已经重新加载过了，但是并没有执行任务。通过命令 cat /var/log/syslog | grep cron 查看系统日志：Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (pidfile fd = 3)
Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (Running @reboot jobs)
Sep 16 22:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)发现日志的时间比我当前时间晚了 12 个小时，会不会就是系统日期问题导致脚本没有达到设定的时间？在按装新系统的后，使用 date 命令查看当前系统时间，发现时间是 UTC 时间，我通过 tzselect 命令设置了时区：[root@db-server ~]# tzselect 
Please identify a location so that time zone rules can be set correctly.
Please select a continent or ocean.
 1) Africa
 2) Americas
 3) Antarctica
 4) Arctic Ocean
 5) Asia
 6) Atlantic Ocean
 7) Australia
 8) Europe
 9) Indian Ocean
10) Pacific Ocean
11) none - I want to specify the time zone using the Posix TZ format.
#? 5
Please select a country.
 1) Afghanistan           18) Israel                35) Palestine
 2) Armenia               19) Japan                 36) Philippines
 3) Azerbaijan            20) Jordan                37) Qatar
 4) Bahrain               21) Kazakhstan            38) Russia
 5) Bangladesh            22) Korea (North)         39) Saudi Arabia
 6) Bhutan                23) Korea (South)         40) Singapore
 7) Brunei                24) Kuwait                41) Sri Lanka
 8) Cambodia              25) Kyrgyzstan            42) Syria
 9) China                 26) Laos                  43) Taiwan
10) Cyprus                27) Lebanon               44) Tajikistan
11) East Timor            28) Macau                 45) Thailand
12) Georgia               29) Malaysia              46) Turkmenistan
13) Hong Kong             30) Mongolia              47) United Arab Emirates
14) India                 31) Myanmar (Burma)       48) Uzbekistan
15) Indonesia             32) Nepal                 49) Vietnam
16) Iran                  33) Oman                  50) Yemen
17) Iraq                  34) Pakistan
#? 9
Please select one of the following time zone regions.
1) east China - Beijing, Guangdong, Shanghai, etc.
2) Heilongjiang (except Mohe), Jilin
3) central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.
4) most of Tibet &amp; Xinjiang
5) west Tibet &amp; Xinjiang
#? 1
 
The following information has been given:
 
        China
        east China - Beijing, Guangdong, Shanghai, etc.
 
Therefore TZ='Asia/Shanghai' will be used.
Local time is now:      Sun Jan 11 23:31:51 CST 2015.
Universal Time is now:  Sun Jan 11 15:31:51 UTC 2015.
Is the above information OK?
1) Yes
2) No
#? yes
Please enter 1 for Yes, or 2 for No.
#? 1
 
You can make this change permanent for yourself by appending the line
        TZ='Asia/Shanghai'; export TZ
to the file '.profile' in your home directory; then log out and log in again.
 
Here is that TZ value again, this time on standard output so that you
can use the /usr/bin/tzselect command in shell scripts:
Asia/Shanghai将 TZ='Asia/Shanghai'; export TZ 写入 ~/.profile，并刷新文件：source .bash_profile测试当前系统时间：root@niekun-bandwagon:~# date
Thu Sep 17 10:44:00 CST 2020
但是系统日志记录的时间还是不对，这就可能还是时区不对，手动复制亚洲时区文件到目录：cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
更新 rsyslog 进程：systemctl restart rsyslog
再次测试发现系统日志时间对了，crontab 脚本也可以正确执行。也可以使用 timedatectl 命令设置时区：# 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone Asia/Shanghai</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1666.html">
<title>Linux 下使用 OptiPNG 压缩图片</title>
<link>https://blog.niekun.net/archives/1666.html</link>
<dc:date>2020-07-14T17:25:00+08:00</dc:date>
<description>最近越来也发现自己的博客加载图片变慢了，由于我很多教程是教 PS 的，会使用到很多图片和截图，所以影响尤其明显。每张图片小则 400Kb 大则 2-3Mb，对于网络浏览不太友好。可以直接在服务器上进行图片压缩，用到的工具是 OptiPNG。OptiPNG home page：http://optipng.sourceforge.net/编译安装我选择从源码编译安装，这样可以直接使用最新版本。如何从源码编译程序可以参考我的文章：https://blog.niekun.net/archives/883.html首先从官网下载源码到 vps 并解压：cd /tmp
wget http://prdownloads.sourceforge.net/optipng/optipng-0.7.7.tar.gz
tar xvf optipng-0.7.7.tar.gz
新建安装路径：mkdir /opt/optipng-0.7.7
ln -s /opt/optipng-0.7.7 /opt/optipng
configure & make：cd /tmp/optipng-0.7.7
./configure --prefix=/opt/optipng-0.7.7
make
make install
测试是否可以执行：/opt/optipng/bin/optipng
创建系统链接：ln -s /opt/optipng/bin/optipng /usr/local/bin/optipng
使用可以使用命令查看处理前处理后的图片体积：ls -lh a.png
压缩一张 png 图片：optipng a.png
压缩目录下的所有 png 图片：optipng *.png
可以自定义压缩等级：Optimization levels:
    -o0         &lt;=&gt;     -o1 -nx -nz                             (0 or 1 trials)
    -o1         &lt;=&gt;     -zc9 -zm8 -zs0 -f0                      (1 trial)
                (or...) -zc9 -zm8 -zs1 -f5                      (1 trial)
    -o2         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0,5                  (8 trials)
    -o3         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0,5                (16 trials)
    -o4         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0-5                  (24 trials)
    -o5         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0-5                (48 trials)
    -o6         &lt;=&gt;     -zc1-9 -zm8 -zs0-3 -f0-5                (120 trials)
    -o7         &lt;=&gt;     -zc1-9 -zm8-9 -zs0-3 -f0-5              (240 trials)
    -o7 -zm1-9  &lt;=&gt;     -zc1-9 -zm1-9 -zs0-3 -f0-5              (1080 trials)
Notes:
    The combination for -o1 is chosen heuristically.
    Exhaustive combinations such as &quot;-o7 -zm1-9&quot; are not generally recommended.
Examples:
    optipng file.png                                            (default speed)
    optipng -o5 file.png                                        (slow)
    optipng -o7 file.png                                        (very slow)</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1547.html">
<title>使用 SCP 管理远程服务器文件</title>
<link>https://blog.niekun.net/archives/1547.html</link>
<dc:date>2020-04-03T08:55:39+08:00</dc:date>
<description>安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输电脑文件。SCP是一种基于BSD RCP协议的网络传输协议，[3] 支持同一个网络上主机之间传输文件。SCP使用Secure Shell（SSH）完成数据传输，并使用同时用它进行身份认证，从而确保数据传输时的真实性和保密性。客户端可以向服务器发送（上传）文件，可选包含其基本属性（权限、时间戳）。客户端也可以请求（下载）一个服务器的文件或目录。SCP默认通过TCP端口22运行。和 SCP 类似功能的是 SFTP 协议，也是使用 SSH 传输数据，具体使用方法参考：https://blog.niekun.net/archives/130.htmlLinux 系统可以直接使用 scp 命令进行操作，Windows 系统可以安装 WinSCP，进行操作。下面介绍 Linux 下使用 scp 进行文件传输。复制远程文件到本地:scp -P port username@from_host:file.txt /local/directory/
复制本地文件到远程:scp file.txt username@to_host:/remote/directory/
复制远程文件夹到本地:scp -r username@from_host:/remote/directory/  /local/directory/

复制本地文件夹到远程:scp -r /local/directory/ username@to_host:/remote/directory/
复制远程文件到另一个远程服务器:scp username@from_host:/remote/directory/file.txt username@to_host:/remote/directory/
执行上面的命令后会提示要求输入所登录的远程用户密码。如果远程服务器 ssh 端口不是默认的 22，需要使用 -P 参数进行设置，注意是大写 P。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1378.html">
<title>NGINX Reverse Proxy 反向代理的使用</title>
<link>https://blog.niekun.net/archives/1378.html</link>
<dc:date>2020-03-30T11:05:00+08:00</dc:date>
<description>Proxying is typically used to distribute the load among several servers, seamlessly show content from different websites, or pass requests for processing to application servers over protocols other than HTTP.nginx 可以将一个客户端的请求反向代理到其他地址/端口，从客户端上看不到代理过程。方向代理的常用来处理服务器上部署的多个网络服务，根据请求呈现不同网页内容，转发请求到其他应用程序等。支持转发的协议有：  HTTP，FastCGI, uwsgi, SCGI, and memcached。不同于 nginx 的重定向 return/rewrite/try_fiels 功能，反向代理对于客户端是不可见的，关于重定向的语法参考：https://blog.niekun.net/archives/195.html下面介绍 ngx_http_proxy_module 模块的使用方式。语法proxy_pass 指令将请求转发到其他代理服务器。转发一个 http 请求到另一个地址：location /some/path/ {
    proxy_pass http://www.example.com/link/;
}以上示例将访问 location 段的请求转发到特定地址，这里有几个规则需要注意：1.代理地址如果不写明 location 段，则转发请求 location 到新的地址：location /some/path/ {
    proxy_pass http://www.example.com;
}以上规则下，访问 /some/path/.test.html 时，会转发到 http://www.example.com/some/path/.test.htmllocation ~ \.php {
    proxy_pass http://127.0.0.1:8000;
}以上规则下，访问 /some/path/test.php 时，会转发到 127.0.0.1:8000/some/path/test.php2.代理地址包含新的 location 时会替换掉请求 location 部分：location /some/path/ {
    proxy_pass http://www.example.com/new/;
}以上规则下，访问 /some/path/test.html 时，会转发到 http://www.example.com/new/test.html，注意 http://www.example.com/ 和 http://www.example.com 不同，也属于包含根路径 location 段的。proxy_pass 语法用来转发给 http 服务，还支持转发给其他协议的服务：fastcgi_pass 转发给 FastCGI server 如 php 服务uwsgi_pass 转发给 uwsgi server 如 python 服务scgi_pass 转发给 SCGI servermemcached_pass 转发给 memcached server转发的服务地址可以用一个 upstream 组来实现负载均衡：http {
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server 192.0.0.1 backup;
    }
    
    server {
        ...
        location / {
            proxy_pass http://backend;
        }
    }
}以上是一个简单的负载均衡代理转发示例。关于 upstream 详细使用参考官方教程proxy_redirect 响应头 location/refresh 重定向当上游服务器返回的响应是重定向或刷新请求（如HTTP响应码是301或者302）时，proxy_redirect可以重设HTTP头部的location/Refresh 字段。语法结构：proxy_redirect default;
proxy_redirect off;
proxy_redirect redirect replacement;
默认设置是：proxy_redirect default。http 响应头的 location 段 HTTP Location 是在两种情况使用在响应头中：要求网页浏览器加载其他网页(域名转址)。在这种情况下，应该使用HTTP状态码3xx发送Location头。提供有关新创建资源位置的信息。在这种情况下，应该使用HTTP状态码201或202发送Location头。通过修改 location 可以让客户端接收到响应后，访问重定向到新的 location。更详细的关于重定向/刷新请求头概念，需要理解 http 协议的结构，查看我的教程：HTTP 协议结构如果设置：server {listen 8080;
servername frontend;

proxy_redirect http://localhost:8000/two/ http://frontend:8080/one/;
...}代理服务器返回的 http 头信息：HTTP/1.1 302 Found
Location: http://localhost:8000/two/some/uri/
则返回给客户端的 Location 段被重写为: http://frontend:8080/one/some/uri/，客户端接收到后就会去重新访问这个新的地址。server 名也可以被省略：proxy_redirect http://localhost:8000/two/ /
以上指令返回给客户端的 Location 段被重写为: http://frontend:8080/some/uri/proxy_redirect 默认设置值为：default，它会自动根据 server location 段和 proxy_pass 地址来修改头信息，以下两种写法效果一样：location /one/ {
    proxy_pass     http://localhost:8000/two/;
    proxy_redirect default;

location /one/ {
    proxy_pass     http://localhost:8000/two/;
    proxy_redirect http://localhost:8000/two/ /one/;以上两种写法都是将返回 location 头信息中 http://localhost:8000/two/ 修改为 http://frontend:8080/one/redirect 和 replacement 都可以包含参数：proxy_redirect http://$proxy_host:8000/ $scheme$host:$server_port/;
rederect 可以使用正则匹配：proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
可以同时写多个 proxy_redirect 指令来处理不同的重定向地址。使用 proxy_redirect off 具有最高优先级，会取消当前同一级的所有 proxy_redirect 指令。一个完整例子：server {
    listen           8080;
    server_name      127.0.0.1;

    location /return {
        return 301 https://niekun.net;
    }
    location /proxy {
        proxy_pass  $scheme://$http_host/return;
        proxy_redirect https://niekun.net /echo;
    }
    location /echo {
        default_type text/plain;
        echo 'remote address: $remote_addr';
    }
}代理过程：客户端访问：http://127.0.0.1:8080/proxynginx 转发到：http://127.0.0.1:8080/return代理服务器响应 301 重定向到：https://niekun.net，http 头的 location 值为：https://niekun.netnginx 将 http 头的 location 修改为：http://127.0.0.1:8080/echonginx 将修改后的响应内容发送给客户端客户端根据响应再次访问：http://127.0.0.1:8080/echo转发请求头信息默认情况下，nginx 反向代理时会舍弃原始请求头中的空字符串项，并重新设定两个请求头内容：Host 和 Connection：Host -&gt; $proxy_host  也就是 proxy_pass 里的 hostConnection -&gt; close关于 http 请求头 header 的可定义的项目参考我的教程：HTTP 协议结构想要设置或修改传递给代理服务的请求头，使用 proxy_set_header 指令：location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Accept-Encoding &quot;&quot;;
    proxy_pass http://localhost:8000;
}以上示例的处理结果是：设置 Host 为本 server 的host 地址而不是转发地址设置 X-Real-IP 为客户端 IP 地址，用来识别访问服务的客户信息清空 Accept-Encoding 的内容mapping headers 动态请求头内容proxy_set_header 支持使用内部变量来定义，也可以使用 map 指令配合自定义参数来根据请求清空动态设置相关 header 内容，注意 map 指令要写在 http 段：map $http_cloudfront_forwarded_proto $cloudfront_proto {
    default &quot;http&quot;;
    https &quot;https&quot;;
}
server {
    ...
    location / {
        proxy_set_header X-Forwarded-Proto $cloudfront_proto;
        proxy_pass http://app;
        proxy_redirect off;
        ...
    }
}以上示例中 $http_cloudfront_forwarded_proto 是已知变量，$cloudfront_proto 是我自定义的变量，使用 map 指令来根据前者的值设置后者的值，然后在 proxy_set_header 设置。map 指令支持以两个因变量来给终变量赋值,语法示例如下：map &quot;$http_cloudfront_forwarded_proto:$http_x_forwarded_proto&quot; $cloudfront_proto {
    default &quot;http&quot;;
    &quot;:https&quot; &quot;https&quot;;
    &quot;https:&quot; &quot;https&quot;;
    &quot;https:http&quot; &quot;https&quot;;
    &quot;http:https&quot; &quot;https&quot;;
    &quot;https:https&quot; &quot;https&quot;;
}如果用户访问时加了代理或者网站有 CDN，$remote_addr 的值就不是用户真实 IP 了。客户端也可以伪造 X-Forwarded-For 信息，使用 map 指令提取用户真实 IP，注意 map 指令要写在配置文件的 http 段：map $http_x_forwarded_for  $client_real_ip {
    default                         $remote_addr;
    ~^(([0-9\.]+),\s?)*([0-9\.]+)$  $3;
}

server {
    echo 'remote address: $client_real_ip';
}如果 $http_x_forwarded_for 没有匹配到则赋值为 $remote_addr，如果匹配到了则提取最后一个 IP。$client_real_ip 变量就是真是客户端的 IP 地址。关于 $http_x_forwarded_for 和 $proxy_add_x_forwarded_for 参考我的文章：获取用户真实 IP in Nginxbuffers 缓存区默认情况下 nginx 缓存来自 proxy server 的响应内容。nginx 会一直在内部缓存来自代理服务器的响应内容直到内容接收完成，然后才发送给客户端。缓存能够帮助减轻客户端的压力，但会浪费服务器的资源和响应。但是打开缓存功能的另一个好处是当客户端再次进行一个缓存过的请求时，nginx 可以快速的返回已经在缓存区的内容。使用 proxy_buffering 指令控制缓存打开/关闭。默认是 on 状态。proxy_buffers 指令控制缓存区数量和缓存大小。第一个来自代理服务器的响应会缓存到单独的区域，proxy_buffer_size 指令控制这一区域的大小：location /some/path/ {
    proxy_buffers 16 4k;
    proxy_buffer_size 2k;
    proxy_pass http://localhost:8000;
}以上示例会给 来自代理服务器：http://localhost:8000 的响应建立 16 个缓存区，每个区域 4kb 空间，第一个响应缓存区 2kb 空间。如果关闭缓存，来自代理服务器的响应会即时发送给客户端，对于想要快速响应的使用场景可以关闭缓存：location /some/path/ {
    proxy_buffering off;
    proxy_pass http://localhost:8000;
}设置出口 IP 地址默认情况下 nginx 向 proxy 上游发起请求连接，代理服务器看到的请求 IP 地址来自 nignx 服务器地址。有时候 web 服务器会设置只允许特定 IP 地址的访问，可以通过 proxy_bind 指令来修改，nginx 用户必须是 root 才行：user root;
...
http{
    ...
    server {
        location /app1/ {
            proxy_bind proxy_bind $remote_addr transparent;
            proxy_pass http://example.com/app1/;
        }
    }
}以上示例中，代理服务器看到的请求来源就会是真正的访问客户端 IP 地址,也就是实现了透明代理。nginx 配置后还需要配置 iptables 路由表来处理代理服务器响应内容：新建一个链，把过来的tcp包都打上标记。新建一个路由表100，让有标记的包都走表100。在路由表100加入一个默认路由，把所有包都扔到lo网卡上去。      #### 新建一个 DIVERT 给包打标签
     sudo iptables -t mangle -N DIVERT;
     sudo iptables -t mangle -A DIVERT -j MARK --set-mark 1;
     sudo iptables -t mangle -A DIVERT -j ACCEPT;

     #### 把tcp的包给DIVERT处理
     sudo iptables -t mangle -A PREROUTING -p tcp -m socket -j DIVERT;

     #### 有标签的包去查名为 100 的路由表
     sudo ip rule add fwmark 1 lookup 100

     #### 100的路由表里就一条默认路由，把所有包都扔到lo网卡上去
     sudo ip route add local 0.0.0.0/0 dev lo table 100;具体实现我还不太懂，后期再研究下。以上就是 http 代理服务器基本使用，下面简单介绍其他集中代理服务器的语法。fastcgi 代理服务器Nginx must rely on a separate PHP processor to handle PHP requests. Most often, this processing is handled with php-fpm, a PHP processor that has been extensively tested to work with Nginx.简单说就是 FastCGI 实现了使用 Nginx 代理 php 请求的过程，将请求转发给 php-fpm：php 进程管理器。location / {
    fastcgi_pass  localhost:9000;
    # fastcgi_pass unix:/run/php/php7.3-fpm.sock;
    fastcgi_index index.php;
    
    fastcgi_split_path_info ^(.+?\.php)(.*)$;
    try_files $fastcgi_script_name =404;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    include fastcgi_params;

    fastcgi_param HTTP_X-REAL-IP $remote_addr;
    fastcgi_param HTTP_X-FORWARED-FOR $proxy_add_x_forwarded_for;
    fastcgi_param HOST $http_host;
}$fastcgi_split_path_info 用来将 请求 url 拆分成两部分：php 文件之前的 $fastcgi_script_name 和之后的部分：$fastcgi_path_infofastcgi_pass 定义真正的用来处理 FastCGI 代理的服务，一般默认地址为：127.0.0.1:9000，可自定义指定为特定版本的phpfastcgi_param 定义 FastCGI 参数fastcgi_params 一般在 nginx 配置目录下，包含了常用的 php 需要设定的参数。总结下和 http 语法区别：fastcgi_pass 类似于 proxy_passfastcgi_param  类似于 proxy_set_header，注意 fastcgi_param 添加 http 请求头信息要加上 HTTP_ 前缀，如：HTTP_X-FORWARED-FOR关于 FastCGI 的详细分析参考：Understanding and Implementing FastCGI Proxying in NginxuWSGI web 服务器uWSGI 是一个独立的 web 服务器，和 nginx 是一个类型的应用。一般 uWSGI 作为后端服务器使用，用 nginx 代理来访问。uWSGI 可以用来部署 python 应用。之前我学习 django 的时候就使用过这个。未完待续。。。参考链接ngx_http_proxy_module 模块所有指令NGINX Reverse ProxyHTTP Load BalancingSecuring HTTP Traffic to Upstream Servers使用nginx的proxy_bind选项配置透明的反向代理Mapping Headers in Nginxngx_http_fastcgi_module 模块所有指令[]()</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1376.html">
<title>traceroute 路由 IP 查看</title>
<link>https://blog.niekun.net/archives/1376.html</link>
<dc:date>2020-03-20T09:00:07+08:00</dc:date>
<description>traceroute 是一种电脑网络工具。它可显示数据包在 IP 网络经过的路由器的 IP 地址。程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减 1。当其存活时间是 0 时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。traceroute 使用互联网控制信息协议(ICMP)实现，ICMP 依靠IP来完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。由于协议不同所以本地 http 代理对 traceroute 无效。现代 Linux 系统称为 tracepath，Windows 系统称为 tracert，Windows NT 系统有结合 ping 和 traceroute 的 pathping 工具。使用Linux可以使用 tracepath/traceroute 工具来测试，traceroute 可使用 apt 来安装，默认最多检测30个路由节点，超过的话就直接结束：root@niekun-bandwagon:~# tracepath github.com
 1?: [LOCALHOST]                                         pmtu 1500
 1:  no reply
 2:  173.254.196.25.static.quadranet.com                   0.980ms
 3:  lax1-fatpipe-1.it7.net                                0.395ms
 4:  69.12.69.1                                            0.539ms asymm  3
 5:  ae12.er4.lax112.us.zip.zayo.com                       0.515ms asymm  4
 6:  ae14.cr2.lax112.us.zip.zayo.com                      26.123ms asymm 11
 7:  ae2.cs1.sjc2.us.eth.zayo.com                         26.180ms asymm 11
 8:  ae3.cs1.sea1.us.eth.zayo.com                         30.307ms asymm 10
 9:  ae1.mcs1.sea1.us.eth.zayo.com                        26.299ms asymm  8traceroute to github.com (192.30.255.112), 30 hops max, 60 byte packets
 1  * * *
 2  173.254.196.25.static.quadranet.com (173.254.196.25)  1.172 ms  1.172 ms  1.161 ms
 3  lax1-fatpipe-1.it7.net (69.12.70.234)  0.220 ms lax1-fatpipe-1.it7.net (69.12.70.232)  0.341 ms lax1-fatpipe-1.it7.net (69.12.70.234)  0.193 ms
 4  ae12.er4.lax112.us.zip.zayo.com (64.124.85.221)  0.397 ms  0.422 ms 69.12.69.1 (69.12.69.1)  0.268 ms
 5  ae14.cr2.lax112.us.zip.zayo.com (64.125.30.74)  25.828 ms ae12.er4.lax112.us.zip.zayo.com (64.124.85.221)  0.364 ms  0.345 ms
 6  ae2.cs1.sjc2.us.eth.zayo.com (64.125.28.144)  35.091 ms ae14.cr2.lax112.us.zip.zayo.com (64.125.30.74)  26.043 ms  26.009 ms
 7  ae2.cs1.sjc2.us.eth.zayo.com (64.125.28.144)  34.909 ms  34.889 ms  34.832 ms
 8  ae1.mcs1.sea1.us.eth.zayo.com (64.125.28.133)  28.864 ms  26.124 ms  26.112 ms
 9  ae1.mcs1.sea1.us.eth.zayo.com (64.125.28.133)  28.448 ms  28.416 ms 64.125.188.97.IPYX-243981-001-ZYO.zip.zayo.com (64.125.188.97)  30.797 ms
10  * 64.125.188.97.IPYX-243981-001-ZYO.zip.zayo.com (64.125.188.97)  30.949 ms *
windows可以使用 tracert/pathping 工具来测试，pathping 多显示了个本地 IP，默认最多检测30个路由节点，超过的话就直接结束：PS C:\Users\Marco Nie&gt; tracert niekun.net

Tracing route to niekun.net [104.24.97.72]
over a maximum of 30 hops:

  1     5 ms     1 ms     1 ms  OrayBox.lan [27.168.1.1]
  2    67 ms   111 ms    81 ms  192.168.1.1
  3     3 ms     3 ms     4 ms  100.64.16.1
  4     4 ms     3 ms     4 ms  10.226.25.13
  5     9 ms     *        *     219.145.223.105
  6    33 ms    32 ms    33 ms  202.97.65.41
  7     *        *        *     Request timed out.
  8     *       42 ms   131 ms  202.97.12.50
  9   341 ms   197 ms   201 ms  202.97.41.50
 10   237 ms   232 ms   224 ms  202.97.92.45
 11   242 ms   252 ms   238 ms  218.30.54.214
 12   197 ms   195 ms   196 ms  104.24.97.72

Trace complete.PS C:\Users\Marco Nie&gt; pathping niekun.net

Tracing route to niekun.net [104.24.97.72]
over a maximum of 30 hops:
  0  Marco-vostro-14.lan [27.168.1.209]
  1  OrayBox.lan [27.168.1.1]
  2  192.168.1.1
  3  100.64.16.1
  4  10.226.25.13
  5  219.145.223.105
  6  202.97.65.41
  7  202.97.34.74
  8     *     202.97.12.50
  9  202.97.41.50
 10  202.97.92.45
 11  218.30.54.214
 12  104.24.97.72

Computing statistics for 300 seconds...</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1375.html">
<title>wkhtmltopdf 将 html为 pdf</title>
<link>https://blog.niekun.net/archives/1375.html</link>
<dc:date>2020-03-18T12:58:56+08:00</dc:date>
<description>一般浏览器都可以将当前页面输出为 pdf，但当有很多个 html 文件时一个一个转换就很麻烦了，可以使用 wkhtmltopdf 命令行工具来实现自动化批量转换。wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely "headless" and do not require a display or display service.wkhtmltopdf 官网：https://wkhtmltopdf.org/GitHub 主页：https://github.com/wkhtmltopdf/wkhtmltopdf下载在 release 页面下载对应系统最新版：https://github.com/wkhtmltopdf/wkhtmltopdf/releases我要安装到 Ubuntu 18.04，所以下载：wkhtmltox_0.12.5-1.bionic_amd64.deb查看 Ubuntu 系统代号可以使用命令：lsb_release -c
安装下载的 deb 包，用以下命令进行安装：dpkg -i wkhtmltox_0.12.5-1.bionic_amd64.deb
使用支持 url 或 本地 html 转换：wkhtmltopdf http://bing.com bing.pdf
wkhtmltopdf path/to/test.html index.pdf
配合 find 命令可以实现批量转换：find path/to/html -name '*.html' -exec wkhtmltopdf {} {}.pdf \;
mkdir pdf/
find path/to/html -name '*.pdf' -exec mv {} pdf/ \;find 命令详细用法参考：https://blog.niekun.net/archives/543.html可以使用 wget 命令下载某个网站到本地，然后使用上面命令批量转换：wget -m -p -k URL
-m, –mirror 等价于 -r -N -l inf -nr-p：下载所有html文件适合显示的元素-k, –convert-links 转换非相对链接为相对链接,将文档链接都转换成本地的</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1334.html">
<title>systemd 使用入门</title>
<link>https://blog.niekun.net/archives/1334.html</link>
<dc:date>2020-03-13T15:27:00+08:00</dc:date>
<description>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。Systemd 架构systemctl是 Systemd 的主命令，用于管理系统。# 重启系统
$ sudo systemctl reboot

# 关闭系统，切断电源
$ sudo systemctl poweroff

# CPU停止工作
$ sudo systemctl halt

# 暂停系统
$ sudo systemctl suspend

# 让系统进入冬眠状态
$ sudo systemctl hibernate

# 让系统进入交互式休眠状态
$ sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
$ sudo systemctl rescuehostnamectl命令用于查看当前主机的信息。# 显示当前主机的信息
$ hostnamectl

# 设置主机名。
$ sudo hostnamectl set-hostname rhel7timedatectl命令用于查看当前时区设置。# 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone America/New_York
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SSUnitSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。Unit 一共分成12种:Service unit：系统服务
Target unit：多个 Unit 构成的一个组
Device Unit：硬件设备
Mount Unit：文件系统的挂载点
Automount Unit：自动挂载点
Path Unit：文件或路径
Scope Unit：不是由 Systemd 启动的外部进程
Slice Unit：进程组
Snapshot Unit：Systemd 快照，可以切回某个快照
Socket Unit：进程间通信的 socket
Swap Unit：swap 文件
Timer Unit：定时器systemctl status命令用于查看系统状态和单个 Unit 的状态。# 显示系统状态
$ systemctl status

# 显示单个 Unit 的状态
$ sysystemctl status bluetooth.serviceUnit 管理对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）# 立即启动一个服务
$ sudo systemctl start apache.service

# 立即停止一个服务
$ sudo systemctl stop apache.service

# 重启一个服务
$ sudo systemctl restart apache.service

# 杀死一个服务的所有子进程
$ sudo systemctl kill apache.service

# 查看一个服务的状态
$ sudo systemctl status apache.service

# 重新加载一个服务的配置文件
$ sudo systemctl reload apache.service

# 重载所有修改过的配置文件
$ sudo systemctl daemon-reload依赖关系Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。systemctl list-dependencies命令列出一个 Unit 的所有依赖。$ systemctl list-dependencies nginx.service
Unit 的配置文件每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。如果配置文件里面设置了开机启动，systemctl enable 命令相当于激活开机启动。与之对应的，systemctl disable 命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。配置文件的后缀名，就是该 Unit 的种类，比如 sshd.socket。如果省略，Systemd 默认后缀名为 .service，所以 sshd 会被理解成 sshd.service。从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的 systemctl status 命令。systemctl status bluetooth.service
一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。sudo systemctl daemon-reload
sudo systemctl restart httpd.service
配置文件的格式配置文件就是普通的文本文件，可以用文本编辑器打开。systemctl cat 命令可以查看配置文件的内容:root@niekun-bandwagon:~# systemctl cat nginx
# /lib/systemd/system/nginx.service
[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/opt/nginx/logs/nginx.pid
ExecStartPre=/usr/local/bin/nginx -t
ExecStart=/usr/local/bin/nginx
ExecReload=/usr/local/bin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target配置文件的区块[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。Description：简短描述
Documentation：文档地址
Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败
Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败
BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动
Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行
Condition...：当前 Unit 运行必须满足的条件，否则不会运行
Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中
RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中
Alias：当前 Unit 可用于启动的别名
Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。Type：定义启动时的进程行为。它有以下几种值。
Type=simple：默认值，执行ExecStart指定的命令，启动主进程
Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出
Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行
Type=dbus：当前服务通过D-Bus启动
Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行
Type=idle：若有其他任务执行完毕，当前服务才会运行
ExecStart：启动当前服务的命令
ExecStartPre：启动当前服务之前执行的命令
ExecStartPost：启动当前服务之后执行的命令
ExecReload：重启当前服务时执行的命令
ExecStop：停止当前服务时执行的命令
ExecStopPost：停止当其服务之后执行的命令
RestartSec：自动重启当前服务间隔的秒数
Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog
TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数
Environment：指定环境变量日志管理ystemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。journalctl 功能强大，用法非常多。# 查看所有日志（默认情况下 ，只保存本次启动的日志）
$ sudo journalctl

# 查看内核日志（不显示应用日志）
$ sudo journalctl -k

# 显示尾部的最新10行日志
$ sudo journalctl -n

# 查看指定服务的日志
$ sudo journalctl /usr/bin/python

# 查看某个 Unit 的日志
$ sudo journalctl -u nginx.service应用开机启动对于那些支持 Systemd 的软件，安装的时候，会自动在 /usr/lib/systemd/system 目录添加一个配置文件。如果你想让该软件开机启动，就执行下面的命令（以 httpd.service 例）。sudo systemctl enable httpd
上面的命令相当于在 /etc/systemd/system 目录添加一个符号链接，指向 /usr/lib/systemd/system 里面的httpd.service文件。这是因为开机时，Systemd只执行 /etc/systemd/system 目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。启动服务设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行 systemctl start 命令。sudo systemctl start httpd
执行上面的命令以后，有可能启动失败，因此要用 systemctl status 命令查看一下该服务的状态。停止服务终止正在运行的服务，需要执行 systemctl stop 命令:sudo systemctl stop httpd.service
有时候，该命令可能没有响应，服务停不下来。这时候就不得不"杀进程"了，向正在运行的进程发出 kill 信号:sudo systemctl kill httpd.service
此外，重启服务要执行 systemctl restart 命令：sudo systemctl restart httpd.service
参考链接http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.htmlhttp://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1316.html">
<title>Windows 下 VMware 安装 Ubuntu 虚拟机</title>
<link>https://blog.niekun.net/archives/1316.html</link>
<dc:date>2020-03-13T14:00:00+08:00</dc:date>
<description>虽然 Windows 10 自带有 WSL，可以安装 Linux 系统，但是在实际使用中发现还是有很多限制的。所以想要完整的 Linux 系统，还是安装了虚拟机。WSL 开启参考：https://blog.niekun.net/archives/1148.html我使用的是 VMware workstation 安装了 Ubuntu 18.04 LTS。安装过程中与遇到了一些问题，需要特别的进行处理，在此做一下记录。VMware workstation & Ubuntu官网下载 VMware workstation，需要购买序列号：https://my.vmware.com/en/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0下载完成后进行安装，然后根据提示重启及输入序列号。Ubuntu 18.04 LTS 镜像下载：http://releases.ubuntu.com/18.04.4/ubuntu-18.04.4-desktop-amd64.iso镜像下载完成后就可以开始准备安装虚拟机了，点击 文件 - 新建虚拟机：选择 典型 安装，然后下一步，点击浏览找到 Ubuntu 镜像文件：下面就根据提示设置虚拟机账户密码等信息，完成安装后会自动启动虚拟机，使用刚才设置的用户名密码登录虚拟机。分辨率设置光标退出虚拟机的快捷键是：ctrl alt。我的主机显示比例是 16:9 的1920 × 1080，开机后显示比例是 16:10 的，所以需要设置下全屏。首先点击保持纵横比拉伸来让显示尽量铺满全屏：进入 Ubuntu，点击右下角扩展键：搜索 displays，然后进入显示设置：选择一个和主机一样比例的分辨率：这样虚拟机就可以全屏了。VMware toolsVMware tools 可以让主机和虚拟机实现数据交互，很多功能依赖于 VMware tools，如：共享文件夹，网络桥接，共享剪贴板等。但是我在安装虚拟机后，VMware tools 安装项是灰色的：查询后了解到 Linux 的 tools 需要手动安装，官网对 Linux 虚拟机安装 VMware tools  有一篇教程：https://www.vmware.com/support/ws5/doc/ws_newguest_tools_linux.htmlVMware 安装的时候在安装目录下会有一个 linux.iso 文件，这就是 VMware tools 安装镜像，我的路径是：C:Program Files (x86)VMwareVMware Workstationlinux.iso首先在虚拟机设置里添加一个新的 cd/dvd，挂载 VMware 安装目录下的 linux.iso 镜像：进入 Ubuntu，桌面会有 VMware tools，终端路径是：/media/USERNAME/VMware Tools：进入 VMware Tools 目录，里面有一个压缩包：VMwareTools-10.3.10-13959562.tar.gz，执行如下命令：cd /tmp
tar xvf '/media/USERNAME/VMware Tools/VMwareTools-10.3.10-13959562.tar.gz'
cd vmware-tools-distrib
sudo ./vmware-install.pl执行解压目录下的 vmware-install.pl，一路 enter 即可。执行结束后就完成了 VMware Tools 的安装，重启系统。网络设置在虚拟机设置里将网络连接设置为桥接模式，这样虚拟机和主机就在一个 IP 网段内，如果不设置为桥接模式，虚拟机内可能无法执行一些网络命令，如：mtr：设置完成后重启虚拟机，主机使用命令 ipconfig 查看当前 IP：虚拟机使用命令 ifconfig 查看当前 IP：两个 IP 在一个网段内则设置成功。共享文件夹根据需要可以设置共享主机文件夹，在虚拟机内可以访问，共享文件夹路径是：/mnt/hgfs：在虚拟机终端测试访问：共享主机代理如果主机设置了代理，虚拟机可以直接共享此代理设置。首先设置主机代理端口开放给局域网，如果是显示只监听本地地址则 listen 地址设置为 127.0.0.1，如果开放监听局域网地址，则 listen 地址设置为 0.0.0.0 即可。在主机使用命令 ipconfig 查看主机 IP 地址。如果要在虚拟机设置系统代理，在虚拟机 Ubuntu 设置里搜索 proxy，点击 network proxy 手动设置代理地址：如果不想设置系统代理，也可以根据上面的主机地址和端口，在单独的应用程序里设置代理，如浏览器。终端代理设置参考我之前的文章，也是使用上面得到的主机 IP 和代理端口：https://blog.niekun.net/archives/97.html以上就是我用 VMware workstation 安装 Ubuntu 的过程。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1296.html">
<title>获取用户真实 IP in Nginx</title>
<link>https://blog.niekun.net/archives/1296.html</link>
<dc:date>2020-03-06T15:00:00+08:00</dc:date>
<description>对于没有连代理访问网站的用户或者没有加 CDN 的网站，可以直接在 Nginx 中用 deny 命令来拒绝某个 IP 的访问，$remote_addr 存储了当前链接用户的 IP:https://nginx.org/en/docs/http/ngx_http_access_module.html#denylocation / {
    deny  192.168.1.1;
    allow 192.168.1.0/24;
    allow 10.1.1.0/16;
    allow 2001:0db8::/32;
    deny  all;
}如果用户访问时加了代理或者网站有 CDN，$remote_addr 的值就不是用户真实 IP 了。$remote_addr 变量默认读取 $proxy_add_x_forwarded_for 变量最后一个 IP 地址，一般情况下这个就是客户端原始 IP，但当网站加了 CDN，最后一个 IP 就成了 CDN 分配的 IP，如用户本地 IP为：1.81.218.204，访问没有加 CDN 的网站：$remote_addr：1.81.218.204
$http_x_forwarded_for: 1.81.218.204
$proxy_add_x_forwarded_for: 1.81.218.204
如果网站加了 CDN 返回信息如下：$remote_addr：172.69.34.194
$http_x_forwarded_for: 1.81.218.204
$proxy_add_x_forwarded_for: 1.81.218.204, 172.69.34.194
可以看到 $remote_addr 发生了变化。$http_x_forwarded_for 的值没有包含 CDN 代理 IP。客户端也可以伪造 X-Forwarded-For 信息，如下使用 curl -H 参数设置头信息：curl https://info.niekun.net -H 'X-Forwarded-For: 2.2.2.2' -H 'X-Forwarded-For: 3.3.3.3'
这时候 nginx 的变量就发生了变化：$remote_addr：172.69.34.194
$http_x_forwarded_for: 2.2.2.2, 3.3.3.3, 1.81.218.204
$proxy_add_x_forwarded_for: 2.2.2.2, 3.3.3.3, 1.81.218.204, 172.69.34.194
可以看到 $http_x_forwarded_for 和 $proxy_add_x_forwarded_for 变量值都附加上了伪造的信息。根据观察 $http_x_forwarded_for 的最后一个 IP，永远是真实的用户 IP，可以进行提取。使用 map 指令提取用户真实 IP，注意 map 指令要写在配置文件的 http 段：map $http_x_forwarded_for  $client_real_ip {
    default                         $remote_addr;
    ~^(([0-9\.]+),\s?)*([0-9\.]+)$  $3;
}如果 $http_x_forwarded_for 没有匹配到则赋值为 $remote_addr，如果匹配到了则提取最后一个 IP。$client_real_ip 变量就是真是客户端的 IP 地址。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1280.html">
<title>Nginx upstream timed out 问题的处理</title>
<link>https://blog.niekun.net/archives/1280.html</link>
<dc:date>2020-03-05T08:53:00+08:00</dc:date>
<description>在安装 wordpress 后遇到一个问题，打开后台的 theme 页面后，一直无法加载出来内容，查看后台 nginx 的日志，发现如下错误：[error] 10929#10929: *337 upstream timed out (110: Connection timed out) while reading upstream, client: 127.0.0.1, server: 127.0.0.1, request: &quot;GET /wp-admin/theme-install.php HTTP/1.1&quot;, upstream: &quot;fastcgi://unix:/run/php/php7.3-fpm.sock:&quot;, host: &quot;127.0.0.1&quot;, referrer: &quot;http://127.0.0.1/wp-admin/themes.php&quot;大概是处理 php 页面的时候 timeout 了，Google 了发现问题出在转发到代理服务器 fastCGI 时超时了:https://talk.plesk.com/threads/upstream-timed-out-110-connection-timed-out-randomly.350497/解决方案就是在 nginx 配置文件内定义一下相关超时时间设定：proxy_connect_timeout 600;
proxy_send_timeout 600;
proxy_read_timeout 600;
send_timeout 600;将上述内容加入 config 文件，reload nginx 测试页面加载是否正常：sudo service nginx configtest
sudo service nginx reload


</description>
</item>
</rdf:RDF>