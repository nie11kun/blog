<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/Linux/">
<title>Marco Nie - Linux</title>
<link>https://blog.niekun.net/category/Linux/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1805.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1801.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1781.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1763.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1758.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1757.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1754.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1752.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1747.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1666.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1805.html">
<title>wsl 2 激活 systemd</title>
<link>https://blog.niekun.net/archives/1805.html</link>
<dc:date>2020-10-13T12:03:00+08:00</dc:date>
<description>wsl 默认不支持 systemd，执行 systemd 命令会返回错误提示：# hostnamectl
System has not been booted with systemd as init system (PID 1). Can't operate.
Failed to create bus connection: Host is down可以安装第三方的工具 genie 来激活 systemd。GitHub：https://github.com/arkane-systems/genie安装添加第三方 apt 库，在 /etc/apt/sources.list.d 目录下新建文件 wsl-translinux.list，文件内容如下：deb [trusted=yes] https://wsl-translinux.arkane-systems.net/apt/ /更新库列表：apt update &amp;&amp; apt upgrade
安装依赖包：安装 Microsoft 依赖，下载对应系统版本的 prod 包：https://packages.microsoft.com/config/：curl -O https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
dpkg -i packages-microsoft-prod.deb安装其他依赖：apt update &amp;&amp; apt install apt-transport-https daemonize dotnet-runtime-3.1安装 genie：apt install systemd-genie
使用退出 wsl 系统后关闭 所有已打开的 wsl：wsl --shutdown
启动 wsl：wsl genie -s
启动的 Linux 系统就可以正常使用 systemd 了。参考链接：https://gist.github.com/djfdyuruiry/6720faa3f9fc59bfdf6284ee1f41f950</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1801.html">
<title>wls 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置</title>
<link>https://blog.niekun.net/archives/1801.html</link>
<dc:date>2020-10-13T10:01:00+08:00</dc:date>
<description>在升级到 wsl 2 后发现一些网络问题和之前的 wsl 不一样了，主要是 DNS 解析和 wsl 和 Windows 网络互访问题，这里介绍如何处理。DNS 解析wsl 2 使用的 DNS 解析服务器设置在文件：/etc/resolv.conf 内设置，这是一个 link 文件，真正的文件路径是：/run/resolvconf/resolv.conf，这个文件是每次 wsl 启动时自动生成的，内容如下：# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.24.144.1nameserver 后面的就是指定的 DNS 服务器地址。我发现有时候分配的服务器地址是无效的，如：127.0.0.53，使用 ping 来测试发现提示无法解析地址。需要设置一个固定的 DNS 地址，方法如下：新建文件：/etc/wsl.conf，内容如下：[network]
generateResolvConf = false以上配置好就不会自动创建 /run/resolvconf/resolv.conf 文件了。退出 wsl，关机然后重新启动：exit
wsl --shutdown
wsl
删除 link 文件：/etc/resolv.conf:rm /etc/resolv.conf
然后新建 /etc/resolv.conf 文件，内容如下，可自定义 nameserver 地址：nameserver 114.114.114.114
再次退出 wsl，关机然后重新启动：exit
wsl --shutdown
wsl
查看 /etc/resolv.conf 文件是否是之前自定义的地址：cat /etc/resolv.conf
测试网络服务：ping niekun.net
参考链接：https://github.com/microsoft/WSL/issues/5256#issuecomment-666545999网络访问配置以前使用 wsl 时 Linux 子系统和 Windows 主机的网络好像是直接互通的，比如我在 Windows 下建立了一个 http 网页 http://127.0.0.1:6000，可以在 Linux 子系统下直接访问地址 http://127.0.0.1:6000，同理对于 Windows 主机访问 Linux 子系统的服务也是可以使用 localhost 直接访问的。在升级到 wsl 2 后发现这一特性没有了，无法直接通过 localhost 地址来互通，查询官方说明关于wsl 2 访问网络服务 的方法可以实现访问，但是每次关机后 wsl 和 Windows 本地地址会发生变化不方便使用。可以设置静态 IP 来固定地址。Windows 终端下执行下面命令：在 wsl 下增加 IP 地址：192.168.50.16，名称为：eth0:1:(以 Ubuntu 系统为例)wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
在 Windows 10 下增加一个 IP 地址：(此命令需要管理员权限执行)netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
执行后，在 wsl 下通过 IP：192.168.50.88 访问 Windows 服务。在 Windows 下通过 IP：192.168.50.16 访问 wsl 服务。完成后再终端使用 ipconfig 查看设置：Ethernet adapter vEthernet (WSL):

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe60::b525:6b90:8fb0:f513%58
   IPv4 Address. . . . . . . . . . . : 172.23.64.1
   Subnet Mask . . . . . . . . . . . : 255.255.240.0
   IPv4 Address. . . . . . . . . . . : 192.168.50.88
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :以上两个命令可以写在一个 powershell 脚本文件内，脚本内设置管理员权限执行，由于需要管理员权限所以无法通过建立 shortcut 放到开机自启动文件夹来自动启动址。wsl_ip.ps1 脚本内容如下，会自动请求管理员权限：if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;))  
{  
  $arguments = &quot;&amp; '&quot; +$myinvocation.mycommand.definition + &quot;'&quot;
  Start-Process powershell -Verb runAs -ArgumentList $arguments
  Break
}

wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
为了方便使用，可以将脚本路径加入系统 PATH 中，这样可以方便的在终端直接运行脚本，PATH 设置参考：https://blog.niekun.net/archives/413.html完成后打开终端直接执行命令：wsl_ip 即可快速设置 IP。参考链接：https://github.com/MicrosoftDocs/WSL/issues/418#issuecomment-648570865</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1781.html">
<title>echo 命令的使用</title>
<link>https://blog.niekun.net/archives/1781.html</link>
<dc:date>2020-09-30T09:23:00+08:00</dc:date>
<description>echo 是常用的终端命令，常用来输出字符串。配合命令的 option 选项可以实现多种输出方式。语法结构：echo [option(s)] [string(s)]
常规使用输出字符串：$ echo i have a dream
i have a dream输出变量：$ x=10
$ echo $x
10输出目录下所有文件名：$ echo *
Business Card Template - PiXimperfect.psd Telegram Desktop Video desktop.ini echo.txt test1.txt test2.txt输出特定名称的文件名：$ echo *.txt
echo.txt test1.txt test2.txt将字符串输出到文件：$ echo 'abc' &gt; test.txt
$ cat test.txt
abc使用 -e 选项识别字符串内的转义符 \\b 表示清除字符间空格$ echo -e 'a \bb \bc'
abc\n 表示换行$ echo -e 'a\nb\nc'
a
b
c\t 表示添加制表符$ echo -e 'a\tb\tc'
a       b       c可以结合 \n \t 使用：$ echo -e '\ta\n\tb\n\tc'
        a
        b
        c\v 表示添加垂直方向制表符$ echo -e 'a\vb\vc'
a
 b
  c\r 表示丢弃前面的字符串$ echo -e 'a\rbc'
bc\c 表示丢弃后面的字符串$ echo -e 'a\cbc'
aroot@localhost$以上就是 echo 命令的简单使用方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1763.html">
<title>Failed to parse PID from file /opt/nginx/logs/nginx.pid 处理</title>
<link>https://blog.niekun.net/archives/1763.html</link>
<dc:date>2020-09-22T16:27:00+08:00</dc:date>
<description>今天在使用 journalctl 查看 nginx 日志时看到在每次启动服务后会出现一条错误信息：$ journalctl -u nginx
...
nginx.service: Failed to parse PID from file /opt/nginx/logs/nginx.pid: Invalid argument
...
查找了下原因，可能是 nginx 在启动时创建 nginx.pid 文件前 systemd 就在请求这个文件，所以出错了。解决办法就是题前手动创建 systemd 需要的文件：mkdir /etc/systemd/system/nginx.service.d
printf &quot;[Service]\nExecStartPost=/bin/sleep 0.1\n&quot; &gt; /etc/systemd/system/nginx.service.d/override.conf
systemctl daemon-reload以上处理就可以解决问题。参考链接：https://bugs.launchpad.net/ubuntu/+source/nginx/+bug/1581864</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1758.html">
<title>从源码编译安装 python</title>
<link>https://blog.niekun.net/archives/1758.html</link>
<dc:date>2020-09-21T16:35:00+08:00</dc:date>
<description>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最新版是 3.8.5，在这个页面找到地址：https://www.python.org/downloads/release/python-385/下载 tgz 压缩包到本地并解压：cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz环境安装编译需要安装一些依赖：apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
编译python 源码使用标准 GNU 编译系统，详细说明参考：https://blog.niekun.net/archives/883.html将 python 安装到 /opt 目录，先创建文件夹：mkdir /opt/python3.8.5
然后配置 configure：cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \没有错误提示的话就开始编译和安装：make
make install
安装完成后测试执行：/opt/python3.8.5/bin/python3 --version
返回版本信息则安装完成。下面将可执行文件加入系统路径，创建软连接：ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
测试运行：python --version
安装 pip源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。官网：https://pip.pypa.io/en/stable/installing/下载脚本到本地：curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py使用刚才安装的 python 执行脚本：/opt/python3.8.5/bin/python3 get-pip.py
pip 的安装路径是 /opt/python3.8.5/bin/，测试命令：/opt/python3.8.5/bin/pip3 --version
返回版本信息则安装完成。添加软连接到系统路径：ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
测试命令：pip --version
参考链接https://docs.rstudio.com/resources/install-python-source/</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1757.html">
<title>awk 命令的用法</title>
<link>https://blog.niekun.net/archives/1757.html</link>
<dc:date>2020-09-18T16:20:00+08:00</dc:date>
<description>awk 是常用的 Linux 文本操作命令和脚本语言。用来按行提取和处理文本内容，也可以执行简单的逻辑处理。比如我们有一个 txt 文件：ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452执行命令：$ awk '{print $1}' test.txt
ab.c
oh.g
si.d可以看到返回结果为每一行的第一个字符串。默认以空格作为分隔符。$1 为每行第一个字符串，$2 为每行第二个字符串，以此类推。$0 为整个文本。可以同时输出多个内容：$ awk '{print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156内部集成的参数FS 区域分割符awk 默认使用空格来分割字符串，也可以自己定义分割符：$ awk 'FS = &quot;.&quot; {print $1, $2}' test.txt
ab c 123 e
oh g 324 b
si d 156 o这时候，ab 和 c 123 e 分别是一个整体。还有一种写法使用 -F 表示，要写在引号外部：$ awk -F. '{print $1, $2}' test.txt
NF 每行字符串个数用 $NF 来表示每行最后一个串：$ awk '{print $NF}' test.txt
456
756
452用 NF 来判断每行字符串格个数：只输出有 4 个字符串的所在行的内容$ awk 'NF == 4 {print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156NR 当前行号NR 记录当前行的行号：$ awk '{print NR}' test.txt
1
2
3$ awk '{print NR, $0}' test.txt
1 ab.c 123 e.rt 456
2 oh.g 324 b.na 756
3 si.d 156 o.ui 452OFS 定义输出串分割符字符串输出是可以自定义分割符号：$ awk 'OFS=&quot;/&quot; {print $1, $2}' test.txt
ab.c/123
oh.g/324
si.d/156BEGIN 和 END 规则BEGIN 规则是在 awk 读取输入文本前执行的指令，END 规则是在 awk 输出完字符串后执行的指令。$ awk 'BEGIN {print &quot;begin process&quot;} {print $0} END {print &quot;end process&quot;}' test.txt
begin process
ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452
end process判断模块可以使用常用的判断来过滤输出结果：设置第4个字符串数字需要大于等于500：$ awk '$4 &gt;=500 {print $0}' test.txt
oh.g 324 b.na 756设置行内必须包含字符串 ab:$ awk '/ab/ {print $0}' test.txt
ab.c 123 e.rt 456设置行开始必须包含字符串 ab:$ awk '/^ab/ {print $0}' test.txt
ab.c 123 e.rt 456awk script 脚本如果命令很复杂，可以建立一个脚本来单独执行。建立文件：test.awk#!/usr/bin/awk -f

BEGIN {
  # set the input and output field separators
  FS=&quot;:&quot;
  OFS=&quot;:&quot;
  # zero the accounts counter
  accounts=0
}
{
  # set field 2 to nothing
  $2=&quot;&quot;
  # print the entire line
  print $0
  # count another account
  accounts++
}
END {
  # print the results
  print accounts &quot; accounts.\n&quot;
}可执行权限：chmod +x test.awk
执行：./test.awk /etc/passwd
windowswindows 下也可以使用 awk，下载安装 Gawk 即可。官网：http://gnuwin32.sourceforge.net/packages/gawk.htm下载对应安装包，安装后将 awk 可执行文件的路径加入系统 PATH 即可使用，参考：https://blog.niekun.net/archives/413.html参考链接https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/http://linuxcommand.org/lc3_adv_awk.php</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1754.html">
<title>${1%str} 在 shell 脚本的用法</title>
<link>https://blog.niekun.net/archives/1754.html</link>
<dc:date>2020-09-18T15:25:00+08:00</dc:date>
<description>执行 shell 脚本时经常会有传入参数，如：./test.sh abcdef abc.bbb
以上的命令使用了两个传入参数，abcdef,abc.bbb。在脚本里使用时，$1 就表示第一个参数，$2 就表示第二个参数:var1 = $1
var2 = $2在脚本中有一种用法，如：${1%def}jjj。他的意思就是将 $1 最后的字符 def 替换为 jjj：newstr1 = ${1%def}jjjnewstr1 的值就是 abcjjj。newstr2 = ${2%.bbb}.cccnewstr2 的值就是 abc.ccc。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1752.html">
<title>FFmpeg 简单用法</title>
<link>https://blog.niekun.net/archives/1752.html</link>
<dc:date>2020-09-18T15:03:12+08:00</dc:date>
<description>FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。官方网站：https://www.ffmpeg.org/安装最简单的方法就是用包管理工具如：apt 安装：apt update
apt install ffmpeg
或者也可以从源码安装，可以参考我之前的教程：https://blog.niekun.net/archives/891.html常用指令查看 ffmpeg 版本：ffmpeg -version
查看支持的编码格式：如 h.264, h.265ffmpeg -codecs
查看支持的容器：如 mp4, mp3, mkvffmpeg -formats
查看已安装的编码器：如 libx264, libx265, libvpx, aacffmpeg -encoders
使用格式FFmpeg 的命令行参数非常多，可以分成五个部分。ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下：全局参数
输入文件参数
输入文件
输出文件参数
输出文件参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]下面是一个例子:ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。一般可以省略输入文件参数。常用命令参数-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。常规使用方法查看元数据信息，如时长，比特率等：ffmpeg -i test.mp4
输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：ffmpeg -i test.mp4 -hide_banner
转码，如 avi to h.264:ffmpeg -i test.avi -c:v libx264 test.mp4
转换容器：ffmpeg -i test.mp4 -c copy test.webm转换容器不需要转码，所以直接 copy 即可。转换码率，转换成固定码率：ffmpeg -i test.mp4 -b:v 500k test_out.mp4
转换码率，转换成一个码率范围：ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
改变分辨率：转换成 480pffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4视频中提取音频：ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg%3d 在 shell 里表示至少输出3个字符空间的数字：% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;如果只需要截一张图，可以指定只截取一帧。$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是1到5之间（1 为质量最高）。裁剪:裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]下面是实际的例子。# 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。高级用法压缩视频内容到指定容量大小使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。bash脚本：#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;使用方法：压缩视频到 50 MB 大小./script.sh test.mp4 50
切割视频到指定时长的多个视频使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。python 脚本：#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()使用方法：将视频切割为单个视频100秒./split.py -f test.mp4 -s 100
ffprobe 使用ffprobe 可以用来得到视频信息。视频时长：秒ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
视频码率：bitffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
参考链接http://www.ruanyifeng.com/blog/2020/01/ffmpeg.htmlhttps://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-sizehttps://github.com/c0decracker/video-splitterhttps://trac.ffmpeg.org/wiki/FFprobeTips</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1747.html">
<title>Linux 系统时间设置问题</title>
<link>https://blog.niekun.net/archives/1747.html</link>
<dc:date>2020-09-17T10:47:00+08:00</dc:date>
<description>昨天重装了 vps 系统，在设置 crontab 定时任务时发现并没有在指定的时间执行脚本。于是就进行排查问题。测试在 /etc/crontab 添加一条测试任务:30  10    *  *  * root python -V &gt; /root/test.log
在 10：30 并没有看到 test.log 文件生成。通过 systemctl status cron 查看信息：Sep 17 10:21:01 niekun-bandwagon CRON[946]: pam_unix(cron:session): session clos
Sep 17 10:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)在 10：29 crontab 脚本已经重新加载过了，但是并没有执行任务。通过命令 cat /var/log/syslog | grep cron 查看系统日志：Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (pidfile fd = 3)
Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (Running @reboot jobs)
Sep 16 22:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)发现日志的时间比我当前时间晚了 12 个小时，会不会就是系统日期问题导致脚本没有达到设定的时间？在按装新系统的后，使用 date 命令查看当前系统时间，发现时间是 UTC 时间，我通过 tzselect 命令设置了时区：[root@db-server ~]# tzselect 
Please identify a location so that time zone rules can be set correctly.
Please select a continent or ocean.
 1) Africa
 2) Americas
 3) Antarctica
 4) Arctic Ocean
 5) Asia
 6) Atlantic Ocean
 7) Australia
 8) Europe
 9) Indian Ocean
10) Pacific Ocean
11) none - I want to specify the time zone using the Posix TZ format.
#? 5
Please select a country.
 1) Afghanistan           18) Israel                35) Palestine
 2) Armenia               19) Japan                 36) Philippines
 3) Azerbaijan            20) Jordan                37) Qatar
 4) Bahrain               21) Kazakhstan            38) Russia
 5) Bangladesh            22) Korea (North)         39) Saudi Arabia
 6) Bhutan                23) Korea (South)         40) Singapore
 7) Brunei                24) Kuwait                41) Sri Lanka
 8) Cambodia              25) Kyrgyzstan            42) Syria
 9) China                 26) Laos                  43) Taiwan
10) Cyprus                27) Lebanon               44) Tajikistan
11) East Timor            28) Macau                 45) Thailand
12) Georgia               29) Malaysia              46) Turkmenistan
13) Hong Kong             30) Mongolia              47) United Arab Emirates
14) India                 31) Myanmar (Burma)       48) Uzbekistan
15) Indonesia             32) Nepal                 49) Vietnam
16) Iran                  33) Oman                  50) Yemen
17) Iraq                  34) Pakistan
#? 9
Please select one of the following time zone regions.
1) east China - Beijing, Guangdong, Shanghai, etc.
2) Heilongjiang (except Mohe), Jilin
3) central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.
4) most of Tibet &amp; Xinjiang
5) west Tibet &amp; Xinjiang
#? 1
 
The following information has been given:
 
        China
        east China - Beijing, Guangdong, Shanghai, etc.
 
Therefore TZ='Asia/Shanghai' will be used.
Local time is now:      Sun Jan 11 23:31:51 CST 2015.
Universal Time is now:  Sun Jan 11 15:31:51 UTC 2015.
Is the above information OK?
1) Yes
2) No
#? yes
Please enter 1 for Yes, or 2 for No.
#? 1
 
You can make this change permanent for yourself by appending the line
        TZ='Asia/Shanghai'; export TZ
to the file '.profile' in your home directory; then log out and log in again.
 
Here is that TZ value again, this time on standard output so that you
can use the /usr/bin/tzselect command in shell scripts:
Asia/Shanghai将 TZ='Asia/Shanghai'; export TZ 写入 ~/.profile，并刷新文件：source .bash_profile测试当前系统时间：root@niekun-bandwagon:~# date
Thu Sep 17 10:44:00 CST 2020
但是系统日志记录的时间还是不对，这就可能还是时区不对，手动复制亚洲时区文件到目录：cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
更新 rsyslog 进程：systemctl restart rsyslog
再次测试发现系统日志时间对了，crontab 脚本也可以正确执行。也可以使用 timedatectl 命令设置时区：# 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone Asia/Shanghai</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1666.html">
<title>Linux 下使用 OptiPNG 压缩图片</title>
<link>https://blog.niekun.net/archives/1666.html</link>
<dc:date>2020-07-14T17:25:00+08:00</dc:date>
<description>最近越来也发现自己的博客加载图片变慢了，由于我很多教程是教 PS 的，会使用到很多图片和截图，所以影响尤其明显。每张图片小则 400Kb 大则 2-3Mb，对于网络浏览不太友好。可以直接在服务器上进行图片压缩，用到的工具是 OptiPNG。OptiPNG home page：http://optipng.sourceforge.net/编译安装我选择从源码编译安装，这样可以直接使用最新版本。如何从源码编译程序可以参考我的文章：https://blog.niekun.net/archives/883.html首先从官网下载源码到 vps 并解压：cd /tmp
wget http://prdownloads.sourceforge.net/optipng/optipng-0.7.7.tar.gz
tar xvf optipng-0.7.7.tar.gz
新建安装路径：mkdir /opt/optipng-0.7.7
ln -s /opt/optipng-0.7.7 /opt/optipng
configure & make：cd /tmp/optipng-0.7.7
./configure --prefix=/opt/optipng-0.7.7
make
make install
测试是否可以执行：/opt/optipng/bin/optipng
创建系统链接：ln -s /opt/optipng/bin/optipng /usr/local/bin/optipng
使用可以使用命令查看处理前处理后的图片体积：ls -lh a.png
压缩一张 png 图片：optipng a.png
压缩目录下的所有 png 图片：optipng *.png
可以自定义压缩等级：Optimization levels:
    -o0         &lt;=&gt;     -o1 -nx -nz                             (0 or 1 trials)
    -o1         &lt;=&gt;     -zc9 -zm8 -zs0 -f0                      (1 trial)
                (or...) -zc9 -zm8 -zs1 -f5                      (1 trial)
    -o2         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0,5                  (8 trials)
    -o3         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0,5                (16 trials)
    -o4         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0-5                  (24 trials)
    -o5         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0-5                (48 trials)
    -o6         &lt;=&gt;     -zc1-9 -zm8 -zs0-3 -f0-5                (120 trials)
    -o7         &lt;=&gt;     -zc1-9 -zm8-9 -zs0-3 -f0-5              (240 trials)
    -o7 -zm1-9  &lt;=&gt;     -zc1-9 -zm1-9 -zs0-3 -f0-5              (1080 trials)
Notes:
    The combination for -o1 is chosen heuristically.
    Exhaustive combinations such as &quot;-o7 -zm1-9&quot; are not generally recommended.
Examples:
    optipng file.png                                            (default speed)
    optipng -o5 file.png                                        (slow)
    optipng -o7 file.png                                        (very slow)</description>
</item>
</rdf:RDF>