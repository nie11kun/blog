<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2020/12/">
<title>Marco Nie - 2020年12月</title>
<link>https://blog.niekun.net/2020/12/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1966.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1958.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1956.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1966.html">
<title>macOS 下使用 QT 部署工具 macdeployqt</title>
<link>https://blog.niekun.net/archives/1966.html</link>
<dc:date>2020-12-05T23:53:15+08:00</dc:date>
<description>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。工具路径在 QT 安装目录的对应编译器 bin 目录下，如：/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：打开 ~/.zshrc 添加如下内容，可以使用 vim 来操作：export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin编辑完成后关闭文件，刷新源：source ~/.zshrc
现在就可以直接使用命令了：macdeployqt -h

部署的方法是直接在 macdeployqt 后提供 app 路径：macdeployqt path/to/test.app
执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 app/Contents/Frameworks 文件夹内。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1958.html">
<title>QT 添加第三方库</title>
<link>https://blog.niekun.net/archives/1958.html</link>
<dc:date>2020-12-02T11:52:00+08:00</dc:date>
<description>如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。GUI 添加使用 GUI 添加的好处是比较直观，使用鼠标点击即可。右键项目名称，点击 add library：选中 external library 点击 next：选择头文件所在目录路径：如果有 lib 库文件的话需要链接进来，没有的话可以不设置：其他保持默认然后点击 next 完成添加。我们打开 pro 文件可以看到在文件最后添加了相关内容：win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dlld
else:unix: LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll

INCLUDEPATH += $$PWD/../../../Library/boost_1_72_0
DEPENDPATH += $$PWD/../../../Library/boost_1_72_0pro 文件添加根据添加一个第三方库所增加的语句，我们可以手动直接编辑 pro 文件完成添加：LIBS 指定 lib 库文件路径，没有的话不需要定义INCLUDEPATH 指头文件所在目录DEPENDPATH 定义和头文件相同目录即可例如我们添加一个 boost filesystem 库到项目：LIBS += -L&quot;/path/to/boost_1_72_0/stage/lib/&quot; \
        -llibboost_filesystem-mgw81-mt-x32-1_72 \
        -llibboost_regex-mgw81-mt-x32-1_72

INCLUDEPATH += &quot;/path/to/boost_1_72_0&quot;
DEPENDPATH += &quot;/path/to/boost_1_72_0&quot;LIBS 中，使用 -L 添加 lib 库目录，使用 -l 添加具体某个库文件，可以不写文件后缀。以上就是 QT 中添加第三方库的方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1956.html">
<title>Macros 聚集 in c++</title>
<link>https://blog.niekun.net/archives/1956.html</link>
<dc:date>2020-12-01T11:37:00+08:00</dc:date>
<description>在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符作为 macro 名称，甚至是 c 关键词。object 形式object 形式的 macro 就是简单的使用一个 identifier 代替代码片段。使用 #define 定义一个 macro：#define TESTINT 1024

void main() {
    int a = TESTINT;
    cout &lt;&lt; a &lt;&lt; endl;
}

//output:
//1024也可以定义一个片段：#define NUMBERS 1, 2, 3

void main() {
    int x[] = { NUMBERS };
    //int x[] = { 1, 2, 3 };这两句效果相同
}也可以多层定义：#define NUMBER1 1
#define NUMBER2 NUMBER1以上示例中 NUMBER2 等于 NUMBER1。function 形式可以定义 function 形式的 macro，需要在定义中 macro 名称后加上圆括号()。例如：#define lang_init()  c_init()定义后就可以使用 lang_init() 来调用 c_init() 了，类似于 alias。object 类型的 macro 可以和 function 类型的 macro 同名，区别就是有没有圆括号：#define test 100
#define test() func()

void main() {
    int a = test;
    test();
}以上就是对 macro 的简单介绍。参考链接：https://gcc.gnu.org/onlinedocs/cpp/Macros.html</description>
</item>
</rdf:RDF>