<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/author/1/">
<title>Marco Nie - admin</title>
<link>https://blog.niekun.net/author/1/</link>
<description>admin</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1763.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1758.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1757.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1754.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1753.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1752.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1747.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1720.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1718.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1690.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1763.html">
<title>Failed to parse PID from file /opt/nginx/logs/nginx.pid 处理</title>
<link>https://blog.niekun.net/archives/1763.html</link>
<dc:date>2020-09-22T16:27:00+08:00</dc:date>
<description>今天在使用 journalctl 查看 nginx 日志时看到在每次启动服务后会出现一条错误信息：$ journalctl -u nginx
...
nginx.service: Failed to parse PID from file /opt/nginx/logs/nginx.pid: Invalid argument
...
查找了下原因，可能是 nginx 在启动时创建 nginx.pid 文件前 systemd 就在请求这个文件，所以出错了。解决办法就是题前手动创建 systemd 需要的文件：mkdir /etc/systemd/system/nginx.service.d
printf &quot;[Service]\nExecStartPost=/bin/sleep 0.1\n&quot; &gt; /etc/systemd/system/nginx.service.d/override.conf
systemctl daemon-reload以上处理就可以解决问题。参考链接：https://bugs.launchpad.net/ubuntu/+source/nginx/+bug/1581864</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1758.html">
<title>从源码编译安装 python</title>
<link>https://blog.niekun.net/archives/1758.html</link>
<dc:date>2020-09-21T16:35:00+08:00</dc:date>
<description>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最新版是 3.8.5，在这个页面找到地址：https://www.python.org/downloads/release/python-385/下载 tgz 压缩包到本地并解压：cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz环境安装编译需要安装一些依赖：apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
编译python 源码使用标准 GNU 编译系统，详细说明参考：https://blog.niekun.net/archives/883.html将 python 安装到 /opt 目录，先创建文件夹：mkdir /opt/python3.8.5
然后配置 configure：cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \没有错误提示的话就开始编译和安装：make
make install
安装完成后测试执行：/opt/python3.8.5/bin/python3 --version
返回版本信息则安装完成。下面将可执行文件加入系统路径，创建软连接：ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
测试运行：python --version
安装 pip源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。官网：https://pip.pypa.io/en/stable/installing/下载脚本到本地：curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py使用刚才安装的 python 执行脚本：/opt/python3.8.5/bin/python3 get-pip.py
pip 的安装路径是 /opt/python3.8.5/bin/，测试命令：/opt/python3.8.5/bin/pip3 --version
返回版本信息则安装完成。添加软连接到系统路径：ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
测试命令：pip --version
参考链接https://docs.rstudio.com/resources/install-python-source/</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1757.html">
<title>awk 命令的用法</title>
<link>https://blog.niekun.net/archives/1757.html</link>
<dc:date>2020-09-18T16:20:00+08:00</dc:date>
<description>awk 是常用的 Linux 文本操作命令和脚本语言。用来按行提取和处理文本内容，也可以执行简单的逻辑处理。比如我们有一个 txt 文件：ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452执行命令：$ awk '{print $1}' test.txt
ab.c
oh.g
si.d可以看到返回结果为每一行的第一个字符串。默认以空格作为分隔符。$1 为每行第一个字符串，$2 为每行第二个字符串，以此类推。$0 为整个文本。可以同时输出多个内容：$ awk '{print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156内部集成的参数FS 区域分割符awk 默认使用空格来分割字符串，也可以自己定义分割符：$ awk 'FS = &quot;.&quot; {print $1, $2}' test.txt
ab c 123 e
oh g 324 b
si d 156 o这时候，ab 和 c 123 e 分别是一个整体。还有一种写法使用 -F 表示，要写在引号外部：$ awk -F. '{print $1, $2}' test.txt
NF 每行字符串个数用 $NF 来表示每行最后一个串：$ awk '{print $NF}' test.txt
456
756
452用 NF 来判断每行字符串格个数：只输出有 4 个字符串的所在行的内容$ awk 'NF == 4 {print $1, $2}' test.txt
ab.c 123
oh.g 324
si.d 156NR 当前行号NR 记录当前行的行号：$ awk '{print NR}' test.txt
1
2
3$ awk '{print NR, $0}' test.txt
1 ab.c 123 e.rt 456
2 oh.g 324 b.na 756
3 si.d 156 o.ui 452OFS 定义输出串分割符字符串输出是可以自定义分割符号：$ awk 'OFS=&quot;/&quot; {print $1, $2}' test.txt
ab.c/123
oh.g/324
si.d/156BEGIN 和 END 规则BEGIN 规则是在 awk 读取输入文本前执行的指令，END 规则是在 awk 输出完字符串后执行的指令。$ awk 'BEGIN {print &quot;begin process&quot;} {print $0} END {print &quot;end process&quot;}' test.txt
begin process
ab.c 123 e.rt 456
oh.g 324 b.na 756
si.d 156 o.ui 452
end process判断模块可以使用常用的判断来过滤输出结果：设置第4个字符串数字需要大于等于500：$ awk '$4 &gt;=500 {print $0}' test.txt
oh.g 324 b.na 756设置行内必须包含字符串 ab:$ awk '/ab/ {print $0}' test.txt
ab.c 123 e.rt 456设置行开始必须包含字符串 ab:$ awk '/^ab/ {print $0}' test.txt
ab.c 123 e.rt 456awk script 脚本如果命令很复杂，可以建立一个脚本来单独执行。建立文件：test.awk#!/usr/bin/awk -f

BEGIN {
  # set the input and output field separators
  FS=&quot;:&quot;
  OFS=&quot;:&quot;
  # zero the accounts counter
  accounts=0
}
{
  # set field 2 to nothing
  $2=&quot;&quot;
  # print the entire line
  print $0
  # count another account
  accounts++
}
END {
  # print the results
  print accounts &quot; accounts.\n&quot;
}可执行权限：chmod +x test.awk
执行：./test.awk /etc/passwd
windowswindows 下也可以使用 awk，下载安装 Gawk 即可。官网：http://gnuwin32.sourceforge.net/packages/gawk.htm下载对应安装包，安装后将 awk 可执行文件的路径加入系统 PATH 即可使用，参考：https://blog.niekun.net/archives/413.html参考链接https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/http://linuxcommand.org/lc3_adv_awk.php</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1754.html">
<title>${1%str} 在 shell 脚本的用法</title>
<link>https://blog.niekun.net/archives/1754.html</link>
<dc:date>2020-09-18T15:25:00+08:00</dc:date>
<description>执行 shell 脚本时经常会有传入参数，如：./test.sh abcdef abc.bbb
以上的命令使用了两个传入参数，abcdef,abc.bbb。在脚本里使用时，$1 就表示第一个参数，$2 就表示第二个参数:var1 = $1
var2 = $2在脚本中有一种用法，如：${1%def}jjj。他的意思就是将 $1 最后的字符 def 替换为 jjj：newstr1 = ${1%def}jjjnewstr1 的值就是 abcjjj。newstr2 = ${2%.bbb}.cccnewstr2 的值就是 abc.ccc。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1753.html">
<title>使用 subprocess.check_output 执行cmd命令并返回结果到字符串</title>
<link>https://blog.niekun.net/archives/1753.html</link>
<dc:date>2020-09-18T15:13:51+08:00</dc:date>
<description>语法：subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)
执行cmd命令并返回结果到字符串。用法：import subprocess

output = check_output([&quot;cat&quot;, &quot;/etc/hostname&quot;]).strip()
print(output)以上脚本会执行 cat /etc/hostname 命令然后将结果赋值给 output 变量。strip() 可以将 string 的前后空格去掉。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1752.html">
<title>FFmpeg 简单用法</title>
<link>https://blog.niekun.net/archives/1752.html</link>
<dc:date>2020-09-18T15:03:12+08:00</dc:date>
<description>FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。官方网站：https://www.ffmpeg.org/安装最简单的方法就是用包管理工具如：apt 安装：apt update
apt install ffmpeg
或者也可以从源码安装，可以参考我之前的教程：https://blog.niekun.net/archives/891.html常用指令查看 ffmpeg 版本：ffmpeg -version
查看支持的编码格式：如 h.264, h.265ffmpeg -codecs
查看支持的容器：如 mp4, mp3, mkvffmpeg -formats
查看已安装的编码器：如 libx264, libx265, libvpx, aacffmpeg -encoders
使用格式FFmpeg 的命令行参数非常多，可以分成五个部分。ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下：全局参数
输入文件参数
输入文件
输出文件参数
输出文件参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]下面是一个例子:ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。一般可以省略输入文件参数。常用命令参数-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。常规使用方法查看元数据信息，如时长，比特率等：ffmpeg -i test.mp4
输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：ffmpeg -i test.mp4 -hide_banner
转码，如 avi to h.264:ffmpeg -i test.avi -c:v libx264 test.mp4
转换容器：ffmpeg -i test.mp4 -c copy test.webm转换容器不需要转码，所以直接 copy 即可。转换码率，转换成固定码率：ffmpeg -i test.mp4 -b:v 500k test_out.mp4
转换码率，转换成一个码率范围：ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
改变分辨率：转换成 480pffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4视频中提取音频：ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg%3d 在 shell 里表示至少输出3个字符空间的数字：% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;如果只需要截一张图，可以指定只截取一帧。$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是1到5之间（1 为质量最高）。裁剪:裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]下面是实际的例子。# 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。高级用法压缩视频内容到指定容量大小使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。bash脚本：#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;使用方法：压缩视频到 50 MB 大小./script.sh test.mp4 50
切割视频到指定时长的多个视频使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。python 脚本：#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()使用方法：将视频切割为单个视频100秒./split.py -f test.mp4 -s 100
ffprobe 使用ffprobe 可以用来得到视频信息。视频时长：秒ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
视频码率：bitffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
参考链接http://www.ruanyifeng.com/blog/2020/01/ffmpeg.htmlhttps://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-sizehttps://github.com/c0decracker/video-splitterhttps://trac.ffmpeg.org/wiki/FFprobeTips</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1747.html">
<title>Linux 系统时间设置问题</title>
<link>https://blog.niekun.net/archives/1747.html</link>
<dc:date>2020-09-17T10:47:00+08:00</dc:date>
<description>昨天重装了 vps 系统，在设置 crontab 定时任务时发现并没有在指定的时间执行脚本。于是就进行排查问题。测试在 /etc/crontab 添加一条测试任务:30  10    *  *  * root python -V &gt; /root/test.log
在 10：30 并没有看到 test.log 文件生成。通过 systemctl status cron 查看信息：Sep 17 10:21:01 niekun-bandwagon CRON[946]: pam_unix(cron:session): session clos
Sep 17 10:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)在 10：29 crontab 脚本已经重新加载过了，但是并没有执行任务。通过命令 cat /var/log/syslog | grep cron 查看系统日志：Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (pidfile fd = 3)
Sep 16 21:46:35 niekun-bandwagon cron[451]: (CRON) INFO (Running @reboot jobs)
Sep 16 22:29:01 niekun-bandwagon cron[451]: (*system*) RELOAD (/etc/crontab)发现日志的时间比我当前时间晚了 12 个小时，会不会就是系统日期问题导致脚本没有达到设定的时间？在按装新系统的后，使用 date 命令查看当前系统时间，发现时间是 UTC 时间，我通过 tzselect 命令设置了时区：[root@db-server ~]# tzselect 
Please identify a location so that time zone rules can be set correctly.
Please select a continent or ocean.
 1) Africa
 2) Americas
 3) Antarctica
 4) Arctic Ocean
 5) Asia
 6) Atlantic Ocean
 7) Australia
 8) Europe
 9) Indian Ocean
10) Pacific Ocean
11) none - I want to specify the time zone using the Posix TZ format.
#? 5
Please select a country.
 1) Afghanistan           18) Israel                35) Palestine
 2) Armenia               19) Japan                 36) Philippines
 3) Azerbaijan            20) Jordan                37) Qatar
 4) Bahrain               21) Kazakhstan            38) Russia
 5) Bangladesh            22) Korea (North)         39) Saudi Arabia
 6) Bhutan                23) Korea (South)         40) Singapore
 7) Brunei                24) Kuwait                41) Sri Lanka
 8) Cambodia              25) Kyrgyzstan            42) Syria
 9) China                 26) Laos                  43) Taiwan
10) Cyprus                27) Lebanon               44) Tajikistan
11) East Timor            28) Macau                 45) Thailand
12) Georgia               29) Malaysia              46) Turkmenistan
13) Hong Kong             30) Mongolia              47) United Arab Emirates
14) India                 31) Myanmar (Burma)       48) Uzbekistan
15) Indonesia             32) Nepal                 49) Vietnam
16) Iran                  33) Oman                  50) Yemen
17) Iraq                  34) Pakistan
#? 9
Please select one of the following time zone regions.
1) east China - Beijing, Guangdong, Shanghai, etc.
2) Heilongjiang (except Mohe), Jilin
3) central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.
4) most of Tibet &amp; Xinjiang
5) west Tibet &amp; Xinjiang
#? 1
 
The following information has been given:
 
        China
        east China - Beijing, Guangdong, Shanghai, etc.
 
Therefore TZ='Asia/Shanghai' will be used.
Local time is now:      Sun Jan 11 23:31:51 CST 2015.
Universal Time is now:  Sun Jan 11 15:31:51 UTC 2015.
Is the above information OK?
1) Yes
2) No
#? yes
Please enter 1 for Yes, or 2 for No.
#? 1
 
You can make this change permanent for yourself by appending the line
        TZ='Asia/Shanghai'; export TZ
to the file '.profile' in your home directory; then log out and log in again.
 
Here is that TZ value again, this time on standard output so that you
can use the /usr/bin/tzselect command in shell scripts:
Asia/Shanghai将 TZ='Asia/Shanghai'; export TZ 写入 ~/.profile，并刷新文件：source .bash_profile测试当前系统时间：root@niekun-bandwagon:~# date
Thu Sep 17 10:44:00 CST 2020
但是系统日志记录的时间还是不对，这就可能还是时区不对，手动复制亚洲时区文件到目录：cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
更新 rsyslog 进程：systemctl restart rsyslog
再次测试发现系统日志时间对了，crontab 脚本也可以正确执行。也可以使用 timedatectl 命令设置时区：# 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone Asia/Shanghai</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1720.html">
<title>自由填充 Pattern in Photoshop</title>
<link>https://blog.niekun.net/archives/1720.html</link>
<dc:date>2020-08-18T12:09:00+08:00</dc:date>
<description>对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。我们从如何定一个 pattern 开始，下面是一张 1 美元图片：使用 object selection tool 快速将主体选出来：选区边沿如果有多余的或者缺失的部分，通过 按住 shift 和 alt 键来增加/减去选区：点击添加图层蒙版，边沿如果需要调整，可以使用画笔工具来进一步修整蒙版。如果蒙版边沿有锯齿，可以双击蒙版打开属性框，调整 smooth 和 contract 来优化蒙版：使用选区工具框出一个矩形框包含我们的主体：选择 edit - define pattern：定义一个名称，点击 ok：新建图层，快捷键 shift backspace/shift delete 调出填充框：content 选择 pattern：custom pattern 里选中我们刚才新建的模型：script 前打勾，然后右侧菜单里选择 random fill：点击 ok 后进入调整菜单，首先将 下面的 color randomness 设为 0 避免图形的染色改变，brightness randomness 设置为 0.02 左右使亮度轻微可以随机改变，形成层次感：将 density 设置为最大 10，将 minimum/maximum scale factor 设置为 1，这样 pattern 会以 1:1 比例显示：将 rotate pattern 打勾，这样模型会随机旋转：设置完成后点击 ok，可以看到效果：还可以做一些优化来使层叠效果更加真实，过程就是降低 density 和 scale，添加图层阴影效果。新建图层，使用上面的方法填充 pattern，在设置中将 density 设置为 9，scale 设置为 0.25：确认后可以看到效果，单个图形变小，填充密度变小：我们给图层添加阴影效果，双击图层打开 layer style，下方点击添加阴影：再次新建图层，使用上面图层的填充设置填充 pattern，可以将空缺的部分进一步补充完整：按住 alt 键拖拽刚才的阴影特效到新图层，可以快速复制效果：可以看到还是有空白的区域没有填充完整，继续重复上面的步骤，建立多个图层，直到完全充满整个区域为止，最终效果如下：以上就是使用 script 来实现 pattern 自由填充的过程。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1718.html">
<title>argparse and struct in python</title>
<link>https://blog.niekun.net/archives/1718.html</link>
<dc:date>2020-08-14T11:20:39+08:00</dc:date>
<description>https://docs.python.org/3/library/argparse.htmlhttps://docs.python.org/3/library/struct.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1690.html">
<title>眼睛进阶处理 in Photoshop</title>
<link>https://blog.niekun.net/archives/1690.html</link>
<dc:date>2020-08-14T11:16:27+08:00</dc:date>
<description>在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。下图是我们的原图：放大眼睛细节：原图已经很好了，很清晰。下面我们进行调整。强化亮部细节需要提亮的部分是光源点的对面，再此图中就是眼睛光斑的下方，新建图层，画笔工具画圆：擦除多余部分，笔刷选择软笔刷，可以先降低不透明度来看到背景：高斯模糊使过度自然：混合模式改为 overlay 实现提亮：blend option 去掉影响阴影部分：如果想要加强效果可以再次复制图层，调整不透明度。增加高光点新建曲线图层，拉高曲线：ctrl I 反转图层蒙版，白色画笔工具软笔刷在瞳孔下方点击一下：可以看到效果太强了，调低不透明度到合适：增加明暗细节新建曲线图层，提高曲线，反转图层蒙版：白色画笔工具使用软笔刷沿着瞳孔在亮部区域画出射线，这一步注意如果有数位板来画的话会更好：降低不透明度到合适：下面增加暗部细节，再次新建曲线，然后降低曲线，反转蒙版：同样的方法画出射线：降低不透明度：眼白清理首先清理红血丝，新建图层，选择修复画笔工具混合模式设置为 screen，这样可以只处理暗部血丝：按 alt 键采样眼白，涂抹血丝区域：然后进行 dogding and burning 明暗调节，首先建立 soild color 观察图层，混合模式改为 color 来只显示亮度情况：新建图层，混合模式改为 soft light，选择笔刷工具软笔刷流量改为 1，快捷键 D 恢复颜色为黑/白，根据实际用白色笔刷涂抹暗部，黑色笔刷涂抹过亮部分：然后修复亮度调整后的颜色变化，新建图层，混合模式改为 color，快捷键 I 拾取眼白正常部分的颜色，然后在新图层上涂抹出需要修复的区域：复制效果将亮部细节处理/高光点/明暗细节处理部分建立分组然后复制一份，安住 ctrl 拖动分组到另一只眼睛部分，可以配合蒙版清理多余部分：可以使用同样的方法清理另一只眼睛的眼白部分最终效果如下：</description>
</item>
</rdf:RDF>