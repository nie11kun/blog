<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/author/1/">
<title>Marco Nie - admin</title>
<link>https://blog.niekun.net/author/1/</link>
<description>admin</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2011.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2002.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1997.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1996.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1992.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1990.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1985.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1979.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1977.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1973.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2011.html">
<title>JavaScript 入门教程之八 -- ES6</title>
<link>https://blog.niekun.net/archives/2011.html</link>
<dc:date>2020-12-21T22:13:20+08:00</dc:date>
<description>ECMAScript (ES) 就是标准 JavaScript 的脚本语言规范。它的第 6 个版本，开始被叫做 ECMAScript 6 (ES6) 然后改名为 ECMAScript 2015，为编写更加复杂的程序添加了很重要的新语法。包括了：classes and modules, iterators and for/of loops, generators, arrow functions, binary data, typed arrays, collections (maps, sets and weak maps), promises, number and math enhancements, reflection, and proxies。ES6 是 ES5 的超集，ES6 现在非常流行，原因就是它引入了新的约定和 OOP 的概念，如：classes。下面我们介绍一些 ES6 中最核心的一些特性。需要注意的是只有浏览器支持 ES6 的情况下才能够执行 ES6 指令，否则会报错。var & letES6 中有三种方式定义变量：var a = 10;
const b = &quot;test&quot;;
let c = true;使用那种类型来申明变量取决于变量需要使用的 scope 范围。scope 是所有编程语言的基本概念，它定义了变量的可见范围。var 关键词定义的变量是全局有效的，或者在整个 function 内有效，而与具体在那个代码块内定义它无关。let 可以定义一个变量在某个特定 scope 内有效，如一个代码块或一个表达式内。例如：if (true) {
    let age = 5;
}
alert(age);以上代码会报错 ES6.html:21 Uncaught ReferenceError: age is not defined，可以打开浏览器调试窗口查看：这种情况下，name 变量只能在 if 表达式内被使用，因为它使用 let 申明。测试 var 和 let 的区别，我们做下面的示例：&lt;script&gt;
    function varTest() {
        var x = 1;
        if (true) {
            var x = 2;
            console.log(x); // 2
        }
        console.log(x); // 2
    }

    function letTest() {
        let x = 3;
        if (true) {
            let x = 4;
            console.log(x); // 4
        }
        console.log(x); // 3
    }
    varTest();
    letTest();
&lt;/script&gt;输出结果为：2
2
4
3varTest() 中定义的两个 x 实际上是同一个变量。letTest() 中 if 表达式中的 x 和外围的 x 不是一个变量。let 最常使用的地方就是 for 循环中：for (let index = 0; index &lt; 3; index++) {
}index 只在 for 循环内可以被使用。const 变量和 let 变量一样都在 scope 内有效。不同点是 const 变量的值是不可变的，不能够被重新分配数据。以下指令会报错：const a = 1;
a = 2;Template LiteralsTemplate literals 文字模板是将变量输出到字符串的一种方式，ES6 之前需要打断字符串：var name = &quot;marco&quot;;
var msg = &quot;hello&quot; + name + &quot;!&quot;;
console.log(msg);ES6 引入了一种新的方式来处理：var name = &quot;marco&quot;;
var msg = `hello ${name}!`;
console.log(msg);template literals 文字模板使用 ` 符号来代替引号 &quot; 或 '。${expression} 是一个占位符，可以包含任何表达式，将评估的结果返回后嵌入 template literals 文字模板中。例如：var a = 1;
var b = 2;
var msg = `sum is ${a + b}`;
console.log(msg);Loops and Functions in ES6在 JavaScript 中常用 for 循环来 iterate list 中的元素：let array = [1, 2, 3];
for (let index = 0; index &lt; array.length; index++) {
    const element = array[index];
}for...in 循环可以用来 iterating 一个含有一定数量的 properties 的 object：let obj = {
    a: 1,
    b: 2,
    c: 3
};
for (let key in obj) {
    console.log(obj[key]);
}log 输出为：1
2
3注意 for...in loop 不能 iterate 一个 array 数组。虽然数组也是一个 object，但他的 index 索引是基于 number 数字的。基于 JavaScript engine，for...in 循环 iterate 某个 list 的元素的顺序是随机的，而且 iterating 索引是一个 string 字符串的，而不是 number 数字，所以当你测试对这个索引进行某些 math 数学加法运算，会发现执行的是对字符串的串联而不是数字运算。ES6 中引入了一个 for...of loop 能够创建一个对 iterable object 进行 iterating 的循环，数组就是一种 iterable object，而含有 name: value 结构属性的 object 不属于。例如：let array = [1, 2, 3];
for (const iterator of array) {
    console.log(iterator);
}在每个循环中，iterator 变量都会赋值为 object 内的坐标元素。for...of loop 适用于其他 iterable objects 例如 string 字符串：for (const iterator of &quot;object&quot;) {
    console.log(iterator);
}输出结果为：o
b
j
e
c
tfor...of 同样适用于 ES6 新引入的一些集合：Map, Set, WeakMap, and WeakSet，后面我们会做介绍。Functions in ECMAScript 6ES6 之前定一个 function 的方法如下：function add(a, b) {
    let sum = a + b;
    console.log(sum);
}ES6 介绍了一种新的语法，效果和上面的示例完全一样：const add = (a, b) =&gt; {
    let sum = a + b;
    console.log(sum);
}这种写法叫做 arrow function，对于只有一个参数的简单 function 非常好用，可以省略关键词 function 和 return 甚至是大括号{}和小括号()：const greet = x =&gt; &quot;welcome&quot; + x;以上代码定义了一个 greet function，有一个参数和一个 string 返回值。如果 function 没有参数，需要加一个小括号()：const x = () =&gt; alert(&quot;hi&quot;);这种语法对于 inline function 很有用。假如有一个数组，需要对其每一个元素都执行某个 function，使用 array 的 forEach method 来为每个元素调用 function，传统写法如下：var arr = [1, 2 ,3 ];
arr.forEach(function(el) {
    console.log(el * 2);
});在 ES6 中，以上功能可以重写为：arr.forEach(el =&gt; {
    console.log(el * 2);
});代码是不是简化很多呢？Default Parameters in ES6之前的 function 中定义参数的默认值可以这样：function test(a, b = 2, c = 3) {
    console.log(a + b + c);
}使用 arrow function 可以这样定义：const test = (a, b = 2, c = 3) =&gt; {
    console.log(a + b + c);
}ES6 objectsJavaScript 中 object 内可以定义多个 variable 变量，叫做 properties。properties 定义了 function 的叫做 method，例如：var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 62,
    test: function() {
        alert(&quot;method&quot;);
    }
};test 就是一个 method，ES6 引入了一种简化的语法和 properties 名称来使定义更加方便和易懂。新的语法定义 method 不需要冒号: 和 functon 关键词：let person = {
    test() {
        alert(&quot;hi&quot;);
    }
};
person.test();当使用已知变量定义 properties 且定义名称和变量名称一样时，可以简写语法如下：let height = 160;
let weight = 60;

let man = {
    height,
    weight
};以上定义中 man object 就定义了两个 properties：height，weight，且赋值为外部调用变量的值。当在 object 中定义了相同名称的 properties，最后一个定义的 property 将会覆盖前面的：let x = {a: 2, a: 3, a: 4};
console.log(x.a);输出结果为：4在 ES5 中如果使用了 restrict 限制模式，定义重复名称的 properties 将会报语法错误，ES6 中取消了这个限制。Computed Property Names 预定义属性名ES6 中，可以使用 computed property name 预定义属性名。通过方括号[] 我们可以在 properties name 中使用一个表达式，可以进行包括串联字符串或数学运算等指令。当需要创建一个基于实际用户数据(id, email等)的特定 object 时非常有用。示例 1：let name = &quot;marco&quot;;
let id = &quot;123&quot;;
let tel = &quot;1300000&quot;;

let user = {
    [name]: &quot;tom&quot;,
    [`user_${id}`]: `${tel}`
};
console.log(user.user_123);

//output:
//1300000示例 2：let i = 0;

let x = {
    ['foo' + ++i]: i,
    ['foo' + ++i]: i
}
console.log(x.foo1);
console.log(x.foo2);

//output:
//1
//2示例 3：var par = 'size';

var config = {
    [par]: 1,
    ['mobile' + par.charAt(0).toUpperCase() + par.slice(1)]: 2
}
console.log(config.mobileSize);

//output:
//2当需要创建基于变量的自定义 object 时，这种方法很有效。ES6 object 新增了一个新的 method：assign() 可以用来将多个 source 源结合起来创建一个新 object。assign() 也可以用来创建一个已知 object 的副本。请看下面示例：let user1 = {
    name: 'marco',
    age: 20,
    sex: 'male'
}

let user2 = {
    name: 'jim',
    age: 18,
    tel: '12345'
}

let newUser = Object.assign({}, user1, user2);
console.log(newUser.name);
console.log(newUser.tel);

//output:
//jim
//12345Object.assign() 的第一个参数表示需要添加新 properties 的目标 object，第一个参数后的所有参数都会被作为 source 源，源参数的数量没有限制，可以任意多个。但是源参数的顺序很重要，因为前面的源 properties 将会被后面的有着同样属性 name 的源 properties 覆盖。例如上面示例中，user1 的 name 和 age properties 会被 user2 的同样名称的 properties 覆盖。以上示例，我们使用{} 作为目标 object，使用两个 object 作为源。下面我们介绍如何使用 assign() 创建一个 object 复制，新 object 不和原 object 产生关联。在下面的示例中，我们使用简单的 assignment = 来创建新 object，但是这种方式会在 object 和原 object 间产生 reference 关联。对新 object 的修改会影响到原 object：let person = {
    name: 'marco',
    age: 20
};

let newPerson = person;
newPerson.name = &quot;tom&quot;;
console.log(newPerson.name);
console.log(person.name);

//output:
//tom
//tom可以看到 修改 newPerson 的 name 属性也会同时影响到 person 的 name 属性。为了避免这种情况，可以使用 Object.assign() 来新建 object：let person = {
    name: 'marco',
    age: 20
};

let newPerson = Object.assign({}, person);
newPerson.name = 'tom';
console.log(newPerson.name);
console.log(person.name);

//output:
//tom
//marco我们也可以在 assign() 中直接给 properties 赋值：let person = {
    name: 'marco',
    age: 20
};

let newPerson = Object.assign({}, person, {name: 'john'});
console.log(newPerson.name);
console.log(person.name);

//output:
//john
//marco以上就是 ES6 中 object 的新语法介绍。Array Destructuring in ES6 数组拆解destructuring assignment 拆解赋值语法能够实现将一个 array 的 values 拆分，或者将一个 object 的 properties 拆解为独立的个体。Destructuring arrayES6中引入的快捷语法来拆解 array 数组，下面的示例介绍如何将数组元素拆解为独立个体：let arr = [1, 2, 3];
let [a, b, c] = arr;

console.log(a);
console.log(b);
console.log(c);也可以拆分一个 function 返回的数组：let a = () =&gt; {
    return [1, 2, 3]
};

let [a, , c] = a();注意上面示例中，第二个参数留空了，表示 a 赋值数组第一个元素，c 赋值数组第三个元素。以上 function 使用了 ES6 的简写语法，参考上一节的介绍。destructuring 拆分语法同样能够简化赋值和交换数据：let a, b, c = 3, d = 4;

[a, b = 2] = [1]; //a=1, b=2
[c, d] = [d, c]; //c=d, d=c

console.log(a);
console.log(b);
console.log(c);
console.log(d);

//output:
//1
//2
//4
//3以上的语法再一些使用场景中能够很大简化代码量，使程序更加简洁。Destructuring object类似于拆解数组，也可以拆解 object 的 properties 为单独个体：let obj = {h: 1, s: 2};
let {h, s} = obj;

console.log(h);
console.log(s);注意定义的新变量名需要和 object property 名称一致，否则新变量的值为：undefined。也可以不声明新变量而直接赋值，但有语法要求。需要加小括号()：let obj = {h: 1, s: 2};
let h, s;
({h, s} = obj);拆解时可以给 object 的 properties 定义新的名称，使用: name: newname 形式：let obj = {h: 1, s: 2};
let {h: a, s: b} = obj;

console.log(a);
console.log(b);这时候如果执行：console.log(h); 会报错。最后，我们可以给新变量设置初值，如果 object 中没有定义这个属性，新变量就会使用初值：let user = {name: &quot;marco&quot;, id: 123};
let {name = &quot;tom&quot;, age = 20} = user;
console.log(name);
console.log(age);

//output:
//marco
//20以上示例中，user object 含有 name 属性，则赋值为对应数据，没有 age 属性则会使用默认值作为新变量的数据。ES6 Rest Parameters在 ES6 之前，如果调用 function 时传入的参数数量是变化的，我们可以使用 arguments array object 来访问这些传入数据。下面示例中，我们创建一个 function 来检查传入参数值是否都在一个给定数组内：function containsAll(arr) {
    for (let index = 1; index &lt; arguments.length; index++) {
        let num = arguments[index];
        if (arr.indexOf(num) == -1) {
            return false;
        }
    }
    return true;
}

let x = [2, 4, 6, 8];
console.log(containsAll(x, 2, 4));
console.log(containsAll(x, 3, 4, 6));

//output:
//true
//false可以看到 function 预定义的参数只有一个，我们在调用时传入了大于 1 个的参数，这时候在 function 内就需要使用 arguments 数组来索引传入数据。arguments[0] 代表第一个参数，也就是预定义的 arr 参数，其他数据在 arguments 数组中往后依次排列。我们使用了 array 的 indexOf method 来获取某个数据在数组中的 position 位置，如果数组中不存在这个数据，则返回 -1，这里我们使用了 === identity operator 来确保数据类型和数值都要匹配上。我们可以给 function 传入任意数量的数据，然后使用 arguments 数组来访问它们。ES6 中通过使用 rest parameter 剩余参数创建了一种更加简洁的语法，来访问变化的传入参数数据：function containsAll(arr, ...nums) {
    for (const iterator of nums) {
        if (arr.indexOf(iterator) == -1) {
            return false;
        }
    }
    return true;
}...nums 叫做 rest parameter 剩余参数，它包含了所有 extra 附加的传入参数，... 叫做 Spread operator 延伸符。只有后面的传入参数才可能被标记为 rest parameter，如果调用时没有 extra 附加的传入参数，则 rest parameter 的值将会是一个空数组[]，而不是 undefined。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2002.html">
<title>JavaScript 入门教程之七 -- DOM</title>
<link>https://blog.niekun.net/archives/2002.html</link>
<dc:date>2020-12-19T14:10:00+08:00</dc:date>
<description>当你打开一个网页，html 页面会被加载和渲染到屏幕上。为了完成这个过程，浏览器会建立这个页面的 Document Object Model 模型。也就是一个指向页面逻辑架构的 object。一个页面的 DOM 可以被表示为一些嵌套的 boxes：JavaScript 能够用来操作 DOM，动态的添加、删除、修改其中的元素。DOM treeDOM 将一个 document 表达为一个 tree structure 树形结构， html 元素称为这个 tree 上的相关联的 nodes 节点。整个 tree 上的 nodes 之间都是互相有关联的。nodes 可以有 child node 子节点。在同一个 tree level 层级的 nodes 叫做 siblings 兄弟关系。想象下面的一个 document structure：以上示例中的关系结构是：&lt;html&gt; 有两个 children：&lt;head&gt;, &lt;body&gt;;&lt;head&gt; 有一个 child：&lt;title&gt;，有一个 parent：&lt;html&gt;;&lt;title&gt; 有一个 parent：&lt;head&gt;， 没有 children;&lt;body&gt; 有两个 children：&lt;h1&gt; and &lt;a&gt;，有一个 parent：&lt;html&gt;;理解 HTML document 的元素间的关系很重要，这样我们就可以使用 JavaScript 来操纵这些元素了。document object 在 JavaScript 中被预定义，可以用来访问 DOM 中的所有元素。换句话说，document object 是页面中所有元素的拥有者。所以想要访问 html 页面中的元素，首先需要访问 document object。看下面的示例：document.body.innerHTML = &quot;Some text&quot;;
body 是 DOM 中的元素，通过 document 来访问到它，然后通过其 innerHTML property 修改其内容。Selecting Elements所有的元素都是 object，都有 properties 和 method。document 有能够让我们选择其内部元素的 method，常用的有三种方法：//finds element by id
document.getElementById(id) 

//finds elements by class name
document.getElementsByClassName(name) 

//finds elements by tag name
document.getElementsByTagName(name)下面的示例，我们使用 getElementById method 来选中一个元素，并修改其内容：var elem = document.getElementById(&quot;demo&quot;);
elem.innerHTML = &quot;hello world&quot;;注意以上示例中我们需要 html 有一个元素设置 id=&quot;demo&quot;，如：&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
&lt;/body&gt;getElementsByClassName() method 会返回一个特定 calss name 的集合。例如，我们有三个含有 class=&quot;demo&quot; 的元素：&lt;body&gt;
    &lt;div class=&quot;demo&quot;&gt;test1&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test2&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test3&lt;/div&gt;
&lt;/body&gt;首先选中全部 3 个元素为一个数组，然后修改第一个元素内容：&lt;script&gt;
    var arr = document.getElementsByClassName(&quot;demo&quot;);
    arr[0].innerHTML = &quot;hi&quot;;
&lt;/script&gt;类似的方式， getElementsByTagName method 返回一个特定 tag 的集合。下面的示例中，将选中所有 paragraph 元素然后修改他们的内容：&lt;body&gt;
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
    &lt;p&gt;3&lt;/p&gt;
&lt;/body&gt;

&lt;script&gt;
    var arr = document.getElementsByTagName(&quot;p&quot;);
    for (var i = 0; i &lt; arr.length; i++) {
        arr[i].innerHTML = &quot;hi there&quot;;
    }
&lt;/script&gt;每个 DOM 中的元素都有 properties 和 method 来提供给我们关于其在 DOM 中的相互关系的信息：element.childNodes 返回其子元素的数组element.firstChild 返回其第一个子元素element.lastChild 返回其最后一个子元素element.hasChildNodes 当其有子元素时返回 true，否则返回 falseelement.nextSibling 返回下一个处于同一 tree level 节点的元素element.previousSibling 返回上一个处于同一 tree level 节点的元素element.parentNode 返回其 parent 节点的元素Changing Attributes当选中了想要的元素后，就可以修改其相关属性了。我们前面使用过通过 innerHTML property 修改了元素的 text 内容。同样的方法，我们可以修改它的属性值，例如修改一个 image 的 src 属性：&lt;/body&gt;
    &lt;img id=&quot;img1&quot; src=&quot;1.jpg&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;img1&quot;);
    el.src = &quot;2.jpg&quot;;
&lt;/script&gt;通常情况下，元素中所有的属性都可以通过 JavaScript 修改。html 元素的 style 也可以通过 JavaScript 修改，所有的 style 属性可以通过 style object 来访问，例如：&lt;body&gt;
    &lt;div id=&quot;demo2&quot; style=&quot;width: 200px;&quot;&gt;some text&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var x = document.getElementById(&quot;demo2&quot;);
    x.style.color = '#6600FF';
    x.style.width = '100px';
&lt;/script&gt;所有的 css properties 都可以通过 JavaScript 修改。但是要注意，JavaScript 中相关 property 时，名称中不能够使用 dash- 横杠，如果 css 属性名称有横杠，需要转换成 camelCase versions，也就是相关首字母转换成大写。例如：js 在调用 background-color property 时需要写成 backgroundColor。Adding & Removing Elements 创建和删除元素Adding Elements使用下面的 method 来创建节点 node：element.cloneNode() clone 一个节点并将其返回document.createElement(element) 创建一个新元素的节点document.createTextNode(text) 创建一个新的 text 节点下面简单说下元素和节点：&lt;div&gt;
    test1
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;以上示例中，div 就是一个 element 元素，test1 就是这个元素下的 text node 节点，p 就是 div 元素下的另一个子元素节点。例如：var node = document.createTextNode(&quot;Some new text&quot;);
将会创建一个 text 节点，但是当前它并不会出现在页面上，因为还没有定义它属于那个元素。element.appendChild(newNode) method 来给元素添加一个新的子节点，并放在最后。element.insertBefore(node1, node2) method 将添加的新直接点 node1 放在已有的子节点 node2 之前。下面做一个示例：&lt;body&gt;
    &lt;div id=&quot;demo3&quot;&gt;test&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var p = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;some text&quot;);
    p.appendChild(node);

    var el = document.getElementById(&quot;demo3&quot;);
    el.appendChild(p);
&lt;/script&gt;以上出现的执行过程为：创建一个元素 p 和 text node node，然后将 node 作为 p 的子元素，最后将 p 添加到 el 中。Removing Elements想要删除一个元素，首先需要选中其 parent 元素，然后使用 removeChild(node) method 来删除相关子元素，例如：&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;some text one&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;some text two&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.removeChild(child);
&lt;/script&gt;也可以使用 parentNode property 来获取某个子元素的 parent 元素，然后执行相关操作：child.parentElement.removeChild(child);Replacing Elements使用 element.replaceChild(newNode, oldNode) method 来替换一个元素。例如：&lt;script&gt;
    var newEl = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;this is a new node&quot;);
    newEl.appendChild(node);

    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.replaceChild(newEl, child);
&lt;/script&gt;Animations 动态效果现在我们已经知道如何选择和修改元素，下面我们可以创建一个简单的动画效果。首先建立一个 html 页面，包含一个 box 元素，后期通过 js 来让它动起来：&lt;style&gt;
    #container {
        width: 200px;
        height: 200px;
        background: green;
        position: relative;
    }
    #box {
        width: 50px;
        height: 50px;
        background: red;
        position: absolute;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;box 元素是 container 的子元素，注意两个的 position attribute，container 是 relative，box 是 absolute，我们将创建一个让 box 从左移动到右的动画。为了实现动态效果，我们需要在一个很小的时间间隔下修改元素的相关 properties，可以使用 setInterval() method：&lt;script&gt;
    var pos = 0;
    var box = document.getElementById(&quot;box&quot;);

    function move() {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }

    setInterval(move, 10);
&lt;/script&gt;以上指令控制 box 的 left property 每 10 毫秒移动 1 位。但是以上的代码会让 box 元素一直向右移动，我们可以加一个简单的判断来检测 box 到达 container 边沿，然后使用  clearInterval() method 停止定时器：function move() {
    if (pos &gt;= 150) {
        clearInterval();
    } else {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }
}当 left 属性达到 150 时，由于 box 宽度为 50，container 宽度为 200，这时候 box 已经达到边沿。Handling Events 事件处理我们可以实现当一个 event 事件发生时执行特定 JavaScript 代码，如点击某个元素，移动鼠标，提交一个表格等。当一个 event 发生在目标元素上时，一个 handling function 会被执行。常用的 html events 包括：event 事件可以作为一个属性添加在元素内，如： &lt;p onclick=&quot;someFunc()&quot;&gt;some text&lt;/p&gt;
下面我们创建一个事件，当用户点击元素时弹出一个窗口：&lt;body&gt;
    &lt;button onclick=&quot;show()&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    function show() {
        alert(&quot;hello&quot;);
    }
&lt;/script&gt;event handling 事件响应也可以在 js 中直接分配给 elements：&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;demo&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;demo&quot;);
    el.onclick = function () {
        el.innerHTML = &quot;clicked&quot;;
    }
&lt;/script&gt;onload 和 onunload events 会在用户进入和离开页面时被触发。可以用来实现当页面加载完成后执行的动作：&lt;body onload=&quot;doSomething()&quot;&gt;
类似的 window.onload event 可以在整个页面加载后执行动作：window.onload = function () {
    //do someting
}onchange event 在文本框中很有用，当文本框的 text 内容被修改同时元素不在 focus 状态时 onchange event 响应。例如：&lt;body&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; onchange=&quot;changed()&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    function changed() {
        var el = document.getElementById(&quot;name&quot;);
        el.value = el.value.toUpperCase();
    }
&lt;/script&gt;以上示例中，当我们在文本框输入字符，然后将光标移动到其他地方或者敲回车键后，文本框字符会自动转换为大写。理解 events 很重要，因为它是实现动态页面的核心。Event ListenersaddEventListener() method 可以给一个元素添加 event handler 而不会覆盖其已有的 event handlers。可以给一个元素添加多个 event handler 甚至是统一类型的 handler，比如可以添加两个 click handler。语法如下：element.addEventListener(event, function, useCapture);
第一个参数是 event 类型，如："click" 或 "mousedown"，需要用引号包围第二个参数是事件发生时调用的 function 名称，不需要写小括号()第三个参数时一个 Boolean 数值，定义是使用 event bubbling 还是 event capturing，这个参数是可选项，后续会介绍注意这里 event 名称不需要 on 前缀，使用 click 代替 onclick。element.addEventListener(&quot;click&quot;, myFunction);
element.addEventListener(&quot;mouseover&quot;, myFunction);

function myFunction() {
  alert(&quot;Hello World!&quot;);
}以上代码给元素添加了两个 event handler，我们可以删除其中一个：element.removeEventListener(&quot;mouseover&quot;, myFunction);
下面的示例中，我们给 button 创建一个 event handler，然后再触发事件后删除这个 event handler：&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    var btn = document.getElementById(&quot;btn&quot;);
    btn.addEventListener(&quot;click&quot;, myFunction);

    function myFunction() {
        alert(Math.random());
        btn.removeEventListener(&quot;click&quot;, myFunction);
    }
&lt;/script&gt;当第一次点击 button 后会弹出窗口，然后删除 click event，后面点击会没有反应。IE8 及以下版本的浏览器不支持 addEventListener() 和 removeEventListener() methods，可以使用 document.attachEvent() 来添加 event handler。Event Propagation 事件传播在 DOM 中有两种方式进行 event propagation 事件传播：bubbling 和 capturing。当事件触发时，可以定义元素顺序。例如有一个 &lt;p&gt; 元素在 &lt;div&gt; 元素内部，当用户点击 &lt;p&gt; 元素时，哪个元素的 click event handler 首先被触发？在 bubbling 模式下，最内部元素的 event 最先响应，逐级触发外层元素；在 capturing 模式下，最外部元素的 event 最先响应，逐级触发内层元素。addEventListener() method 支持设置事件传播类型，定义下面的 useCapture 参数：addEventListener(event, function, useCapture)
useCapture 默认值为 false，也就是 bubbling 模式，当设置为 true 时 event 使用 capturing 模式。例如：//Capturing propagation
elem1.addEventListener(&quot;click&quot;, myFunction, true); 

//Bubbling propagation
elem2.addEventListener(&quot;click&quot;, myFunction, false);当同一个 event 存在于多个 DOM 层级中的元素时，设置 event propagation 事件传播模式很有用。Image Slider 幻灯片下面我们制作一个幻灯片程序，通过 Next 和 Prev button 来切换图片。首先创建 html，包含两个 button 和一个 image：&lt;html&gt;
&lt;body&gt;
    &lt;button&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;然后再 JavaScript 中定义我们的图片数组：&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];
&lt;/script&gt;下面需要添加响应 Next 和 Prev button 的 event handler 来切换不同图片：&lt;body&gt;
    &lt;button onclick=&quot;prev()&quot;&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button onclick=&quot;next()&quot;&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];

    var num = 0;
    function next() {
        var slider = document.getElementById(&quot;slider&quot;);
        num++;
        if (num &gt;= images.length)
            num = 0;
        slider.src = images[num];
    }

    function prev() {
        var slider = document.getElementById(&quot;slider&quot;);
        num--;
        if (num &lt; 0)
            num = images.length - 1;
        slider.src = images[num];
    }
&lt;/script&gt;效果如下：num 变量存储当前图片的 index 索引。Form Validation 表格验证html5 添加了一些用来验证的属性，例如 required attribute 能够添加给 input 元素来强制必须输入内容。更加复杂的验证机制可以通过 JavaScript 完成。form 元素有一个 onsubmit event 能够用来进行验证。我们创建一个 form 表格，有两个 input 和一个 button，需要两个 input 输入一样的内容且不为空才通过验证：&lt;form onsubmit=&quot;return validate()&quot; method=&quot;post&quot;&gt;
    number: &lt;input type=&quot;text&quot; name=&quot;num1&quot; id=&quot;num1&quot;&gt;
    &lt;br&gt;
    repeat: &lt;input type=&quot;text&quot; name=&quot;num2&quot; id=&quot;num2&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;然后定义 validate() function：&lt;script&gt;
    function validate() {
        var n1 = document.getElementById(&quot;num1&quot;);
        var n2 = document.getElementById(&quot;num2&quot;);

        if (n1.value != &quot;&quot; &amp;&amp; n2.value != &quot;&quot;) {
            if (n1.value == n2.value)
                return true;
        }
        alert(&quot;the values shoud be equal and not blank&quot;);
        return false;
    }
&lt;/script&gt;只有当 onsubmit event 的返回值为 true 时，form 才会被提交。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1997.html">
<title>JavaScript 入门教程之六 -- JS内置 Objects</title>
<link>https://blog.niekun.net/archives/1997.html</link>
<dc:date>2020-12-18T18:53:00+08:00</dc:date>
<description>下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。JavaScript Arrays 数组当你需要定义三个课程名称时，需要分别定义：var course1 =&quot;HTML&quot;; 
var course2 =&quot;CSS&quot;; 
var course3 =&quot;JS&quot;; 当你有 100 个课程名称呢？这时候可以使用 Array：var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);以上定义了一个数组 courses，存储了 3 个元素。可以使用 index 索引号内访问数组元素，索引号 0 表示第一个元素：var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);
var course = courses[0];
courses[1] = &quot;c++&quot;;以上示例表示：给变量 course 赋值数组第一个元素，给第二个元素赋值 c++。如果尝试访问超出数组元素的索引，会返回 undefined。在定义数组时也可以只申明数组元素个数，后续再给元素赋值：var courses = new Array(3);
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;array 数组是一种特殊的 object，它使用 index number 来访问元素，而标准 object 使用 property name 来访问元素。JavaScript array 是动态的，也就是你可以在创建时不传入任何参数给构造器：var courses = new Array();
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;
courses[3] = &quot;C++&quot;;你可以添加任意多个元素给数组。为了定义更加方便，可以使用 array literal 语法来创建数组：var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];以上语法和使用 new 关键词创建的数组是一样的。推荐使用这种语法。JavaScript array 内建了很多实用的 properties 和 method。array 的 length property 返回数组的元素个数：var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
document.write(courses.length);length 的返回值比最后一个元素的索引号大 1，如果数组为空，则返回值为 0。使用 concat() method 可以叠加两个数组并返回为一个新的数组：var c1 = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
var c2 = [&quot;C++&quot;];
var newC = c1.concat(c2);newC 数组拥有四个元素："HTML", "CSS", "JS", "C++"。注意使用 concat() method 并不会影响 c1 和 c2。Associative Arrays 关联型数组很多编程语言支持给数组添加命名化的 index 索引，也就是给每个元素定义一个名称，但是 JavaScript 不支持这种操作。但是我们依然可以定义命名化的 index 索引数组，JavaScript 会将其作为一个 object 处理：var a = [];
a[&quot;name&quot;] = &quot;marco&quot;;
a[&quot;age&quot;] = 20;
document.write(a[&quot;age&quot;]);JavaScript 会将 a 作为 object 处理，这样 name 和 age 就是其 properties。可以使用以上写法来读取 property 数据。由于 a 数组被作为 object 处理，所以标准 array 的一些 method 和 properties 将无法正确执行，例如：a.length 返回值将是 0 而不是 2。JavaScript 原生并不支持命名化的元素索引，所以推荐当你想要使用 number 数字型 index 时使用 array，当你想要使用命名化的索引时使用 object。the Math Object 数学对象the Math Object 可以用来处理数学运算任务，它包含多个 properties：Math 没有 constructor 构造器，所以使用时并不需要单独创建 object。例如：document.write(Math.PI);
以上将输出：3.141592653589793Math object 包含多个 method 用来计算：下面示例计算 4 的平方根：var a = Math.sqrt(4);如果想要得到一个 0- 10 的随机数，可以使用下面方法：Math.ceil(Math.random() * 10);
下面编写一个小程序，让用户输入一个数字然后将这个数字的平方根放在弹窗通知中：var n = prompt(&quot;please input a number: &quot;, &quot;&quot;);
var m = Math.sqrt(n);
alert(m);The Date Object 时间对象setInterval() method 用来在指定的间隔时间(毫秒)下调用 function 或评估一个表达式。它将会持续调用直到执行  clearInterval() 或关闭窗口。下面的示例将会每三秒钟弹出窗口：function myAlert() {
    alert(&quot;hello&quot;);
}
setInterval(myAlert, 3000);注意传递 function 时只需要写 function 名称即可，不需要小括号()。Data object 可以让我们使用时间元素，一个 Date object 由：a year, a month, a day, an hour, a minute, a second, and milliseconds 构成。使用 new 关键词来创建一个 Date obect，包含有当前的日期和时间：var d = new Date();
//d stores the current date and time也可以使用指定的日期和时间来创建 Date object：new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)JavaScript 日期计算使用毫秒为单位，起始日期为：01 January, 1970 00:00:00 (UTC)。一天包含 86,400,000 毫秒。以下示例使用不同方式定义指定日期：//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000); 

//Fri Jan 02 2015 10:42:00
var d2 = new Date(&quot;January 2, 2015 10:42:00&quot;);

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);JavaScript 的月份从 0 到 11，1 月就是 0，12 月就是 11。Date object 是 static 类型的，创建后就不会改变。Date object 有如下 method 可供使用：例如读取当前小时数值：var d = new Date();
document.write(d.getHours());下面示例在窗口显示当前时间，且每秒刷新一次：function printTime() {
    var d = new Date();
    var hour = d.getHours();
    var min = d.getMinutes();
    var sec = d.getSeconds();
    document.body.innerHTML = hour + &quot;:&quot; + min + &quot;:&quot; + sec;
}

setInterval(printTime, 1000);innerHTML property 可以设置或返回一个 HTML 元素的内容，这里我们将 document 的 body 块的内容赋值为我们定义的时间数据，并且每秒覆盖更新一次。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1996.html">
<title>JavaScript 入门教程之五 -- Objects</title>
<link>https://blog.niekun.net/archives/1996.html</link>
<dc:date>2020-12-18T15:25:00+08:00</dc:date>
<description>JavaScript 的 variables 变量是用来包含数据的容器。object 同样是变量，但是包含了多个数据。一个 object 是一组使用 name:value 模式定义的数据集合，大括号{} 内部定义数据，数据间使用逗号, 分隔，注意大括号结尾的分号;：var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 170
};这些数据叫做 properties：  propertyproperty valuenamemarcoage20likebasketballheight170object 初始化语法可以写在一行，也可以写在多行。以下两种写法都是一样的：var John = {name: &quot;John&quot;, age: 25};

var John = {
  name: &quot;John&quot;,
  age: 25
};JavaScript 的 object 就是一组有命名的数据的容器。有两种方法访问 object 的 properties：objectName.propertyName
//or
objectName['propertyName']使用上面的示例访问 properties，以下两种结果是一样的：var x = person.age;
var y = person['age'];使用 JavaScript 内建的 length property 可以得到 property 或 string 包含的字符个数:var a = person.name.length;methodobject method 就是一个定义了 function 的 property，使用 object method 的语法为：objectName.methodName()
我们前面多次使用 document.write() 来输出内容到网页，实际上 write() function 就是 document object 的一个 method。定义一个 method 的语法如下：methodName = function() { code lines }
在上面的示例中给 object 加入一个 method：var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 62,
    test: function() {
        alert(&quot;method&quot;);
    }
};

person.test();使用 method 的方法和 properties 一样，需要加上小括号()。The Object Constructor 构造器上一节我们学习了如何建立 object，例如：var person = {
name: &quot;John&quot;, age: 42, favColor: &quot;green&quot;
};以上的写法一次只能创建一个 object，那么如何设置一种 object type 用来创建多个统一类型的 objects 呢？标准的方法是使用 constructor function 构造器来定义一个 object type：function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}以上就是一个 constructor function，接收传入数据来赋值给 object properties。关键词 this 表示当前 object 本身。当我们定义了一个 object constructor，就可以使用关键词 new 来新建一个 object：var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
document.write(p1.name);

//output:
//marcop1 就是 person 类型的 object，它的 properties 就是对应传入的数据。同样的方法，可以在 object constructor 中定义 method：    function person(name, age, color) {
        this.name = name;
        this.age = age;
        this.favColor = color;
        this.changeName = function(name) {
            this.name = name;
        }
    }

    var p1 = new person(&quot;marco&quot;, 25, &quot;blue&quot;);
    p1.changeName(&quot;john&quot;);
    document.write(p1.name);以上示例中，我们定义了一个 changeName method，它有一个参数 name 用来赋值给 object 的 propertiy name。也可以在 object constructor function 外部定义 method：function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = bornyear;
}

function bornyear() {
    return 2020 - this.age;
}

var p1 = new person(&quot;marco&quot;, 25);
document.write(p1.yearOfBirth());以上示例中，我们给 property yearOfBirth 赋值为 bornyear。bornyear function 在外部定义，this 关键词可以来访问 person 的 properties，因为 bornyear 复制给了 person 的一个 property。注意当将一个 function 赋值给 object 时不需要写小括号()。通过 object property name 来调用构造器定义的 method，注意不是外部 function 的名称。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1992.html">
<title>JavaScript 入门教程之四 -- Functions</title>
<link>https://blog.niekun.net/archives/1992.html</link>
<dc:date>2020-12-18T13:58:00+08:00</dc:date>
<description>JavaScript function 就是一个执行特定任务的代码块。使用 function 的优点是：代码复用通过传入不同参数得到不同结果function 需要被调用才能执行。定义使用关键词 function 来定义一个 function，需要指定名称，使用大括号{} 来定义代码块：function name() { 
  //code to be executed
}function name 可以包含字符、数字，下划线和 &amp; 符号。下面定义一个简单的 function：function myFunction() {
    alert(&quot;call the function&quot;);
}

myFunction();一个 function 可以被调用任意次数，当需要调用 function 时，直接使用 function name 名称及小括号() 即可。注意结尾要写分号;。还有一种调用写法：myFunction.call()。当使用这种方法时，会自动将关键词 this 传入此 function，后续会详细介绍。function 参数function 可以接收参数，在定义时需要列出来：functionName(param1, param2, param3) {
   // some code
}多个参数使用逗号, 隔开。当定义了参数后，就可以在 function 代码块内使用：function myFunction(name) {
    alert(&quot;hi &quot; + name);
}

myFunction(&quot;marco&quot;);以上第一了一个 function 有一个 name 参数，当调用此 function 时需要给 name 赋值。function 内部就会将赋值数据分配个 name 参数。调用 function 时，通过不同的参数值来得到不同的结果：myFunction(&quot;marco&quot;);
myFunction(&quot;john&quot;);
myFunction(&quot;tom&quot;);使用逗号分隔多个参数：function myFunction(name, age) {
    alert(&quot;my name is &quot; + name + &quot;, age is &quot; + age);
}

myFunction(&quot;marco&quot;, 20);JavaScript 不会检查调用 function 时的传入参数个数和定义的参数个数是否一致，如果调用时传入参数数量少于 function 定义参数个数，则缺失的参数会被赋值为 undefined，表示没有被赋值数据。如果传入参数数量大于 function 定义参数个数，可以使用数组：arguments 来访问这些传入数据，在 function 内可以被调用，形如：arguments[0], arguments[1]，arguments 数组是 function 内自动定义的，按顺序存储所有的传入参数数据。请看下面示例：function test(a, b) {
    console.log(arguments[0]);
    console.log(arguments[1]);
    console.log(arguments[2]);
}
test(1, 2, 3);

//output:
//1
//2
//3以上示例中，function 本身只定义了 2 个参数，但是我们在调用时传入了 3 个数据，这时候为了访问到第 3 个数据，就需要使用 arguments 数组来处理了。可以看到 function 内除了使用定义的参数名外，也可以使用内部自动定义的 arguments 数组来访问传入数据。function 可以有一个可选的 return 命令，用来从 function 返回一个数据。当 JavaScript 执行到 return 时，会停止执行后续指令。下面的示例中，我们计算两个参数的和并返回结果：function myFunction(a, b) {
    return a + b;
}

var x = myFunction(1, 2);变量 x 的值就是 3。如果 function 中没有 return 则默认会返回  undefined。Alert, Prompt, ConfirmJavaScript 提供三种弹出窗口：Alert, Prompt, Confirm。alert Box 用来给用户显示一个提示信息，需要点击 OK 来取消弹窗。有一个参数：alert(&quot;this is a alert&quot;);信息中需要换行的话可以加入 \n：alert(&quot;this is\n a alert&quot;);
效果如下：Prompt Box 用来弹出一个用户可以输入数据的提示窗口。用户需要点击 OK 或 cancel 来退出窗口，如果点击 OK 则会 return 输入的数据，如果点击 cancel 则会返回 null。prompt() 有两个参数，第一个是窗口显示的提示信息字符串，第二个是输入框的默认字符(可选项)：var a = prompt(&quot;please input value&quot;, &quot;test&quot;);
document.write(a);效果如下：选择 OK 后变量 a 会赋值为输入的数据。confirm box 可以用来作为确认对话框。用户必须点击 OK 或 cancel 来退出窗口，当点击 OK 后 box 会返回 true，当点击 cancel 后 box 会返回 false：var result = confirm(&quot;if confirm&quot;);

if (result) {
    alert(&quot;confirmed&quot;);
}
else {
    alert(&quot;not confirmd&quot;);
}弹出窗口不要过多的使用，因为弹出窗口会导致页面不可用。inline function有一种特殊的 function 可以在直接在调用中进行定义，不需要写 function 名称。例如想要对 array 数组的每个元素执行一个 function，通过 forEach method 来给每个元素调用 function：var arr = [1, 2, 3];
arr.forEach(function(el) {
    console.log(el * 2);
});function 直接在调用中定义，参数 el 的值通过 forEach method 来传入每个元素的数据。下一章介绍的 object 中，要定义一个 method 就可以使用 inline function 来建立：    function person(name, age, color) {
        this.name = name;
        this.age = age;
        this.favColor = color;
        this.changeName = function(name) {
            this.name = name;
        }
    }具体的介绍参考：JavaScript 入门教程之五 -- Objects</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1990.html">
<title>JavaScript 入门教程之三 -- Conditionals and Loops</title>
<link>https://blog.niekun.net/archives/1990.html</link>
<dc:date>2020-12-18T11:10:00+08:00</dc:date>
<description>The if Statement在编程中，如果想要根据不同的情况执行不同的代码，可以使用 if conditional statements 状况指令来处理，语法如下：if (condition) {
   statements
}使用 if 语法来根据 condition 是否为 true 来确定是否执行 statements。下面举例说明，修改 html 文件 script 部分：var a = 1;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}效果如下：如果修改 condition 不为 true 则不会执行内部指令：var a = 2;
if (a == 1) {
    alert(&quot;a is 1&quot;);
}以上示例不会执行 alert function。注意如果 statement 指令只有一句时，可以省略大括号，如下写法也是正确的：var a = 1;
if (a == 1)
    alert(&quot;a is 1&quot;);使用 else 申明来 condition 为 false 时执行的指令：if (expression) {
   // executed if condition is true
}
else {
   // executed if condition is false
}下面举例说明：var a = 1;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else
    alert(&quot;a is bigger than b&quot;);以上示例实现的动作也可以使用我们上一章提到的状况判断符来实现：a &lt; b ? alert(&quot;a smaller than b&quot;) : alert(&quot;a is bigger than b&quot;);
如果 condition 不止有两种情况要处理，可以使用 else if 申明多个情况下的指令，修改上面的示例：var a = 2;
var b = 2;
if (a &lt; b)
    alert(&quot;a smaller than b&quot;);
else if (a == b)
    alert(&quot;a equal to b&quot;);
else
    alert(&quot;a is bigger than b&quot;);则会执行 alert(&quot;a equal to b&quot;); 指令。注意 else 在整个块中必须作为最后一个申明写在 if 和 else if 之后，如果所有 condition 的条件都不满足则会执行 else 中的申明指令。可以根据情况使用任意多个 else if 申明。switch当 condition 有多个情况需要处理时，使用 else if 就会很麻烦。这时候可以使用 switch statement 来处理，语法如下：switch (expression) {
  case n1: 
     statements
     break;
  case n2: 
     statements
     break;
  default: 
     statements
}switch expression 会被评估一次，然后在 case 中寻找匹配的结果并执行对应块的指令。以下是一个简单示例：var day = 2;
switch (day) {
    case 1:
        document.write(&quot;today is monday&quot;);
        break;
    case 2:
        document.write(&quot;today is tuesday&quot;);
        break;
    default:
        document.write(&quot;today is another day&quot;);
        break;
}当 day 的值为 2，则会匹配到 case 2 并执行其内的指令。当 JavaScript 执行到 break 后会跳出 switch 块，如果不写 break 则会顺序执行下面的指令，即使不满足其他的 case 条件。通常情况下每个 case 块结尾都应该有 break。default 关键词用来处理没有匹配到任何 case 情况，如果没有匹配到则执行 default 中的指令。如果不需要处理没有指定的 case 匹配到的情况时 default 可以被省略。for 循环使用 loop 循环可以多次执行一段代码，通过一些条件来控制循环次数及参数值。JavaScript 提供三种类型的循环：for, while, 和 do while。for 循环语法如下：for (statement 1; statement 2; statement 3) {
   code block to be executed
}Statement 1 在循环前被执行Statement 2 定义执行循环的状态Statement 3 在每次循环后被执行下面的示例将输出 0 - 4：for (var i=0; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}过程为：首先给变量 i 赋值为 1，执行循环的条件是 i&lt;5，每次循环后给 i 加 1。当 i==4 时，执行完本次循环后 i 加 1 后值为 5，不满足第二项条件就会跳出循环。statement 1 是可选项可以不写，如：var i = 0;
for (; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}和第一个示例效果是一样的。statement 1 也可以同时定义多个参数，使用逗号, 来隔离，如：for (var i=0, j=2; i&lt;5; i++) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    
}如果 statement 2 返回 true 则会执行循环块内容，如果返回 false 则会结束循环。同样的 statement 2 也是可选项，也可以不定义，但是必须在循环块内定义 break 不然就会无线循环下去：for (var i=0; ; i++) {
    if (i &gt;= 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}statement 3 用来修改初始变量的值，同样也是可选项，可以在循环块内部直接修改初值：for (var i=0; i&lt;5 ;) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}while 循环while 循环也是用来实现当某个 condition 为 true 时循环一个代码块。语法如下：while (condition) {    
   code block
}下面的示例将输出 0 - 10 的数字：var i = 0;
while (i&lt;=10) {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
}当 condition 一直为 true 时，循环就会继续下去。我们应该避免无限循环情况出现。do while 循环do while 循环是 while 循环的一种变形，它会首先执行一次循环块然后判断 condition 条件。语法如下：do {
   code block
}
while (condition);注意 while 结尾的分号; 不能省略。下面的示例会输出 0 - 4：var i = 0;
do {
    document.write(i + &quot;&lt;br&gt;&quot;);
    i++;
} while (i&lt;5);循环块至少会执行一次，即使 condition 为 false。breakbreak 指令用来跳出循环继续执行后续程序。下面示例中，将只会输出 0 - 4 的数字：for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        break;
    document.write(i + &quot;&lt;br&gt;&quot;);
}在 function 中可以使用 return 来跳出当前代码块，下一章节将会介绍。continuecontinue 指令用来仅跳出当次循环，然后继续进行下一次循环。下面示例将会输出 0- 10，但不包括 5：for (var i=0; i&lt;10 ; i++) {
    if (i == 5)
        continue;
    document.write(i + &quot;&lt;br&gt;&quot;);
}当 i 等于 5 时会跳出本次循环所以不会输出 5，但是会继续进行下面的循环。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1985.html">
<title>JavaScript 入门教程之二 -- 基本概念</title>
<link>https://blog.niekun.net/archives/1985.html</link>
<dc:date>2020-12-17T16:33:00+08:00</dc:date>
<description>数学运算符有以下运算符可以使用：加减运算使用方法很简单：var b = 10 + 2;
var c = b - 3;
document.write(c);可以使用 eval() 来将计算结果转换为字符串形式：var d = eval(&quot;10 + 2 + 1&quot;)
document.write(d);d 的结果就是 &quot;13&quot;。乘法使用星号* 来表示，以下三种写法都是正确的：var e = 2 * 3;
var f = 2 * '3';
var g = '2' * '3';
document.write(g);注意如果尝试对一个字符串进行乘法计算会返回：NaN (Not a Number)：var h = 'hello' * 2;
document.write(h);

//output：
//NaN除法使用斜线/ 表示：var i = 1 / 2;注意被除数不能为 0。取模运算使用% 表示：var j = 10 % 3;
document.write(j);

//output:
//1可以对整数和浮点型数字进行取模运算。递增和递减：使用++ 表示给对应变量进行加 1 运算，操作符写在变量前则返回加 1 后的值。写在后边返回加 1 前的值。使用-- 表示给对应变量进行减 1 运算，操作符写在变量前则返回减 1 后的值。写在后边返回减 1 前的值var k = 10;
var l = k++;
var m = ++l;
document.write(m);

//output:
//11分配符 Assignment Operators可用的分配符有：除了常规用法外，也可以在一行命令中使用多个分配符，例如：var n = 4;
var o = 5;
o += n += 3;
document.write(o);

//output:
//12比较符 Comparison Operators在逻辑判断中使用比较符来比较数据是否有区别。结果为 true 或 false。例如可以使用 equal to (==) operator 来比较两个数据是否一样：var p = 2;
document.write(p == 1);

//output:
//false所有的数据类型都可以进行比较，返回值只有 true 和 false。但需要注意比较的两个数据需要是同一类型的。以下是可用的比较符：逻辑判断符 Logical Operators逻辑判断符用来评估一个表达式，返回结果为 true 和 false。可用的逻辑判断符为：AND, OR, NOT：&amp;&amp; - AND 如果判断块都为 true，则返回 true|| - OR  如果任何一个判断块为 true，则返回 true! - NOT  如果判断块为 false，则返回 true下面的示例是对两个判断块进行 与AND 操作：(4 &gt; 2) &amp;&amp; (1 &lt; 3);以上两个判断块都为 true 则整个逻辑判断结果为 true。状况判断符 Conditional (Ternary) Operator状况判断符用来根据一些实际状态给某个变量赋值。语法如下：variable = (condition) ? value1: value2 
下面举例说明：var age = 20;
var isAdult = (age &lt; 18) ? &quot;too young&quot; : &quot;old enough&quot;;
document.write(isAdult);

//OUTPUT:
//old enough以上示例中，如果 age 小于 18 则 isAdult 赋值为 "too young"，如果 age 大于等于 18 则 isAdult 赋值为 "old enough"。字符串操作符 String Operators我们可以使用级联符+ 来将多个字符串组合成一个新的字符串。例如：var str1 = &quot;this is a &quot;;
var str2 = &quot;test string&quot;;
document.write(str1 + str2);

//output:
// this is a test string注意一个数字使用引号括起来后就成了一个字符串，如：&quot;42&quot; 表示一个字符串。。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1979.html">
<title>JavaScript 入门教程之一 -- 总览</title>
<link>https://blog.niekun.net/archives/1979.html</link>
<dc:date>2020-12-17T10:31:00+08:00</dc:date>
<description>JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。最初命名为 Mocha，1995年9月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年12月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上 Java 这个编程语言“热词”，因此将其临时改名为 JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。不同于服务器端脚本语言，例如 PHP 与 ASP，JavaScript 主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于 JavaScript 以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器变得强大，现在的程序员更喜欢运行于服务端的脚本以保证安全，但 JavaScript 仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖 JavaScript 在客户端进行支持。随着引擎如 V8 和框架如 Node.js 的发展，及其事件驱动及异步 IO 等特性，JavaScript 逐渐被用来编写服务器端程序。且在近几年中，Node.js 的出世，让 JavaScript 也具有了一定的服务器功能。我们的第一个 JavaScript我们首先来了解一些基本概念，给 web 网页加上 JavaScript。在 web 上，JavaScript 位于 HTML document 内，可以在任意位置。js 内容使用 &lt;script&gt; 和 &lt;/script&gt; 包围起来：&lt;script&gt;
   ...
&lt;/script&gt;让我们使用 JavaScript 在网页上打印出一个 Hello World，新建一个 html 文件，内容如下：&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        
    &lt;/body&gt;
    &lt;script&gt;
        document.write(&quot;hello world&quot;);
    &lt;/script&gt;
&lt;/html&gt;使用 document.write() function 用来给 html document 写入内容。注意此 function 只用来测试，实际使用中会覆盖 document 中已有的内容。JavaScript 每条指令结尾使用分号; 来标记。文件保存后可以使用浏览器打开查看效果。js 中还支持标准 html markup 标记语法，我们给 hello world 设置属性：    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
    &lt;/script&gt;这时候文字会以标题模式显示。也可以在浏览器终端 console 中输出信息，使用 console.log() function 实现：    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
    &lt;/script&gt;打开浏览器的调试窗口即可看到输出信息，chrome 浏览器使用快捷键 ctrl+shift+I 或设置中打开调试：点击 console 栏查看：注释对于不需要被执行的语句可以使用符号来忽略，使用双斜杠 // 注释单行内容，使用 /* 和 */ 注释一个块。修改我们上面的 html 文件的 js 块：    &lt;script&gt;
        // this is a commit
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
        /* this code create
            a alert box
        */
        alert(&quot;this is a alert box&quot;);
    &lt;/script&gt;alert() function 用来弹出一个提示窗口。变量variables 变量是存储数据的容器。变量的值可以再程序中被修改。使用关键词 var 申明一个变量：var x = 10;
以上指令给变量 x 分配数据 10。注意我们在此使用 assign 分配来描述这个过程，因为在 JavaScript 中等于号= 会调用 assignment operator 操作符，而不是 equal to operator 操作符。变量名是大小写敏感的，也就是说 name 和 Name 是两个变量。让我们输出一个变量值到浏览器：var x = 10;
document.write(x);变量定义的基本原则：首字符必须是这三者之一：字母，下划线_，$ 符。后续字符可以是字母、数字，下划线或者 &amp;名称不能包含数学运算符或操作符不能包含空格不能使用特殊字符，如：# & % 等不能使用连字符-，这是减法保留符数据类型JavaScript 支持多种类型的数据：numbers, strings, arrays 等。numbernumber 可以是整数或小数：var a = 10;
var b = 1.1;变量分配的数据类型可以任意修改，例如重新分配 a 的数据为 string 字符串：a = &quot;this is a strings&quot;;
string使用 string 可以来存储及操作文本信息。使用引号来包裹内容，单引号' 或双引号&quot; 都可以：var a = 'marco';
var b = &quot;john&quot;;如果要在 string 内部使用也引号，可以通过内外使用不同的单双引号来实现，js 会自动区分：var a = &quot;this is a 'test'&quot;;
如果内外想要使用同一个引号形式可以在内部使用转义符 \ 来实现：a = &quot;this \&quot;is\&quot; a \&quot;other\&quot; test&quot;;
转义符可以将特殊字符作为普通字符使用，也可以实现特殊功能，一些列表是常用的转码：注意字符串的包裹分号需要前后统一，起始用了单引号结尾也必须使用单引号，否则会报错。BooleanBoolean 只有两种结果：true 和 false。如果你需要一种只有两种可能的结果的数据类型，就可以使用 Boolean：var isActive = true;注意 Boolean 类型的值如果是：0 (zero), null, undefined, empty string 则都是 false，其他如果有一个真实数据的都为 true。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1977.html">
<title>brew 安装路径</title>
<link>https://blog.niekun.net/archives/1977.html</link>
<dc:date>2020-12-16T22:04:00+08:00</dc:date>
<description>brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。brew 默认安装路径为：/usr/local/Cellar，然后会在 /usr/local/opt/ 建立所安装的包的软连接。包安装好后如果不能正常执行，可以建立包的可执行程序的软连接到：/usr/local/bin/ 目录。比如安装 openssl：brew install openssl
安装后包的路径为：/usr/local/Cellar/openssl@1.1/1.1.1h。同时包的软连接在：/usr/local/Cellar/openssl。这时候执行命令：openssl version
返回的并不是刚才安装的版本，而是系统自带的老版本的。这时候可以建立可执行程序的软连接到对应路径：ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
这时候执行命令就可以得到正确的返回：openssl version
//OpenSSL 1.1.1h  22 Sep 2020
其他包的模式和此类似。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1973.html">
<title>QT 网络应用</title>
<link>https://blog.niekun.net/archives/1973.html</link>
<dc:date>2020-12-16T16:59:00+08:00</dc:date>
<description>最近研究了下 QT 如何访问网络，做一些简单总结。首先在 pro 文件内定义网络属性：QT  += network
如果需要连接 https 需要安装 openssl 工具，使用 QT 的 MaintenanceTool 工具找到 openssl toolkit 并安装。否则执行程序时 ssl 会报错。安装后需要将 openssl 路径加入系统 PATH，默认安装路径为：Qt/Tools/OpenSSL。根据需要将对应系统版本的 bin 路径加入 PATH 如：C:\Qt\Tools\OpenSSL\Win_x86\bin，里面包含相关 lib 库文件。添加方法参考：https://blog.niekun.net/archives/413.html。需要用到的 QT class：QNetworkAccessManagerQNetworkRequestQSslConfigurationQNetworkReply我们做一个示例，新建项目，在头文件添加相关引用：#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;public 栏添加触发网络访问的 function：public:
    void doRequest();private 栏定义指针：private:
    QNetworkAccessManager *manager;添加 private slots 用来处理服务器的回应：private slots:
    void replyFinished(QNetworkReply *reply);传入参数 reply 用来接收网络访问响应内容，对应于 signal: void QNetworkAccessManager::finished(QNetworkReply *reply)，signal 触发后的数据通过 connect 会自动传入 slot 中，下面在源文件中做详细定义。下面修改源文件，先在构造器中调用触发网络 function: doRequest()：MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    doRequest();
}下面实现 doRequest() 的内容：void MainWindow::doRequest() {
    manager = new QNetworkAccessManager(this);

    QSslConfiguration sSlConfig;
    sSlConfig.setDefaultConfiguration(QSslConfiguration::defaultConfiguration());
    sSlConfig.setProtocol(QSsl::TlsV1_2);

    QNetworkRequest request;
    request.setSslConfiguration(sSlConfig);
    request.setUrl(QUrl(&quot;https://info.niekun.net&quot;));
    request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);

    manager-&gt;get(request);

    connect(manager, &amp;QNetworkAccessManager::finished, this, &amp;MainWindow::replyFinished);
    connect(manager, &amp;QNetworkAccessManager::finished, manager, &amp;QNetworkAccessManager::deleteLater);
}首先实例化一个 QNetworkAccessManager 用来访问网络。然后构造我们的 request 和 ssl 的初始化内容，request 中设置了访问的网络地址，定义了一个 request 的 header。QNetworkAccessManager  的 object 使用 get function 来启动网络请求。然后我们使用 connect 根据网络请求发出后的响应来触发相关 slot function。signal 触发后的数据会传入 slot function 中。所以 signal：void QNetworkAccessManager::finished(QNetworkReply *reply) 触发后返回的数据 reply 自动作为传入数据给 replyFinished。第二个 connect 的作用是网络请求结束后释放相关内存，避免造成内存溢出。注意这里我使用了新版的 QT connect 语法，详细参考官方文档：https://wiki.qt.io/New_Signal_Slot_Syntax下面实现 replyFinished：void MainWindow::replyFinished(QNetworkReply *reply) {
    if(reply-&gt;error())
    {
        qDebug() &lt;&lt; &quot;ERROR!&quot;;
        qDebug() &lt;&lt; reply-&gt;errorString();
    }
    else
    {
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentTypeHeader).toString();
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::LastModifiedHeader).toDateTime().toString();;
        qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentLengthHeader).toULongLong();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
        qDebug() &lt;&lt; &quot;-----------------------&quot;;
        qDebug().noquote() &lt;&lt; reply-&gt;readAll();
    }
}reply 指向 &amp;QNetworkAccessManager::finished 的 QNetworkReply 数据。在此 function 中，我们输出 reply 中的部分信息来检测网络是否通畅。其他的可用类型可以查询：https://doc.qt.io/qt-5/qnetworkrequest.html#public-types注意使用 qDebug().noquote() 来自动将字符串中的 \n 作为换行处理。正常输出信息如下：&quot;text/plain&quot;
&quot;&quot;
0
200
&quot;OK&quot;
-----------------------
request info:
request: GET / HTTP/1.1
scheme: https
host: info.niekun.net
http_host: info.niekun.net
uri: /
request_uri: /
connection: 202130
remote_addr: 172.68.189.53
client_real_ip: 1.81.217.183
server_port: 443

other variates:
http_x_forwarded_for: 1.81.217.183
proxy_add_x_forwarded_for: 1.81.217.183, 172.68.189.53以上就是 QT 访问网络的简单教程。参考链接：https://www.bogotobogo.com/Qt/Qt5_Downloading_Files_QNetworkAccessManager_QNetworkRequest.php</description>
</item>
</rdf:RDF>