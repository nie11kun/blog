<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/author/1/">
<title>Marco Nie - admin</title>
<link>https://blog.niekun.net/author/1/</link>
<description>admin</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2140.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2139.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2137.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2100.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2103.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2098.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2086.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2085.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2074.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2071.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2140.html">
<title>node.js 入门教程之六 -- FileSystem</title>
<link>https://blog.niekun.net/archives/2140.html</link>
<dc:date>2021-02-07T17:17:30+08:00</dc:date>
<description>File descriptor 文件描述器当需要访问文件系统里的某个文件时，需要首先得到这个文件的 file descriptor 文件描述器。一个 file descriptor 就是通过 fs 模块的 open() method 打开对应文件的返回数据。它的结构如下：const fs = require('fs')

fs.open('./test.txt', 'r', (err, data) =&gt; {
    if (err) {
        console.log('open fail')
        return
    }
    console.log('open success')
})如果文件打开成功，callback 中的 data 数据就是一个 file descriptor。这种方式是异步处理的，文件打开过程中系统会执行其他任务。在上面的示例中，fs.open() 的第三个参数使用了 'f' 标记，它的意思就是以只读模式打开文件。我们可以通过使用不同的标记来以不同的方式打开文件：r 只读模式，文件不存在会报错a 只写模式，streaming 流定位到文件结尾位置，如果文件不存在则创建文件r+ 读写模式，文件不存在会报错w+ 读写模式，streaming 流定位到文件起始位置，如果文件不存在则创建文件a+ 读写模式，streaming 流定位到文件结尾位置，如果文件不存在则创建文件更多 flag 的使用参考：https://nodejs.org/api/fs.html#fs_file_system_flags也可以使用 fs.openSync() method 打开文件，其返回值为 file descriptor 而不是通过 callback 的方式：try {
    const data = fs.openSync('./test.txt', 'r')
    console.log('open success')
} catch (error) {
    console.log('open fail')
}这种方式是同步模式的，程序会等待接收到 file descriptor 或者 error 后才执行后面的指令。File stats 文件信息每个文件都包含独自的属性信息，可以通过 node.js 查看。通常我们使用 fs 模块的 stat() method。以下是一个简单示例：const fs = require('fs')

fs.stat('./test.txt', (err, stats) =&gt; {
    if (err) {
        console.log('read fail')
        return
    }
    console.log(stats)
})同样的，node.js 也提供了同步模式 method，在读取 stats 过程中会阻塞进程知道读取结束：try {
    const stats = fs.statSync('./test.txt')
    console.log(stats)
} catch (error) {
    console.log(error)
}文件信息存储在 stats 变量中，可以读取其中的需要的信息，常用的有以下：是否是文件或文件夹：stats.isFile()，stats.isDirectory()是否是一个链接文件：stats.isSymbolicLink()文件大小(单位为字节)：stats.sizeFile Path 文件路径每个文件在系统中都有一个路径。在 Linux 中路径格式如：/users/joe/file.txt，在 Windows 中路径格式如：C:\users\joe\file.txt。在程序中引用路径时需要特别注意路径的格式。node.js 中可以使用 path 模块来处理文件路径相关数据。如果给定一个路径，可以提取其相关数据，如：path.dirname: 获取文件的上级文件夹路径path.basename: 获取文件名部分path.extname: 获取文件扩展名const path = require('path')

const file = '/home/marco/file.txt'
console.log(path.dirname(file))
console.log(path.basename(file))
console.log(path.extname(file))

//output:
/home/marco
file.txt
.txt可以获取文件名不包含扩展名部分，通过给 path.basename() 设置第二个参数：console.log(path.basename(file, path.extname(file)))

//output:
file可以组合多个部分为一个 path：const dir = 'home/marco/'
p = path.join('/' + dir + 'test.txt')
console.log(p)

//output:
/home/marco/test.txt使用 path.resolve() 可以从一个相对路径获取到绝对路径：p = path.resolve('file.txt')
console.log(p)
p = path.resolve('./test/file.txt')
console.log(p)

//OUTPUT:
/mnt/hgfs/Development/node.js/filesystem/file.txt
/mnt/hgfs/Development/node.js/filesystem/test/file.txt以上示例中，会将程序当前执行路径作为绝对路径添加给后面定义的文件相对路径。也可以将文件的相对目录单独定义，会自动组合它们：p = path.resolve('tmp', 'file.txt')
console.log(p)

//output:
/mnt/hgfs/Development/node.js/filesystem/tmp/file.txt如果在路径前加斜杠/ 表明这就是一个绝对路径：p = path.resolve('/tmp', 'file.txt')
console.log(p)

//output:
/tmp/file.txt如果路径中包含相对关系标记符如: .., //等，可以使用 path.normalize() 得到常规形式的路径：p = path.normalize('/home/../test/file.txt')
console.log(p)

//output:
/test/file.txtpath.resolve 和 path.normalize 都不会检查路径是否真实存在，它们仅仅是根据提供的数据计算路径结果。reading file 读取文件最简单的方式读取文件内容就是通过 fs.readFile() method，需要给它传入文件路径，编码格式，callback function:const fs = require('fs')

fs.readFile('./test.txt', 'utf-8', (err, data) =&gt; {
    if (err) {
        console.log('read fail')
        return
    }
    console.log(data)
})或者也可以使用同步模式的 fs.readFileSync()：try {
    data = fs.readFileSync('./test.txt', 'utf-8')
    console.log(data)
} catch (error) {
    console.log('read error')
}fs.readFile() 和 fs.readFileSync() 都会先将文件内容读取到内存中，然后返回数据。这就意味着读取大文件会影响系统内存的占用量，所以一个比较好的选择是使用 stream 流读取文件内容。后续章节会介绍 stream 模块。writing file 文件写入最简单的写入文件的方法就是使用 fs.writeFile() method。示例如下：const fs = require('fs')

const content = 'some new words'
fs.writeFile('./test.txt', content, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})或者使用同步模式的版本 fs.writeFileSync()：try {
    fs.writeFileSync('./test.txt', content)
    console.log('write success')
} catch (error) {
    console.log('write error')
}默认情况下，如果这个文件已经存在，API 会替换掉这个文件中已有的内容。我们可以通过定义 flag 来修改这个设置：fs.writeFile('./test.txt', content, {flag: 'a+'}, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})flag 的定义和上面的 fs.open 中定义的 flag 一样，可以参考设置。append to a file 给文件添加内容给已有文件附加内容更加方便的方法是使用 fs.appendFile()和 fs.appendFileSync()，例如：const fs = require('fs')

content = '\nnew line\n'
fs.appendFile('./test.txt', content, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})上面了方法都会在将数据完全写入文件后在执行 callback，这种情况下使用 stream 是一个更好的方法。working with folder 文件夹操作node.js 的 fs 模块提供了很多实用的 method 来对文件夹进行操作。检查文件夹是否存在使用 fs.access() 可以检查文件夹是否存在，以及 node.js 是否有访问它的权限：const fs = require('fs')

fs.access('./tmp', err =&gt; {
    console.log(err ? 'not exist' : 'exist')
})

//output:
//not exist创建新文件夹使用 fs.mkdir() 或 fs.mkdirSync() 创建新文件夹：const fs = require('fs')

const fd = 'tmp'
try {
    if (!fs.existsSync(fd)) {
        fs.mkdirSync(fd)
        console.log('create success')
    }
} catch (error) {
    console.log('create fail')
}上面使用了同步模式 method 创建文件夹，看起来更加直观。read content of a directory 读取目录内容使用 fs.readdir() 或 fs.readdirSync() 可以读取某个目录中的内容，包括其中的文件和文件夹。返回值为一个数组：const fs = require('fs')

const p = '/usr'
const d = fs.readdirSync(p)
console.log(d)输出为：[
  'bin',     'games',
  'include', 'lib',
  'lib32',   'lib64',
  'libexec', 'libx32',
  'local',   'sbin',
  'share',   'src'
]通过 path 模块的 join 或 resolve method 可以输出每个元素的绝对路径，修改以上示例：const fs = require('fs')
const path = require('path')

const p = '/usr'
const d = fs.readdirSync(p).map(f =&gt; {
    return path.resolve(p, f)
})
console.log(d)输出如下：[
  '/usr/bin',     '/usr/games',
  '/usr/include', '/usr/lib',
  '/usr/lib32',   '/usr/lib64',
  '/usr/libexec', '/usr/libx32',
  '/usr/local',   '/usr/sbin',
  '/usr/share',   '/usr/src'
]如果只想获取目录下的文件而不包含文件夹，可以定义一个 filter 过滤元素：const fs = require('fs')
const path = require('path')

const isFile = fileName =&gt; {
    return fs.statSync(fileName).isFile()
}
const p = '/usr'
const d = fs.readdirSync(p).map(f =&gt; {
    return path.resolve(p, f)
}).filter(isFile)

console.log(d)rename folder 重命名文件夹使用 fs.rename() 或 fs.renameSync() 重命名文件夹。第一个参数定义当前路径，第二个参数定义新路径：const fs = require('fs')

fs.rename('./tmp', './new', err =&gt; {
    if (err) {
        console.log('rename error')
        return
    }
    console.log('rename success')
})remove folder 删除文件夹使用 fs.rmdir() 或 fs.rmdirSync() 可以删除文件夹。但删除文件夹相比其他操作稍微复杂，用到的工具可能超出你需要的部分。所以最简单的方法就是使用第三方模块：fs-extra 来处理。它是 fs 的替代品，在 fs 模块的基础上提供了很多新功能。使用 fs-extra 的 remove() method 可以实现删除文件夹的功能：const fs = require('fs-extra')

const p = './new'
fs.remove(p, err =&gt; {
    if (err) {
        console.log('remove error')
        return
    }
    console.log('remove success')
})也可以使用 promise 模式：fs.remove(p)
.then(() =&gt; console.log('remove success'))
.catch((err) =&gt; console.log(err))还可以使用 async/await 模式：const rm = async (p) =&gt; {
    try {
        await fs.remove(p)
        console.log('remove success')
    } catch (error) {
        console.log('remove error')
    }
}
rm(p)</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2139.html">
<title>Windows 主机使用 VMware 虚拟机在共享文件夹调试 node.js 时 npm install 报错问题的处理</title>
<link>https://blog.niekun.net/archives/2139.html</link>
<dc:date>2021-02-07T11:07:10+08:00</dc:date>
<description>由于 node.js 在 Windows 下会有各种问题，最好的开发环境还是 Linux，所以我通过 VMware 内安装 Ubuntu 虚拟机的方式学习 node.js。我的流程是：VMware 安装 Ubuntu共享 Windows 下的文件夹给 Ubuntu 作为开发目录Windows 下使用 vs code 通过 ssh 方式远程连接 Ubuntu通过远程连接的方式在 Windows 下做 node.js 开发实际体验很好。但是在通过 npm 安装某些包时常常会有报错出现，错误日志大概意思就是说无法给 node_modules 文件夹内安装的库文件添加软连接到系统路径。网上查询后发现了问题原因，我的开发目录实际是在 Windows 下的，Windows 和 Linux 有着不一样的文件系统和路径格式，所以 npm 在安装某些包含 bin 可执行文件的第三方库时，会默认自动创建相关文件的软链接到 Linux 系统路径，这样就就报错了。如果要坚持使用共享目录的形式做开发，那么需要设置在 npm 安装新库时使用参数 --no-bin-links 告诉系统不要自动创建软连接，语法如下：npm install cowsay --no-bin-links
这样就会跳过相关步骤。也可以设置到 npm 配置中，这样以后安装的包都会默认不创建 bin 的软连接了：npm config set bin-links false
当然最理想的方式就是将开发路径放置在 Linux 系统中，而不是通过共享目录的形式。这样就是一个纯原生的环境。参考链接：https://github.com/npm/npm/issues/2221</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2137.html">
<title>node.js 入门教程之五 -- HTTP request and response</title>
<link>https://blog.niekun.net/archives/2137.html</link>
<dc:date>2021-02-06T16:50:00+08:00</dc:date>
<description>搭建 http server下面是一个 http server 的示例：const http = require('http')
process.env.PORT = 3000
const port = process.env.PORT

const server = http.createServer((req, res) =&gt; {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})
server.listen(port, () =&gt; console.log(`server running at port ${port}`))访问 http://localhost:3000 就会看到页面显示 hello world。下面我们简单解释下以上示例的执行过程：首先引入 http module设置环境变量 PORT 为 3000，然后赋值给 port 变量创建一个 server，其中含有一个 callback function，用户访问 server 时会被调用设置监听端口并启动 server，当 server 启动成功后，会执行 server.listen 内定义的 callback function当 server 收到用户的请求时，会触发 request event 并提供了两个数据：一个 request(http.IncomingMessage object) 和一个 response(http.ServerResponse object)。request 提供了 request 的详细信息，可以用来获取请求 hreaders 和请求数据。response 用来操作将要发送给客户端的数据。在上面的示例中，我们修改了 response 相关信息：设置 statusCode 为 200设置一个 header结束 response 并将响应内容作为数据传入 end()发起 GET 请求下面示例发起一个 GET 请求：const https = require('https')
const options = {
    hostname: 'niekun.net',
    port: 443,
    path: '/',
    method: 'GET'
}

const req = https.request(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})

req.on('error', err =&gt; console.log(err))
req.end()以上示例执行过程为：首先引入 https 模块。创建一个 options object 存储请求的信息。创建一个 https request，使用 options 作为请求信息，当请求成功后会执行后面定义的 callback function。定义一个 event handler 事件管理器来处理当 error 被触发时的响应。最后结束这个 request下面是一个 POST 请求示例：const https = require('https')

const data = JSON.stringify({
    todo: 'go to sleep'
})

const options = {
    hostname: 'niekun.net',
    port: 443,
    path: '/',
    method: 'POST',
    Headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
    }
}

const req = https.request(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})
req.on('error', err =&gt; console.log(err))

req.write(data)
req.end()POST 请求相比 GET 请求多了 request.write(data) 部分，因为 POST 是把数据消息放在 body 中的。PUT 和 DELETE 请求和 POST 格式相同，只需要修改 request.method 即可。使用 Axios 库发起 POST 请求上面介绍了是应用 https 模块来发起 POST 请求，我们也可以使用第三方库使代码更加简洁，这里介绍 axios 库实现(需要通过 npm 安装)：const axios = require('axios')

axios
.post('http://localhost:3000', {
    todo: 'go to sleep'
})
.then(res =&gt; {
    console.log(`statusCode is: ${res.status}`)
    process.stdout.write(res.data)
})
.catch(err =&gt; console.log(err))获取 http request body 数据下面介绍 server 端如何提取在 http request body 中的 json 数据。如果你使用 Express 模块创建 http server，那么只需要使用它的 body-parser 内容拆分模块即可实现提取 json 数据，Express 模块在第一章做过示例，如果客户端使用上面的 axios 示例发起请求，服务端代码如下：const express = require('express');
const app = express();

process.env.PORT = 3000
const port = process.env.PORT

app.use(
    express.urlencoded({
        extended: true
    })
)
app.use(express.json())

app.get('/', (req, res) =&gt; {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})

app.post('/', (req, res) =&gt; {
  console.log(req.body.todo)
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/html')
  res.end('hello world\n')
});

const server = app.listen(port, () =&gt; console.log('Server ready'));我们使用 express 模块创建了一个 server，并同时监听 GET 和 POST 请求并定义了 callback 响应，通过 app.use 设置了对请求 body 数据的 json 支持。当启动上面实例中使用 axios 开启的服务端的程序后，server 端收到 POST 请求后就会提取请求 body 中的 todo 对应内容并输出到终端。客户端成功收到 response 后会输出 200 状态码和响应内容。我们通过浏览器直接访问 localhost:3000 会发起一个 GET 请求，浏览器会显示 hello world。如果你不想使用 express 模块创建 server，那么 server 端要提取 POST request body 中的 json 数据就稍微麻烦一些。首先需要理解的是当我们通过 http.createServer() 创建了一个 http 服务后，callback function 会在所有的 request headers 内容都接收到后被调用，而不是 request body。connection callback 中传递的完整的 request object 数据是在 stream 流中。所以我们必须监听传输的 request body 的内容，它们是在一些 chunks 数据块中的。首先我们通过监听 data event 获取 body 数据，data event 在传输过程中会被多次触发，当 request 数据传输完毕后 end event 会被触发。通过下面的代码可以获取到完整的 body 数据：const server = http.createServer((req, res) =&gt; {
    let data = '';
    req.on('data', chunk =&gt; {
        data += chunk;
    })
    req.on('end', () =&gt; {
        console.log(JSON.parse(data).todo)
    })
})以上代码中，data 最终存储了 request body 的数据，然后通过 JSON.parse method 可以解析 json 内容。server 端完整的代码如下：const http = require('http')
process.env.PORT = 3000
const port = process.env.PORT

const server = http.createServer((req, res) =&gt; {
    let data = '';
    req.on('data', chunk =&gt; {
        data += chunk;
    })
    req.on('end', () =&gt; {
        console.log(JSON.parse(data).todo)
    })

    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})
server.listen(port, () =&gt; console.log(`server running at port ${port}`))以上就是 http request 和 response 部分的简单介绍。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2100.html">
<title>node.js 入门教程之四 -- Event Loop 和 asynchronous</title>
<link>https://blog.niekun.net/archives/2100.html</link>
<dc:date>2021-02-04T21:36:00+08:00</dc:date>
<description>Event Loop 事件循环event loop 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node.js 能够变得如此流行的原因之一。node.js 代码运行在单进程中，也就是说它在一刻只能执行一个任务。这一限制特性使得我们不用担心任务间冲突问题。我们在变开发中只需要专注于代码本身，同时应避免进程阻塞，例如同步方式等待网络请求，死循环等。通常情况下，浏览器中的每个 tab 页面都是都有各自独立的 event loop，防止某个页面的死循环或过高的资源消耗影响到整个浏览器的体验。我们只需要关注于我们的代码运行在一个单一的 event loop 中，编程中要注意到这一点，防止进程阻塞。JavaScript 代码中如果有长时间等待 return 返回给 event loop 控制时，任何其他代码将会被阻塞，也会阻塞页面 UI 单元，用户在此期间无法进行点击，滚动等操作。几乎所有的 JavaScript 原生 IO 指令都是 non-blocking 非阻塞式的，例如：网络请求，文件读写等，阻塞是一种 exception 例外情况，这也是 JavaScript 大量的使用 callback 方式，以及最近引入的 promise 和 async/await。call stack 调用结构JavaScript 的 call 调用过程的结构遵循 LIFO (Last In, First Out)，也就是总是先响应最近的任务。event loop 总是连续的检查 call stack 看是否有任务需要执行。在这个过程中，它会将发现的任务添加到 call stack 中并按顺序执行。下面是一个简单的示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    bar();
    baz();
}

foo();
console.log('END');

//output:
//foo
//bar
//baz
//END在以上示例中，首先会调用 foo()，在 foo 中首先会调用 bar()，然后调用 baz()。call stack 执行过程如下：在 event loop 的每次 iteration 递归执行中会查询 call stack 中是否有需要执行的任务，如果有则执行它，直到 loop 结束为止，如下是循环中的全过程：以上示例说明了 JavaScript 在一般情况下按顺序执行代码的过程。下面介绍如何将一个 function 推迟到 call stack 递归到最后时再被调用。需要使用以下的代码指令：setTimeout(() =&gt; {}, 0)
以上代码调用了 setTimeout 延时 function，但是将延时设置为 0，这样的意义就是要求它在可以执行的时候立刻执行其中定义的 function。那么如何才能让其在层级的最后再执行 function 呢？下面是一个完整的片段：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    baz();
}

foo();
console.log('END');

//output:
//foo
//baz
//END
//bar以上示例中，我们在 foo 中先调用 setTimeout function，并将时间设置为 0，要求其在可以执行时立刻执行内部定义的指令，以上示例循环的 call stack 过程如下：下面时循环的顺序执行全过程：为什么会是这样的执行顺序呢？为什么 setTimeout 时间设置为 0 反而最后才执行其 function？下面做介绍。Message Queue 消息队列当 setTimeout() 被调用时，浏览器或 node.js 会开启一个定时器，当定时时间到达时，这里我们设置为 0 也就是立刻到达了时间，callback 响应的 function 会被放到 Message Queue 消息队列中。Message Queue 消息队列也管理着用户主动触发的一些事件如鼠标点击键盘输入等，或者 fetch 获取响应信息，这些消息按顺序排列着等待被代码执行。call stack 和 Message Queue 是互相独立的，event loop 循环时 call stack 中的任务是优先的，它会首先查找 call stack 中需要执行的代码并按顺序执行，当 satck 执行完成后再去查看 Message Queue 中需要处理的任务。我们并不需要等待一些 functions 如 setTimeout 或 fetch 这些任务的执行过程，因为这些工作由浏览器提供且这些任务运行在它们单独的线程中。例如当我们设置了 setTimeout 2 秒的定时，我们并不需要停下来等待这 2 秒钟，而是会执行层级中接下来的指令。Job Queue 任务队列ES6 中引入了一种新的 Job Queue 任务队列概念，也就是 Promise。提供了在条件到达后立刻执行被调用 function 的方法，而不是等待到 call stack 结束。当 Promise 定义的 resolve 条件满足时，会在当前 call stack 执行结束后立刻执行 resolve function。简单的区分 Message Queue 和 Job Queue：Message Queue 会将出现的每个任务按顺序排列到队列最后，等待排队执行。而 Job Queue 就像拿到了快捷车票，会在 stack 中的指令结束后立刻跳转到这个任务上来。下面是一个示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

//output:
//foo
//baz
//END
//should be right after baz, before bar
//bar以上示例可以看到，promise 定义之后会继续运行 stack 中接下来的常规指令，然后 promise 的 resolve 条件会立刻得到满足，此时异步任务会在 stack 中的任务执行结束后立刻被响应而不是排列到队列最后。理解 process.nextTick()上面我们介绍了 event loop 的相关概念，一次的 event loop 循环叫做一个 tick，注意此循环只包含常规 call stack 中的任务。当我们给 process.nextTick() 传递一个 function 时，就是告诉 engine 在本次循环 tick 结束下次循环开始前执行这个 function。语法如下：process.nextTick(() =&gt; {
  //do something
})当 call stack 中的任务执行完毕后，js engine 会优先查询是否在 nextTick 中定义了 function，如果有就会优先执行它们，然后是 Job Queue 的异步响应，最后才是 Message Queue 队列中的任务。请看下面的示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

process.nextTick(() =&gt; console.log(&quot;next tick&quot;));

//output:
//foo
//baz
//END
//next tick
//should be right after baz, before bar
//bar理解 setImmediate()setImmediate function 用来定义在下次 event loop 循环开始前执行的 function。语法如下：setImmediate(() =&gt; {
  //run something
})setImmediate() 和上面讲到的 setTimeout(() =&gt; {}, 0)，Promise，process.nextTick()，不同点是它是执行在下个循环中的，而其它几种都是属于当前循环的，所以它是最后被执行的。下面是一个包含这几种类型的异步任务的完整示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

process.nextTick(() =&gt; console.log(&quot;next tick&quot;));
setImmediate(() =&gt; console.log(&quot;immediate&quot;));

//output:
//foo
//baz
//END
//next tick
//should be right after baz, before bar
//bar
//immediatetimers 定时器setTimeout()当需要延时执行一个 function 时，可以使用 setTimeout function 实现。使用它定义需要延时执行的任务以及延时的具体时间，以毫秒为单位。示例如下：setTimeout(() =&gt; {
    console.log('delay 1s')
}, 1000);

console.log('start')以上示例会延时一秒输出对应信息。也可以传入预定义的 function 以及传递数据给 setTimeout：const test = (a, b) =&gt; console.log(a + b);
setTimeout(test, 2000, 1, 2);以上示例中，setTimeout 调用 test function，1 和 2 为 test 的传入数据。setTimeout 会返回一个 timer ID，你可以存储这个它，可以通过 id 清除对应的定时器以取消对应的计划任务：const t1 = setTimeout(() =&gt; {
    console.log('delay 1s')
}, 1000);
clearTimeout(t1);以上示例中由于通过 id 清除了 t1 定时器，所以任务不会被执行。一个特殊情况就是将延时设置为 0 也就是上一节介绍的内容，这是定义的任务会排列在 message queue 中并在本次循环结束后按顺序被执行。setInterval()setInterval 和 setTimeout 功能类似，但区别是 setInterval 会连续响应定义的任务，响应的间隔时间以毫秒为单位，在 setInterval 中自定义。下面是一个简单的示例：setInterval(() =&gt; {
    console.log('wow');
}, 500);程序运行后会每隔 500 毫秒连续输出信息。同样的通过 timer ID 使用 clearInterval 可以清除对应的 setInterval 定时任务：const t2 = setInterval(() =&gt; {
    console.log('wow');
}, 500);

setTimeout(() =&gt; {
    clearInterval(t2);
}, 2000);以上程序执行后，会每隔 500 毫秒输出 wow，两秒后停止输出。setInterval 会在指定的时间间隔下连续执行定义的 function 而不会考虑这个定义的 function 运行需要多少时间。如果这个 function 一直保持固定的执行时间，不会有什么问题：如果这个 function 在一些情况下执行时间大于设定的间隔时间，则前一个任务还没结束下一个任务已经要开始，就会造成冲突问题：为了避免这种情况发生，可以在需要连续调用的 function 执行结束时调用递归 setTimeout 来避免：const test2 = () =&gt; {
    console.log('wow');
    setTimeout(test2, 1000);
}

test2();以上示例中，我们在 function 定义中在指令结束后定义一个 setTimeout 调用其本身，这样可以实现连续对自身的调用且能保证每个任务都是被完整执行后才开始下一次执行的：Asynchronous and Callbacks 异步与响应在目前的电脑中，应用程序在特定的时间在占用系统资源运行任务，然后结束程序释放资源给其他程序使用。这个过程在以极快的速度循环进行着以至于我们以为这些程序在同时进行处理(多处理器设备除外)。程序内部通过 interrupts 中断：一个发送给处理器的信号，来获得系统的注意及时处理相关响应动作。这使得系统可以在某个任务等待回应过程中去处理其他事情，例如当程序在等待某个网络回应时，不能要求整个系统都停下来等待。通常情况下，编程语言都是默认以 synchronous 同步的方式执行代码的，部分编程语言提供了其他支持库的方式实现异步，或者通过多线程的方式支持异步。JavaScript 默认是同步和单线程模式，也就是说它不可以新建线程和平行运行。代码是按照编程顺序逐行执行的，如下示例：const a = 1
const b = 2
const c = a * b
console.log(c)但是 JavaScript 是诞生于浏览器的，它的主要工作就是响应用户的交互操作，如：onClick, onMouseOver, onChange, onSubmit 等。那么它如何在同步模式下实现上面的功能呢？答案就在他的运行环境中，浏览器提供了一系列的 APIs 来处理这些功能。node.js 引入了 non-blocking I/O 无阻塞 IO 的环境使得在此基础上扩展了文件访问，网络访问等的异步处理能力。你无法预知用户何时会点击了浏览器的一个按钮，所以我们就会提前定义一个 click event 的 event handler 事件处理器，这个 event handler 内需要定义一个 function，当事件被触发时会自动被调用。如下示例定义了一个 button 的 click event handler：document.getElementById('button').addEventListener('click', () =&gt; {});
这个响应过程叫做 callback。一个 callback 就是一个作为某个 function 的传入参数的 function，且只会在 event 被触发时才被执行。JavaScript 可以定义 first-class functions，能够以参数的形式传入其他 function，也叫 higher-order functions。通常情况，我们可以将客户端代码放在 window object 的 load event 中作为 callback function，这样就可以在页面加载完成后执行这部分代码：window.addEventListener('load', () =&gt; {
    //...
})callback 不止在浏览器的 DOM 结构下应用，一个常用的情景就是定时器：setTimeout(() =&gt; {
  // runs after 2 seconds
}, 2000)XHR 请求也会接受 callback，下面的示例中将一个 function 赋值给 XMLHttpRequest 的一个 property，当特定的 event 发生时会调用定义的 function：const XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
const xhr = new XMLHttpRequest();
xhr.onreadystatechange = () =&gt; {
    if (xhr.readyState == 4) {
        xhr.status == 200 ? console.log(xhr.responseText) : console.log('error');
    };
};
xhr.open('GET', 'https://niekun.net');
xhr.send();以上示例执行后，如果网址访问成功则会输出网页内容，否则输出 error。那么如何处理 callback 的 errors？通常情况下 node.js 接受的的策略是：将 callback function 的第一个参数作为 error object，叫做 error-first callbacks。当没有 error 时 object 为 null，当有 error 发生时，object 中会包含相关信息。下面是一个读取文件的示例：const fs = require('fs')
fs.readFile('./fs.json', (err, data) =&gt; {
    if (err !== null) {
        console.log('read error');
        return;
    }
    console.log(data.toString());
})在读取中有错误时 err 会包含错误信息。callback 在一般情况下使用很方便，但是每个 callback 相当于增加了一层嵌套层级，当你有很多个 callback 时就会产生多级嵌套，代码结构会越来越复杂。例如一下示例：window.addEventListener('load', () =&gt; {
  document.getElementById('button').addEventListener('click', () =&gt; {
    setTimeout(() =&gt; {
      items.forEach(item =&gt; {
        //your code here
      })
    }, 2000)
  })
})以上是一个四级嵌套，看起来已经比较复杂了，如果有更多的 callback 发生代码的结构会变得更加难以理解。Promise 异步从 ES6 开始 JavaScript 引入了多个处理异步代码的功能代替 callback 模式，包括：Promises (ES6) 和 Async/Await (ES2017)。promise 在我之前的 JavaScript 教程中做了介绍，参考：https://blog.niekun.net/archives/2011.html下面是一个 promise 的应用示例：let done = true;

const isItDoneYet = new Promise((resolve, reject) =&gt; {
    if (done) {
        const workDone = &quot;working done&quot;;
        resolve(workDone);
    } else {
        const why = 'still working on';
        reject(why);
    }
});

const checkIfDone = () =&gt; {
    isItDoneYet
    .then((ok =&gt; console.log(ok)), (err =&gt; console.log(err)))
}

checkIfDone();

//output:
//working doneresolve 和 reject function 也可以分别在 then 和 catch 中定义：const checkIfDone = () =&gt; {
    isItDoneYet
    .then(ok =&gt; console.log(ok))
    .catch(err =&gt; console.log(err))
}一个 promise 就是定义一个数据的 proxy 代理，这个数据会在后续中产生。promise 可以用来执行异步任务而不需要使用 callback。它在最近的 ES2017 更新中被进一步的整合为 async 和 await。理解 promise 的运行机制对于理解 async 和 await 很有必要。当调用一个 promise 时，它将保持在 pending 挂起状态，程序会继续执行下面的指令。在 promise pending 状态直到它有了 resolve 解决指令期间，可以提供其调用 function 需要的数据。创建的 promise 最终会在一个 resolved state 或 rejected state 状态下结束，并分别调用其 callback function：then 和 catch。promise API 提供了一个 constructor 构建器，通过 new Promise() 初始化。在上面的示例中，promise 判断参数 done 的值，如果为 true 则进入 resolved 状态(当 then 的 resolve 调用时)，如果为 false 则进入 rejected 状态(当 catch 调用时)。在没有调用 then 或 catch 时，promise 保持 pending 状态。通过 resolve 和 reject，我们可以和向前交流获取 promise 的状态结果，以及根据结果执行什么指令。这里我们只是简单的输出了一行字符串信息，也可以是一个 object 或 null 也可以。由于在此之前我们已经创建了 promise，所以它已经开始了执行，这对于理解 resuming a promise 继续执行 promise 很重要。一个常用的 promise 使用的技巧：Promisifying，定义一个包含 callback 的常规 function，callback 返回一个 promise，下面是一个示例：const fs = require('fs');

const getFile = (fileName) =&gt; {
    return new Promise((resolve, rejects) =&gt; {
        fs.readFile('./fs.json', (err, data) =&gt; {
            if (err) {
                rejects(err)
                return
            }
            resolve(data)
        })
    })
}

getFile(&quot;fs.json&quot;)
    .then(data =&gt; console.log(data.toString()))
    .catch(err =&gt; console.log(err))通过上面的介绍，我们知道了通过 new Promise() 命令可以创建一个 promise，然后根据实际条件执行 promise 的 resolve(then) 或 reject(catch) function。promises chain 链一个 promise 可以作为另一个 promise 的返回，可以组成一个 promises 链条。Fetch API 是介绍 promises 链很好的示例。它可以 fetch 获取一个资源，然后顺序执行一个 promises chain。fetch API 是基于 promise 的结构，调用 fetch() 就等同于通过 new Promise() 定义 promise。下面的是一个 promises 链示例，使用了 Fetch API：const fetch = require('node-fetch');

const status = response =&gt; {
    if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
        return Promise.resolve(response)
    }
    return Promise.reject(new Error(response.statusText))
}

const json = response =&gt; response.json() // return a promise

fetch('https://api.github.com/users/github') // return a promise, resolve is a response type
    .then(status) // use response as data and reture a promise
    .then(json) // use response as data convert to json and reture a promise
    .then(data =&gt; console.log('Request succeeded with JSON response', data)) // resolve call
    .catch(err =&gt; console.log('Request failed', err)) // if status promise call reject function, would call here以上程序的执行过程如下：使用 fetch 获取一个 url 的数据，然后返回一个 promise，resolve 时返回数据为一个 response，其中包含很多 properties，这里需要用到 status 和 statusText当 fetch 数据完成后我们调用 resolve 也就是 status function，status 使用 response 数据来判断并返回一个 promise，resolve 数据为 response 本身下一步当 status promise 调用 resolve 时会调用 json function，将 response 数据转换为 json 格式并返回一个 promise resolve 数据为 json 数据，如果 status 进入 reject 也就是 response 不正常，则会直接执行最后的 catch function 跳过前面的环节然后是数据的输出，当 json promise 调用 resolve 时会执行输出 data 数据在上面的示例中，我们在 promise 链的最后定义了一个 catch，当 promise 链中的任何一个 promise 失败然后 raise 一个 error 或者 reject，控制器会执行链中定义的最近的一个 catch。reject 或 raise error 都会触发 catch 部分，下面两种定义的 promise 语法都会进入 catch：new Promise((resolve, reject) =&gt; {
    throw new Error('error')
}).catch(err =&gt; console.log(err))

new Promise((resolve, reject) =&gt; {
    reject('error')
}).catch(err =&gt; console.log(err))也可以将 errors 级联，如果在 catch 中再次 throw 一个 error，可以再次附加一个 catch 来处理它：new Promise((resolve, reject) =&gt; {
    throw new Error('error')
})
.catch(err =&gt; {throw new Error('error')})
.catch(err =&gt; console.log(err))promises 顺序多个 promises 可以控制他们的响应顺序，使用 Promise.all() 可以定义一个 promise list 表，当 promises 都 resolve 时设置执行动作。请看下面的测试：const fetch = require('node-fetch');

const f1 = fetch('http://localhost/fs.json');
const f2 = fetch('http://localhost/fs2.json');

Promise.all([f1, f2])
.then(response =&gt; console.log(&quot;array of results&quot;, response))
.catch(err =&gt; console.log(err))返回的结果：array of results [
  Response {
    size: 0,
    timeout: 0,
    [Symbol(Body internals)]: { body: [PassThrough], disturbed: false, error: null },
    [Symbol(Response internals)]: {
      url: 'http://localhost/fs.json',
      status: 404,
      statusText: 'Not Found',
      headers: [Headers],
      counter: 0
    }
  },
  Response {
    size: 0,
    timeout: 0,
    [Symbol(Body internals)]: { body: [PassThrough], disturbed: false, error: null },
    [Symbol(Response internals)]: {
      url: 'http://localhost/fs2.json',
      status: 404,
      statusText: 'Not Found',
      headers: [Headers],
      counter: 0
    }
  }
]可以看到 response 是一个数组，包含了两个 promise 返回的数据且按数组定义的顺序排列。使用 ES6 的 object 拆解语法，上面示例也可以这样写：Promise.all([f1, f2])
.then(([response1, response2]) =&gt; console.log(&quot;array of results&quot;, response1, response2))
.catch(err =&gt; console.log(err))Promise.race()当 Promise.race() 中定义的 promises 数组中有第一个 resolve 的 promise 时，这个 promise 会运行 then 且只运行这一次，最终的状态就是那个 promise resolved 状态。下面是一个示例：const first = new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, 500, 'first');
})
const second = new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, 100, 'second');
})
Promise.race([first, second]).then(res =&gt; console.log(res))

//output:
//second上面的示例中，首先定义了两个 promise，当 resolve 时都是执行了一个定时器。先到达定时时间的 promise 将会执行 resolve 动作。async 和 awaitJavaScript 从 ES2015 才引入 promise 代替 callback，从 ES2017 开始 JavaScript 处理异步有了更加简化的语法：async/await。async functions 是 promise 和 generator 的结合。也即是说 async/await 是基于 promise 的。关于 promise 和 generator 的 JavaScript 语法可以参考：https://blog.niekun.net/archives/2011.htmlpromise 是为了处理异步而创造的，但随着使用场景的复杂化，它的劣势被凸显出来：语法臃肿，promise 链不能打断需要联系书写。于是便诞生了 async function。它可以让代码看起来像是同步代码，但在底层它是异步的且无 IO 阻塞问题。首先我们定义一个异步 promise：const doSomethingAsync = () =&gt; {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, 2000, 'i did something')
    })
}setTimeout 第三个参数是 resolve 的传入数据。当我们要调用这个 promise function 时使用关键词 await，然后 call 动作将会 pending 挂起状态直到 promise 被 resolved 或 rejected，注意在客户端代码中，需要使用 async 定义相关 function：const doSomething = async () =&gt; {
    console.log(await doSomethingAsync());
}
console.log('before')
doSomething()
console.log('after')

//output:
//before
//after
//i did something以上是一个简单的示例说明 async 的用法，await 后的 promise function 返回值是 resolve 或 reject 的数据。在 function 定义中使用 async 关键词意味着这个 function 返回值为 promise 类型，即使定义中没有明确定义返回类型，它依然会返回 promise。所以以下代码是有效的：const test = async () =&gt; {
    return 'test';
}
test().then(res =&gt; console.log(res))

//output:
//test以上的代码和下面的写法是一样的效果：const test = async () =&gt; {
    return Promise.resolve('test');
}
test().then(res =&gt; console.log(res))可以看到使用 async 后语法得到了简化易读，当代码很复杂时这一优势会更加明显，下面是使用 promise 语法读取 json 数据并拆解它的示例：const getFirstUserData = () =&gt; {
    return fetch('/js.json') // return a promise, resolve response data
        .then(response =&gt; response.json()) // reture a promise, resolve translate response data to json type
        .then(users =&gt; users[0]) // return a promise, resolve is first element in response array data
        .then(user =&gt; fetch(`/users/${user.name}`)) // use first element data to fetch new data and return response data when resolve
        .then(userResponse =&gt; userResponse.json()) // translate to json type and return it if resolve
}
getFirstUserData()下面使用 async/await 来实现上面的功能：const { default: fetch } = require(&quot;node-fetch&quot;)

const getFirstUserData = async () =&gt; {
    const response = await fetch('/js.json')
    const users = await response.json()
    const user = users[0]
    const userResponse = await fetch(`/users/${user.name}`)
    const userData = await userResponse.json()

    return userData;
}
getFirstUserData()多个 async function 组合使用async function 可以很方便的组成 chain 链，且语法相比较 promise 更加易读。下面是一个多个 async function 组合使用的示例：const promiseToDoSomething = () =&gt; {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, 2000, 'i did something')
    })
}

const watchSomeoneDoingSomething = async () =&gt; {
    const something = await promiseToDoSomething()
    return something + '\nand i watched'
}

const watchSomeoneWatchingSomeoneDoingSomething = async () =&gt; {
    const something = await watchSomeoneDoingSomething()
    return something + '\nand i watched as well'
}

watchSomeoneWatchingSomeoneDoingSomething().then(res =&gt; console.log(res))

//output:
//i did something
//and i watched
//and i watched as wellasync/await function 看起来就像是同步代码，这样调试起来非常方便。Event emitter 事件触发器如果在浏览器端开发过 JavaScript，你肯定了解用户通过 events 事件来实现交互，如：鼠标点击，键盘按键，鼠标移动等。在后端，node.js 通过 events module 可以建立一个小型系统来处理 events 事件。通常使用 EventEmitter class，下面是初始化 events 的方法：const EventEmitter = require('events')
const eventEmitter = new EventEmitter()此时 eventEmitter object 有很多 properties，其中最常用的就是 on 和 emit method：on 用来定义一个 event 事件，同时定义一个 callback function，当 event 触发后被执行emit 用来触发某个 event 事件下面我们创建一个 start event：eventEmitter.on('start', () =&gt; console.log('started'))然后触发 start：eventEmitter.emit('start')

//output:
//start可以给 event 传递参数，在 callback 时使用：eventEmitter.on('test1', par =&gt; console.log('started', par))
eventEmitter.emit('test1', 'wow')

//output:
//started wow当然也可以给 event 传递多个数据：eventEmitter.on('test2', (a, b) =&gt; console.log(`started from ${a} to ${b}`))
eventEmitter.emit('test2', 1, 200)

//output:
//started from 1 to 200EventEmitter object 同样有很多其他实用 method 来实现交互，例如：once(): 添加一个一次性的 event 事件监听器，只会被触发一次removeListener() / off(): 删除某个已定义的 event 监听器removeAllListeners(): 删除所有的 event 监听器更多关于 events module 的用法参考：https://nodejs.org/api/events.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2103.html">
<title>Windows 10 配置共享文件夹</title>
<link>https://blog.niekun.net/archives/2103.html</link>
<dc:date>2021-02-03T10:28:00+08:00</dc:date>
<description>最近研究了下 Windows 的共享设置，目的是在同一局域网下共享文件夹给其他设备读写。下面从原理和实际操作上介绍下共享过程。SMBWindows 共享使用 Server Message Block (SMB) 协议，它可以让应用程序访问本机网络下的其他设备的文件及服务。SMB 是 IBM 在 1980 年代创造的协议，目前已经有了很多的升级及分支。SMB 协议允许应用程序访问远程主机的文件和资源如打印机等，也可以同远程主机上设置了接收 SMB 协议的应用程序通信。它运行在网络的 layer 7 层，也就是 application 应用层，使用 TCP/IP 的 445 端口传输数据。从 Windows 95 开始，微软将引入了 SMB 协议的支持。Linux 端，samba 作为一个开源软件提供 SMB 的支持。SMB 协议也是在不断发展的，下面是一个简单的版本更新过程：SMB 1.0 (1984): IBM 为 DOS 下的文件共享创造了 SMBCIFS (1996): 微软开发了 SMB 的分支版本并集成在 Windows 95，添加了大文件的支持，直接在 TCP/IP 传输SMB 2.0 (2006): 在 Windows Vista 和 Windows Server 2008 中发布. 提升了性能SMB 2.1 (2010): 在 Windows Server 2008 R2 和 Windows 7 中发布SMB 3.0 (2012): 在 Windows 8 和 Windows Server 2012 中发布. 提升了性能，增加备份，安全和管理功能SMB 3.02 (2014): 在 Windows 8.1 和 Windows Server 2012 R2 中发布. 提升性能并完全停止支持 CIFS/SMB 1.0SMB 3.1.1 (2015): 在 Windows 10 和 Windows Server 2016 中发布在 2017 年，利用 SMB 1.0 的漏洞，WannaCry 勒索软件在互联网中大规模传播，微软虽然立刻发布了补丁，但专家还是建议立刻停止运行 SMB 1.0 协议。Windows 设置共享下面介绍在 Windows 10 中配置共享文件夹。首先打开控制面板，进入 network and Internet：点击 network and sharing center：点击 change advanced sharing settings：在 current profile 中打开网络发现和文件共享：然后在 all network 中关闭密码保护(否则在其他设备访问时会提示输入账户密码)：控制面板配置完成后，我们开始配置需要共享的文件夹。在需要共享的文件夹上点击右键，选择属性：在 share 选项卡中点击 share：在下拉菜单中选择 everyone，然后点击 add：修改此文件夹的读写权限，我这里设置读和写：点击 share 开启共享：返回属性栏，点击 advanced share：选中 share this folder：点击 permission：设置共享权限，我这里设置为可读写：确认后共享文件夹就配置完成了。访问共享文件下面介绍在其他局域网设备访问主机的共享文件夹。Windows在 Windows 上，打开 file explorer，点击 network：在右侧就是本地网络下启用了网络发现的设备列表，点击进入设置了共享文件夹的设备名称就可以访问了：也可以在地址栏直接输入共享路径地址，以双反斜线\\开头后面是设备 IP 或名称，如：\\DESKTOP-BS3C55D。关于设备的名称，可以在终端通过 whoami 命令查询：iPhone在支持 SMB 协议的设备或应用程序中都可以打开 Windows 共享的文件，下面介绍通过 iPhone 的 files app 来连接到 Windows 共享目录。打开 files app，点击右上角的 ... 选择 connect to server：在 server 中输入共享主机的地址，这里直接输入 IP 地址：选择 guest 点击 next：完成后就可以访问到共享目录了：如果文件夹设置的是可读写权限，就可以在手机上传输文件到共享目录了。参考链接：Server Message Block Protocol (SMB protocol)</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2098.html">
<title>解除 UWP 应用的网络隔离</title>
<link>https://blog.niekun.net/archives/2098.html</link>
<dc:date>2021-02-02T09:33:00+08:00</dc:date>
<description>Microsoft store 里都是 UWP 应用，运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。该机制也阻止了 UWP 应用访问 localhost，如果你的代理地址在本地地址，UWP 就无法访问。有两种方法来解除某个 UWP 应用的沙盒隔离，一种是使用系统自带的工具 CheckNetIsolation，一种是使用第三方工具 fiddler。CheckNetIsolationWindows 10 自带了一个 CheckNetIsolation 工具，可以解除 UWP 应用的网络隔离，使之可以正常访问本地地址在终端执行以下指令即可：CheckNetIsolation.exe loopbackexempt -a -p=SID
SID(security identifier) 是每个 UWP 应用独有的识别码，可以从注册表中获得应用的 SID 码。快捷键 win + R 打开运行窗口，输入 regedit 进入注册表。访问如下路径：\HKEY_CURRENT_USER\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\：此路径下的左侧文件夹名称就是当前安装的每个 UWP 应用的 SID 码，右侧的 DisplayName 就是应用的名称，可以用来帮助找到需要的应用 SID。复制需要解除隔离的应用的 SID 码执行上面的命令即可。然后应用就可以正常访问本地地址了，也可以使用抓包工具获取到流量。fiddler也可以使用第三方软件来实现以上任务，这里介绍 fiddler。fiddler 是一款免费的网络调试代理工具。官网地址：https://www.telerik.com/fiddler下载安装后打开应用，点击左上角的 WinConfig：会弹出所有 UWP 应用列表，找到需要解除隔离的应用，点击左侧的选择框，然后点击 save change 即可：此时再次运行对应的应用，就可以在 fiddler 看到应用的流量信息了。注意 fiddler 需要一直保持开启状态解除隔离才会生效。使用 fiddler 还可以方便的设置代理服务，使选中的应用通过代理访问网络，点击 tools - options：在弹出栏中，点击 gateway，选择 manual proxy configuration：第一行设置代理地址，模式为：proxyserver:8080
也可以根据网络协议设置：http=httpproxy:8080;https=httpsproxy:8080
第二行设置 bypass 忽略列表，可以设置忽略代理本地地址或其他需要排除的地址：&lt;local&gt;;*.extranet.example.com;
点击 ok 保存后即可，此时在 WinConfig 中选中的 UWP 应用就会通过代理地址访问网络。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2086.html">
<title>创建新文件 in Linux</title>
<link>https://blog.niekun.net/archives/2086.html</link>
<dc:date>2021-01-28T08:17:25+08:00</dc:date>
<description>下面介绍几种常用的命令行创建新文件的方法。touch：touch test1.txt
&gt;:&gt; test2.txt
cat:cat /dev/null &gt; test3.txt
echo:echo &gt; test4.txt
vim:vim test5.txt
:wq
使用中选择最简单的方式即可。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2085.html">
<title>node.js 入门教程之三 -- npm</title>
<link>https://blog.niekun.net/archives/2085.html</link>
<dc:date>2021-01-26T15:45:00+08:00</dc:date>
<description>调用 node.js 文件node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。语法如下：const library = require('./libs')和导入其他第三方模块类似使用 require 指令，需要指定 node.js 文件路径。以上示例表示导入当前目录下的 libs.js 文件。js 文件中默认定义的 objects 等元素是私有的，不能够被外部使用。在被导入的文件中，需要在引用前 expose 暴漏出需要被外部使用的功能。需要使用到 module system 的 module.exports API 来实现。当给一个 object 或 function 赋予 exports 属性时，就表明这些元素可以暴漏给外部。有两种方法来实现。第一种方法是将某个 object 直接赋值给 module.exports，module.exports 是 module system 的一个 object 用来将某个 object 暴漏出来，且只能在一个文件中赋值给某一个元素，下面是一个示例：libs.js 文件：const person = {
    name: 'marco',
    age: 20
}

module.exports = person;main.js 文件：const libs = require('./libs');

console.log(libs.age);

//OUTPUT:
//20上面示例中，我们将 libs.js 文件的 person object 赋值给了 module.exports，在 main.js 中调用 libs.js 文件后，main.js 中的 libs object 就相当于 person object。我们可以发现，这种定义方法可以将某个 node.js 文件中的一个 object 暴漏给外部使用。第二种方法是将需要暴漏的元素定义为 exports 的 properties，这种方式可以将多个 objects 或 function 暴漏给外部。libs.js 文件：const person = {
    name: 'marco',
    age: 20
}
exports.person = person;

exports.car = {
    brand: 'bmw',
    color: 'red'
}main.js 文件：const libs = require('./libs');

console.log(libs.person.age);
console.log(libs.car.brand);

//OUTPUT:
//20
//bmw以上示例中，我们先在 libs.js 中定义了两个 object，并都作为 exports 的一个 property，可以看到有两种方式定义。在 main.js 中调用后，通过调用 libs object 对应的 properties 名称即可调用对应暴露的元素。npm 包管理器npm 是 node.js 的标准包管理器。一开始，npm 作为下载和管理 node.js 包的依赖的工具，现在也成为了 JavaScript 前端开发工具。下载包如果项目中有 package.json 文件，可以通过下面指令自动安装所有在文件中定义的模块，安装路径为 node_modules 文件夹内：npm install
安装某一个模块包：npm install &lt;package-name&gt;
在项目中安装的包会自动添加条目到 package.json 文件中。也可以在安装时使用 --save 选项来添加到文件。更新包更新项目中所有包：npm update
更新某一个包：npm update &lt;package-name&gt;
执行任务package.json 文件内支持定义指定的命令行指令，通过下面的语法来执行：npm run &lt;task-name&gt;
指令定义在 scripts 块内，例如：{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;
  }
}此时我们在终端执行下面命令：$ npm run start
Debugger attached.

&gt; start
&gt; uname -r

5.8.0-38-generic
Waiting for the debugger to disconnect...可以看到通过 run 定义命令的名称就可以执行对应的命令。包安装路径当使用 npm 安装包时，可以定义两种安装模式：local install 逻辑安装global install 全局安装默认情况下当我们使用下面指令安装包：npm install chalk
包会安装到当前项目路径下的 node_modules 文件夹内。此时 npm 会将对应包的信息写入 package.json 文件内的 dependencies 块内，如：{
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }
}全局安装通过 -g 标记实现：npm install -g chalk
使用全局安装模式时，npm 不会将包安装到项目路径下，而是 global location 路径下。通过 npm root -g 命令可以返回 golbal 路径的地址，Linux 默认地址为：/usr/local/lib/node_modules，Windows 默认地址为：C:\Users\YOU\AppData\Roaming\npm\node_modules。可执行程序当安装一个包后，我们通过 require 关键词来调用模块：const inquirer = require('inquirer')
当安装的包是可执行程序的时候呢？当安装的包含有可执行程序时，程序会放在 node_modules/.bin/ 文件夹内，关于如何运行这些可执行程序，我们通过 cowsay 包来演示。首先安装 cowsay，这里安装到 global 路径下：npm install -g cowsay
我的 global 路径地址为：/opt/node-v15.5.1-linux-x64/lib/node_modules，可执行文件被安装在 /opt/node-v15.5.1-linux-x64/bin/ 目录下：cowsay -&gt; ../lib/node_modules/cowsay/cli.js查看属性可以看到此可执行文件是指向 cli.js 的一个链接。通过 npx 命令可以方便的执行此程序，不需要提供程序所在路径：$ npx cowsay wow
 _____
&lt; wow &gt;
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||package.json 文件package.json 文件是其项目的一个声明，它可以用来做一些完全没有关联的事情。例如，它是配置工具的仓库，也存储着 npm 安装的包的版本信息。下面是最简单的文件形式：{}
文件需要遵守 json 格式，否则无法被程序读取其定义的内容。没有什么内容是必须的，所以可以是一个简单的大括号。如果你要做一个通过 npm 分享的 node.js 包，那么 package.json 文件需要定义一些必须的属性以供了解这个包的信息，后面会做详细介绍。下面是另一个示例：{
  &quot;name&quot;: &quot;test-node&quot;
}以上定义了一个 name property，定义了这个 app 或 package 的名称。文件和项目文件在同一文件夹下。下面是一个更加复杂的示例：{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A Vue.js project&quot;,
  &quot;main&quot;: &quot;src/main.js&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
    &quot;test&quot;: &quot;npm run unit&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
    &quot;babel-core&quot;: &quot;^6.22.1&quot;,
    &quot;babel-eslint&quot;: &quot;^8.2.1&quot;,
    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,
    &quot;babel-jest&quot;: &quot;^21.0.2&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;,
    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,
    &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.0.1&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.15.0&quot;,
    &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
    &quot;file-loader&quot;: &quot;^1.1.4&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;jest&quot;: &quot;^22.0.4&quot;,
    &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;,
    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;portfinder&quot;: &quot;^1.0.13&quot;,
    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,
    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,
    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
    &quot;vue-jest&quot;: &quot;^1.0.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
}包含了很多的属性设置：version 表示当前版本号name 设置包名称description 对 app 简要的描述main 设置 app 的入口文件private 如果设置为 true 可以防止包被无意的发布到 npmscripts 定义可以运行的脚本命令dependencies npm 依赖包列表devDependencies 定义开发使用的 npm 包列表engines 设置 app 运行的 node 版本browserslist 指定支持的浏览器版本以上所有的属性都可以被 npm 或其他工具使用。常用属性下面介绍一些常规使用的属性，包括你在本地开发的项目也可以使用。name 定义app 名称：&quot;name&quot;: &quot;test-project&quot;
name 必须小于 214 个字符，不能含有空格，只能包含小写字母，横杠- 或下划线_。如果将包发布到 npm，会生成一个独有的链接。author 定义作者信息：&quot;author&quot;: &quot;marco &lt;me@niekun.net&gt; (https://niekun.net)&quot;
或者：  &quot;author&quot;: {
    &quot;name&quot;: &quot;marco&quot;,
    &quot;email&quot;: &quot;me@niekun.net&quot;,
    &quot;url&quot;: &quot;https://niekun.net&quot;
  }contributors 定义代码贡献者信息，可以包含多人：  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;marco&quot;,
      &quot;email&quot;: &quot;me@niekun.net&quot;,
      &quot;url&quot;: &quot;https://niekun.net&quot;
    }
  ]bugs 定义反馈 bug 的链接，一般是 GitHub issue 页面：&quot;bugs&quot;: &quot;https://github.com/whatever/package/issues&quot;
homepage 定义包的主页链接：&quot;homepage&quot;: &quot;https://whatever.com/package&quot;
version 定义当前包的版本：&quot;version&quot;: &quot;1.0.0&quot;
此属性遵守 semantic versioning (semver) notation 语义版本标记语法。也就是由三个数字表示：x.x.xlicense 定义包的授权信息：&quot;license&quot;: &quot;MIT&quot;
keywords 定义关于这个包实现功能的关键词，是一个数组：  &quot;keywords&quot;: [
    &quot;learning&quot;,
    &quot;nodejs&quot;
  ]使用 keywords 可以帮助别人找到你的包，或者在 https://www.npmjs.com/ 网站上搜索关键词。description 定义一个对此 app 的简短描述：&quot;description&quot;: &quot;a node.js beginner guide&quot;
repository 定义项目仓库地址：&quot;repository&quot;: &quot;github:whatever/node-project&quot;
注意如果不是使用的 GitHub 也可以定义其他工具：&quot;repository&quot;: &quot;gitlab:whatever/node-project&quot;
也可以明确的定义版本控制系统信息：  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/whatever/testing.git&quot;
  }main 设置包的入口：&quot;main&quot;: &quot;./main.js&quot;
private 如果设置为 true，可以防止包被无意的发布到 npm：&quot;private&quot;: &quot;true&quot;
scripts 定义可执行的 node 脚本：  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;,
    &quot;test&quot;: &quot;echo abcd&quot;
  }定义的脚本是命令行程序，通过 npm run xxx 执行，如：npm run start
dependencies 定义 app 需要安装的 npm 依赖包：  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }当通过 npm install &lt;PACKAGENAME&gt; 安装包，会自动将包写入 package.json 文件的 dependencies 块。devDependencies 定义 app 开发需要的 npm 依赖包：&quot;devDependencies&quot;: {
  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
  &quot;babel-core&quot;: &quot;^6.22.1&quot;
}和 dependencies 的区别是这里定义的包只是在开发设备上安装，而不需要在执行设备上安装。开发包通过以下命令安装：npm install --save-dev &lt;PACKAGENAME&gt;
engines 设置此包运行的 node 版本和其他命令版本：  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;=3.0.0&quot;
  }browserslist 定义 app 支持的浏览器版本：&quot;browserslist&quot;: [
  &quot;&gt; 1%&quot;,
  &quot;last 2 versions&quot;,
  &quot;not ie &lt;= 8&quot;
]以上定义的意义是：支持所有类型浏览器的最近两个版本且需要至少有 1% 的占有率，不包括小于等于 IE8 版本的浏览器。浏览器占有率信息来自于 https://caniuse.com/ 统计。依赖包版本信息在 dependencies 和 devDependencies 中定义了依赖包列表，每个包都定义了版本信息，如：^0.13.0 或 ~3.0.0，通过版本号前的符号可以们定义接受那些版本的升级，下面介绍版本标记的用法：无标记，如 1.0.0 定义只安装此版本的包latest 定义安装最新版本的包^ 只能升级到不改变最左边第一个非零数字的版本，如定义 ^0.13.0，通过 npm update 可以升级到 0.13.1 或 0.13.2，但不能升级到 0.14.0，定义 ^1.13.0，能够升级到 1.13.1 或 1.14.0，不能升级到 2.0.0~ 只能升级最后一位数字变化的版本，如 定义 ~1.13.0，能够升级到 1.13.1，但不能升级到 1.14.0&gt; 接受大于定义的版本号的更新&gt;= 接受大于等于定义的版本号的更新&lt; 接受小于定义的版本号的更新&lt;= 接受小于等于定义的版本号的更新- 设置一个版本范围，如：1.0.0 - 2.0.0|| 组合设置，如：&lt; 2.0.0 || &gt; 3.0.0更加详细的定义方法参考：https://nodejs.dev/learn/semantic-versioning-using-npmpackage-lock.json 文件在 npm 5 版本中 npm 引入了 package-lock.json 文件。前面介绍了 package.json 文件，它是一个通用的被广泛使用的配置文件。package-lock.json 文件的目的是更加确切的追踪安装的依赖包的版本，以用来 100% 复制开发者的安装环境到其他安装者设备上，即使某些包已经够了更新版本。这解决了一个 package.json 遗留的问题，在 package.json 中你可以定义某个包可接受的版本升级范围，版本格式遵守 semantic versioning (semver) notation 语义版本标记语法，例如：~1.13.1 可以升级到 1.13.2，但不可以升级到 1.14.0^1.13.1 可以升级到 1.14.0，但不能升级到 2.0.01.13.1 只能安装 1.13.1 版本，不能升级到其他任何版本你发布的包中并不包含开发环境中的  node_modules 文件夹因为它占用空间很大。当在其他设备中通过 npm install  命令安装依赖包时，竟会遵循上面定义的版本范围安装支持的最新版本到设备中，这就会导致用户安装的版本和你开发环境的版本不一致，可能导致 bug 的出现。package-lock.json 中定义了你当前开发环境安装的各种依赖包的准确版本，这样通过 npm install 命令安装的就是其中定义的准确版本。这一概念并不是 npm 独创的，其他编程语言也在使用类似的模式，如 php 的 Composer。package-lock.json 文件需要打包在仓库中，以供其他人使用。当使用 npm update 更新包时，package-lock.json 中的定义也会同步更新。下面是一个 package-lock.json 文件的示例，当我们执行 npm install cowsay 时，会创建以下内容：{
  &quot;requires&quot;: true,
  &quot;lockfileVersion&quot;: 1,
  &quot;dependencies&quot;: {
    &quot;ansi-regex&quot;: {
      &quot;version&quot;: &quot;3.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=&quot;
    },
    &quot;cowsay&quot;: {
      &quot;version&quot;: &quot;1.3.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz&quot;
,
      &quot;integrity&quot;: &quot;sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==&quot;,
      &quot;requires&quot;: {
        &quot;get-stdin&quot;: &quot;^5.0.1&quot;,
        &quot;optimist&quot;: &quot;~0.6.1&quot;,
        &quot;string-width&quot;: &quot;~2.1.1&quot;,
        &quot;strip-eof&quot;: &quot;^1.0.0&quot;
      }
    },
    &quot;get-stdin&quot;: {
      &quot;version&quot;: &quot;5.0.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g=&quot;
    },
    &quot;is-fullwidth-code-point&quot;: {
      &quot;version&quot;: &quot;2.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=&quot;
    },
    &quot;minimist&quot;: {
      &quot;version&quot;: &quot;0.0.10&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8=&quot;
    },
    &quot;optimist&quot;: {
      &quot;version&quot;: &quot;0.6.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-2j6nRob6IaGaERwybpDrFaAZZoY=&quot;,

      &quot;requires&quot;: {
        &quot;minimist&quot;: &quot;~0.0.1&quot;,
        &quot;wordwrap&quot;: &quot;~0.0.2&quot;
      }
    },
    &quot;string-width&quot;: {
      &quot;version&quot;: &quot;2.1.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==&quot;,
      &quot;requires&quot;: {
        &quot;is-fullwidth-code-point&quot;: &quot;^2.0.0&quot;,
        &quot;strip-ansi&quot;: &quot;^4.0.0&quot;
      }
    },
    &quot;strip-ansi&quot;: {
      &quot;version&quot;: &quot;4.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-qEeQIusaw2iocTibY1JixQXuNo8=&quot;,
      &quot;requires&quot;: {
        &quot;ansi-regex&quot;: &quot;^3.0.0&quot;
      }
    },
    &quot;strip-eof&quot;: {
      &quot;version&quot;: &quot;1.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=&quot;
    },
    &quot;wordwrap&quot;: {
      &quot;version&quot;: &quot;0.0.3&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o9XabNXAvAAI03I0u68b7WMFkQc=&quot;
    }
  }
}我们安装的 cowsay 有如下依赖，它们会被自动安装：get-stdinoptimiststring-widthstrip-eof以上的依赖包可能也会有它们各自的其他依赖包，会自动安装相关其他包，每个包的依赖包在 requires 属性中定义。所有的包以字母排序顺序在文件中。每个包都有 version 属性定义了各自当前安装的版本，resolved 定义了包地址，integrity 字符串用来验证包。包版本管理及安装下面的指令查询当前安装的所有包及其依赖包：npm list
输出信息示例：❯ npm list
/Users/joe/dev/node/cowsay
└─┬ cowsay@1.3.1
  ├── get-stdin@5.0.1
  ├─┬ optimist@0.6.1
  │ ├── minimist@0.0.10
  │ └── wordwrap@0.0.3
  ├─┬ string-width@2.1.1
  │ ├── is-fullwidth-code-point@2.0.0
  │ └─┬ strip-ansi@4.0.0
  │   └── ansi-regex@3.0.0
  └── strip-eof@1.0.0当然也可以直接打开 package-lock.json 文件查看，但这样不太方便观察结构。npm list -g 用来查看 global 安装的包。如果只想查询顶层的包，也就是你主动通过 npm install 安装的那些包，可通过 npm list --depth=0 查询：❯ npm list --depth=0
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1也可以单独查询某个包：❯ npm list cowsay
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1使用下面命令查询某个包当前发布的最新版本：❯ npm view cowsay version
1.4.0要安装某个包的特定版本需要加上 @ 标记：npm install cowsay@1.2.0
查看某个包的所有历史版本列表：$ npm view cowsay versions
[
  '1.0.0', '1.0.1', '1.0.2',
  '1.0.3', '1.1.0', '1.1.1',
  '1.1.2', '1.1.3', '1.1.4',
  '1.1.5', '1.1.6', '1.1.7',
  '1.1.8', '1.1.9', '1.2.0',
  '1.2.1', '1.3.0', '1.3.1',
  '1.4.0'
]通过 npm update 可以更新所有已安装的包，更新版本规则遵循 package.json 定义的版本升级范围，同时会更新 package-lock.json 文件内的当前包版本信息。想要查询当前有哪些包有更新版本时，可以执行 npm outdated 命令：其中有些更新是大版本更新， npm update 并不会更新到这些大版本，因为这些更新可能包含有重大的变化。如果要强制更新到最新的版本包括大版本更新，可以按顺序执行下面的命令：npm install -g npm-check-updates
ncu -u
npm update使用下面命令卸载某个包：npm uninstall &lt;package-name&gt;
添加 -S 或 --save 标记删除 package.json 中的相关信息。如果要删除的包是一个开发包，在 devDependencies 中定义过，则需要添加 -D 或 --save-dev 标记来删除相关信息：npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;如果包是 global 安装的，则卸载需要添加 -g 标记：npm uninstall -g &lt;package-name&gt;
npm local 和 global 安装本地包和全局包的区别是本地包通过 npm install 安装到当前项目下的 node_modules 文件夹内，全局包通过 npm install -g 安装到系统路径下，路径地址可通过 npm root -g 查询。在程序中，只能 require 本地包：require('package-name')
通常情况下推荐所有的包都以本地模式安装。这可以让不同的程序使用各自不同版本的包。更新一个全局包会同时影响所有使用这个包的 app。当一个包含有可执行程序时，应该安装为 global 全局包。这样所有的项目都可以调用执行。npm dependencies 和 devDependencies当通过 npm intall 安装包时，表示将包作为 dependency。包信息会自动写入 package.json 文件的 dependencies 块内。当安装时添加 -D 标记，表示将包作为 devdependency 安装。包信息会自动写入 devDependencies 块内。开发包的目的是用来开发程序时使用，作为产品运行时是不需要的。执行 npm install 会默认安装这些开发包。如果不需要安装开发包需要加上 --production 标记：npm install --production xxx
npx 包运行器npx 可以用来运行 node.js 程序。node.js 开发者通常将大部分含有可执行程序的包作为 global 包发布，这样就使得可执行程序在系统 PATH 路径下可以被直接执行。但这样的弊端就是不能安装不同版本的包。使用 npx 命令可以自动寻找 node_modules 文件夹内的对应的名称的可执行程序，而不需要知道程序具体的路径，也不需要以 global 方式安装包。npx 另一个很好的功能是可以直接运行某些命令而不需要提前安装它们，还可以通过 @ 标记来执行不同版本的同一命令。cowsay 是一个很好的示例来说明 npx 的使用，如果我们以 global 模式安装 cowsay，可以通过下面方式执行：cowsay &quot;wow&quot;
以上命令只有通过 global 方式安装才能够正常执行，否则会报错提示命令不存在。如果以 local 方式安装 cowsay，可以通过 npx 执行：npx cowsay &quot;Hello&quot;
通过 @ 标记来执行不同版本的命令：npx node@10 -v #v10.18.1
npx node@12 -v #v12.14.1npm 也可以直接执行来自 url 的任意代码片段，而不仅限于 npm 官方渠道发布的包。下面示例是执行部署在 glist 的包：npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
可执行程序路径定义在 package.json 文件的 bin 属性内。glist 包含内容如下：当然执行不受控制网络的代码需要多加注意。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2074.html">
<title>服务器部署 WebDAV 服务</title>
<link>https://blog.niekun.net/archives/2074.html</link>
<dc:date>2021-01-22T11:16:00+08:00</dc:date>
<description>WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。简单说 webdav 就像一个网盘，可以远程访问他的目录名对其文件进行读写操作。WebDAV 允许客户端进行下列操作：处理服务器上 WebDAV 发布目录中的资源具有正确权限的用户可以在 WebDAV目录中复制和移动文件修改与某些资源相关联的属性。例如，用户可写入并检索文件的属性信息锁定并解锁资源以便多个用户可同时读取一个文件。但每次只能有一个人修改文件搜索 WebDAV 目录中的文件的内容和属性下面介绍如何在服务器上部署 WebDAV 服务。这里通过 nginx 来代理。编译 nginx我们通过 nginx 来代理 webdav 服务，nginx 自带有 ngx_http_dav_module 模块，但是其不支持一些 webdav 的 method 如：PROPFIND, OPTIONS, LOCK, UNLOCK。可以通过第三方模块来完整支持 webdav 的特性。下载以下两个第三方模块：nginx-dav-ext-module：https://github.com/arut/nginx-dav-ext-moduleheaders-more-nginx-module：https://github.com/openresty/headers-more-nginx-module以上两个模块需要在编译时通过 --add-module 参数来引入模块，同时需要包含 --with-http_dav_module 模块，否则编译会报错。从源码编译 nginx 参考我之前的教程：https://blog.niekun.net/archives/30.html我使用的完整的编译参数如下：./configure --prefix=/opt/nginx-1.19.6 \
--user=nginx --group=nginx \
--with-compat --with-file-aio --with-threads \
--with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module \
--with-mail --with-mail_ssl_module \
--with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module \
--add-module=../echo-nginx-module \
--add-module=../ngx-fancyindex \
--add-module=../headers-more-nginx-module \
--add-module=../nginx-dav-ext-module配置文件nginx 编译安装完成后，需要配置 conf 文件来使 webdav 生效。我提前已经设置了一个单独的子域名来访问 webdav 服务，且使用 ssl 加密。首先建立 webdav 文件夹并设置正确的权限，否则在读写时会提示权限不足：mkdir /home/www/webdav
chown -R www-data:www-data /home/www/webdav如果想要限制用户访问，可以使用 ngx_http_auth_basic_module 模块来建立账号访问，具体参考：https://blog.niekun.net/archives/730.html完整配置文件如下：dav_ext_lock_zone zone=foo:10m;
server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   webdav.xxx.xxx;
    include       my-server/ssl;

    # 限制访问
    auth_basic           &quot;Restricted Access&quot;;
    auth_basic_user_file ../users/.adminpasswd;

    # webdav 目录
    root /home/www/webdav;
    client_body_temp_path /opt/nginx/client_body_temp;

    # webdav 设置
    dav_access      user:rw  group:rw  all:r;
    dav_methods PUT DELETE MKCOL COPY MOVE;
    dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;
    dav_ext_lock zone=foo;
    create_full_put_path on;

    # 优化大文件上传
    send_timeout 3600;
    client_body_timeout 3600;
    keepalive_timeout 3600;
    lingering_timeout 3600;
    client_max_body_size 2G;

    location / {
        # 创建文件夹操作时结尾添加斜杠
        if ($request_method = MKCOL) {
            rewrite ^(.*[^/])$ $1/ break;
        }

        # 移动文件夹操作时结尾添加斜杠
        if (-d $request_filename) {
            rewrite ^(.*[^/])$ $1/;
            set $md /;
        }

        set $x $http_destination$request_method;
        if ($x ~ [^/]MOVE) {
            more_set_input_headers -r &quot;Destination: ${http_destination}${md}&quot;;
        }
    }

    # 拒绝 Windows 或 macos 多余文件上传到 webdav 路径
    location ~ \.(_.*|DS_Store|Spotlight-V100|TemporaryItems|Trashes|hidden|localized)$ {
        access_log  off;
        error_log   off;

        if ($request_method = PUT) {
            return 403;
        }
        return 404;
    }

    location ~ \.metadata_never_index$ {
        return 200 &quot;Don't index this drive, Finder!&quot;;
    }
}注意第一句 dav_ext_lock_zone 要放在 http 块内。否则会报错。配置文件修改好后，使用下面指令测试配置是否正确：nginx -t
如果返回 ok 重启服务即可：systemctl restart nginx
客户端连接nginx 配置好 webdav 模块并启动后，可以尝试在客户端访问。Windows 的 file explorer 和 macos 的 finder 都可以直接连接 webdav。Windows 端在 file explorer 中点击 home - easy access - map as drive：在弹出窗口中点击 connect to a web site：点击 next 在地址栏输入服务器 nginx 定义的 webdav 访问地址：点击 next 后如果设置了 auth_basic 会提示要求输入账户和密码，输入账户密码后就进入了 webdav 目录了，下面就可以测试新建文件，修改文件等操作。注意 Windows 中默认只有 https 方式访问的地址才可以设置 auth，否则不会弹出输入账户和密码的提示框，而是直接提示无法访问此地址。如果想要开放 http 方式的 auth 验证，需要修改注册表 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel 的值为 2，然后重启系统即可，此键值定义为：0 - Basic authentication disabled1 - Basic authentication enabled for SSL shares only2 or greater - Basic authentication enabled for SSL shares and for non-SSL sharesmacos 端参考链接：Making Native WebDAV Actually Work on nginx with Finder and ExplorerNginx repair of WebDAV functionalityModule ngx_http_dav_moduleUsing Basic Authentication with Windows 7 and Windows Vista WebDAV Client</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2071.html">
<title>修复 ubuntu vmware 虚拟机无法访问主机共享目录</title>
<link>https://blog.niekun.net/archives/2071.html</link>
<dc:date>2021-01-15T16:32:00+08:00</dc:date>
<description>今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 /mnt/hgfs 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载即可。首先查看当前设置的共享目录有哪些：$ vmware-hgfsclient 
Development
Downloads
InstallationPackage挂载主机共享路径到虚拟机对应路径下，设置所有用户可访问：$ sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other
执行以上命令后，发现共享文件夹出现了：$ ls /mnt/hgfs/
Development  Downloads  InstallationPackage以上就是解决 VMware Linux 虚拟机没有自动挂载共享目录的方法。</description>
</item>
</rdf:RDF>