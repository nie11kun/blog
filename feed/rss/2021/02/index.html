<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2021/02/">
<title>Marco Nie - 2021年2月</title>
<link>https://blog.niekun.net/2021/02/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2100.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2103.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2098.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2100.html">
<title>node.js 入门教程之四 -- Event Loop</title>
<link>https://blog.niekun.net/archives/2100.html</link>
<dc:date>2021-02-04T21:36:00+08:00</dc:date>
<description>Event Loop 事件循环event loop 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node.js 能够变得如此流行的原因之一。node.js 代码运行在单进程中，也就是说它在一刻只能执行一个任务。这一限制特性使得我们不用担心任务间冲突问题。我们在变开发中只需要专注于代码本身，同时应避免进程阻塞，例如同步方式等待网络请求，死循环等。通常情况下，浏览器中的每个 tab 页面都是都有各自独立的 event loop，防止某个页面的死循环或过高的资源消耗影响到整个浏览器的体验。我们只需要关注于我们的代码运行在一个单一的 event loop 中，编程中要注意到这一点，防止进程阻塞。JavaScript 代码中如果有长时间等待 return 返回给 event loop 控制时，任何其他代码将会被阻塞，也会阻塞页面 UI 单元，用户在此期间无法进行点击，滚动等操作。几乎所有的 JavaScript 原生 IO 指令都是 non-blocking 非阻塞式的，例如：网络请求，文件读写等，阻塞是一种 exception 例外情况，这也是 JavaScript 大量的使用 callback 方式，以及最近引入的 promise 和 async/await。call stack 调用结构JavaScript 的 call 调用过程的结构遵循 LIFO (Last In, First Out)，也就是总是先响应最近的任务。event loop 总是连续的检查 call stack 看是否有任务需要执行。在这个过程中，它会将发现的任务添加到 call stack 中并按顺序执行。下面是一个简单的示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    bar();
    baz();
}

foo();

//output:
//foo
//bar
//baz在以上示例中，首先会调用 foo()，在 foo 中首先会调用 bar()，然后调用 baz()。call stack 执行过程如下：在 event loop 的每次 iteration 递归执行中会查询 call stack 中是否有需要执行的任务，如果有则执行它，直到 loop 结束为止，如下是循环中的全过程：以上示例说明了 JavaScript 在一般情况下按顺序执行代码的过程。下面介绍如何将一个 function 推迟到 call stack 递归到最后时再被调用。需要使用以下的代码指令：setTimeout(() =&gt; {}, 0)
以上代码调用了 setTimeout 延时 function，但是将延时设置为 0，这样的意义就是要求它在可以执行的时候立刻执行其中定义的 function。那么如何才能让其在层级的最后再执行 function 呢？下面是一个完整的片段：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    baz();
}

foo();

//output:
//foo
//baz
//bar以上示例中，我们在 foo 中先调用 setTimeout function，并将时间设置为 0，要求其在可以执行时立刻执行内部定义的指令，以上示例循环的 call stack 过程如下：下面时循环的顺序执行全过程：为什么会是这样的执行顺序呢？为什么 setTimeout 时间设置为 0 反而最后才执行其 function？下面做介绍。Message Queue 消息队列当 setTimeout() 被调用时，浏览器或 node.js 会开启一个定时器，当定时时间到达时，这里我们设置为 0 也就是立刻到达了时间，callback 响应的 function 会被放到 Message Queue 消息队列中。Message Queue 消息队列也管理着用户主动触发的一些事件如鼠标点击键盘输入等，或者 fetch 获取响应信息，这些消息按顺序排列着等待被代码执行。call stack 和 Message Queue 是互相独立的，event loop 循环时 call stack 中的任务是优先的，它会首先查找 call stack 中需要执行的代码并按顺序执行，当 satck 执行完成后再去查看 Message Queue 中需要处理的任务。我们并不需要等待一些 functions 如 setTimeout 或 fetch 这些任务的执行过程，因为这些工作由浏览器提供且这些任务运行在它们单独的线程中。例如当我们设置了 setTimeout 2 秒的定时，我们并不需要停下来等待这 2 秒钟，而是会执行层级中接下来的指令。Job Queue 任务队列ES6 中引入了一种新的 Job Queue 任务队列概念，也就是 Promise。提供了在条件到达后立刻执行被调用 function 的方法，而不是等待到 call stack 结束。当 Promise 定义的 resolve 条件满足时，会在当前 function 执行结束后立刻执行 resolve function。简单的区分 Message Queue 和 Job Queue：Message Queue 会将出现的每个任务按顺序排列到队列最后，等待排队执行。而 Job Queue 就像拿到了快捷车票，会在前一个指令结束后立刻跳转到这个任务上来。下面是一个示例：const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();

//output:
//foo
//baz
//should be right after baz, before bar
//bar以上示例可以看到，promise 定义之后会运行 baz function，然后 promise 的 resolve 条件会立刻得到满足，此时异步任务会在 baz 执行结束后立刻被响应而不是排列到队列最后。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2103.html">
<title>Windows 10 配置共享文件夹</title>
<link>https://blog.niekun.net/archives/2103.html</link>
<dc:date>2021-02-03T10:28:00+08:00</dc:date>
<description>最近研究了下 Windows 的共享设置，目的是在同一局域网下共享文件夹给其他设备读写。下面从原理和实际操作上介绍下共享过程。SMBWindows 共享使用 Server Message Block (SMB) 协议，它可以让应用程序访问本机网络下的其他设备的文件及服务。SMB 是 IBM 在 1980 年代创造的协议，目前已经有了很多的升级及分支。SMB 协议允许应用程序访问远程主机的文件和资源如打印机等，也可以同远程主机上设置了接收 SMB 协议的应用程序通信。它运行在网络的 layer 7 层，也就是 application 应用层，使用 TCP/IP 的 445 端口传输数据。从 Windows 95 开始，微软将引入了 SMB 协议的支持。Linux 端，samba 作为一个开源软件提供 SMB 的支持。SMB 协议也是在不断发展的，下面是一个简单的版本更新过程：SMB 1.0 (1984): IBM 为 DOS 下的文件共享创造了 SMBCIFS (1996): 微软开发了 SMB 的分支版本并集成在 Windows 95，添加了大文件的支持，直接在 TCP/IP 传输SMB 2.0 (2006): 在 Windows Vista 和 Windows Server 2008 中发布. 提升了性能SMB 2.1 (2010): 在 Windows Server 2008 R2 和 Windows 7 中发布SMB 3.0 (2012): 在 Windows 8 和 Windows Server 2012 中发布. 提升了性能，增加备份，安全和管理功能SMB 3.02 (2014): 在 Windows 8.1 和 Windows Server 2012 R2 中发布. 提升性能并完全停止支持 CIFS/SMB 1.0SMB 3.1.1 (2015): 在 Windows 10 和 Windows Server 2016 中发布在 2017 年，利用 SMB 1.0 的漏洞，WannaCry 勒索软件在互联网中大规模传播，微软虽然立刻发布了补丁，但专家还是建议立刻停止运行 SMB 1.0 协议。Windows 设置共享下面介绍在 Windows 10 中配置共享文件夹。首先打开控制面板，进入 network and Internet：点击 network and sharing center：点击 change advanced sharing settings：在 current profile 中打开网络发现和文件共享：然后在 all network 中关闭密码保护(否则在其他设备访问时会提示输入账户密码)：控制面板配置完成后，我们开始配置需要共享的文件夹。在需要共享的文件夹上点击右键，选择属性：在 share 选项卡中点击 share：在下拉菜单中选择 everyone，然后点击 add：修改此文件夹的读写权限，我这里设置读和写：点击 share 开启共享：返回属性栏，点击 advanced share：选中 share this folder：点击 permission：设置共享权限，我这里设置为可读写：确认后共享文件夹就配置完成了。访问共享文件下面介绍在其他局域网设备访问主机的共享文件夹。Windows在 Windows 上，打开 file explorer，点击 network：在右侧就是本地网络下启用了网络发现的设备列表，点击进入设置了共享文件夹的设备名称就可以访问了：也可以在地址栏直接输入共享路径地址，以双反斜线\\开头后面是设备 IP 或名称，如：\\DESKTOP-BS3C55D。关于设备的名称，可以在终端通过 whoami 命令查询：iPhone在支持 SMB 协议的设备或应用程序中都可以打开 Windows 共享的文件，下面介绍通过 iPhone 的 files app 来连接到 Windows 共享目录。打开 files app，点击右上角的 ... 选择 connect to server：在 server 中输入共享主机的地址，这里直接输入 IP 地址：选择 guest 点击 next：完成后就可以访问到共享目录了：如果文件夹设置的是可读写权限，就可以在手机上传输文件到共享目录了。参考链接：Server Message Block Protocol (SMB protocol)</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2098.html">
<title>解除 UWP 应用的网络隔离</title>
<link>https://blog.niekun.net/archives/2098.html</link>
<dc:date>2021-02-02T09:33:00+08:00</dc:date>
<description>Microsoft store 里都是 UWP 应用，运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。该机制也阻止了 UWP 应用访问 localhost，如果你的代理地址在本地地址，UWP 就无法访问。有两种方法来解除某个 UWP 应用的沙盒隔离，一种是使用系统自带的工具 CheckNetIsolation，一种是使用第三方工具 fiddler。CheckNetIsolationWindows 10 自带了一个 CheckNetIsolation 工具，可以解除 UWP 应用的网络隔离，使之可以正常访问本地地址在终端执行以下指令即可：CheckNetIsolation.exe loopbackexempt -a -p=SID
SID(security identifier) 是每个 UWP 应用独有的识别码，可以从注册表中获得应用的 SID 码。快捷键 win + R 打开运行窗口，输入 regedit 进入注册表。访问如下路径：\HKEY_CURRENT_USER\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings\：此路径下的左侧文件夹名称就是当前安装的每个 UWP 应用的 SID 码，右侧的 DisplayName 就是应用的名称，可以用来帮助找到需要的应用 SID。复制需要解除隔离的应用的 SID 码执行上面的命令即可。然后应用就可以正常访问本地地址了，也可以使用抓包工具获取到流量。fiddler也可以使用第三方软件来实现以上任务，这里介绍 fiddler。fiddler 是一款免费的网络调试代理工具。官网地址：https://www.telerik.com/fiddler下载安装后打开应用，点击左上角的 WinConfig：会弹出所有 UWP 应用列表，找到需要解除隔离的应用，点击左侧的选择框，然后点击 save change 即可：此时再次运行对应的应用，就可以在 fiddler 看到应用的流量信息了。注意 fiddler 需要一直保持开启状态解除隔离才会生效。使用 fiddler 还可以方便的设置代理服务，使选中的应用通过代理访问网络，点击 tools - options：在弹出栏中，点击 gateway，选择 manual proxy configuration：第一行设置代理地址，模式为：proxyserver:8080
也可以根据网络协议设置：http=httpproxy:8080;https=httpsproxy:8080
第二行设置 bypass 忽略列表，可以设置忽略代理本地地址或其他需要排除的地址：&lt;local&gt;;*.extranet.example.com;
点击 ok 保存后即可，此时在 WinConfig 中选中的 UWP 应用就会通过代理地址访问网络。</description>
</item>
</rdf:RDF>